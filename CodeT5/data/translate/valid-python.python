a , b , x = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 0 : NEW_LINE INDENT print ( int ( b // x ) + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( int ( b // x ) + 1 - int ( ( a - 1 ) // x ) - 1 ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE l = [ tuple ( map ( int , input ( ) . split ( ) ) ) for _ in range ( m ) ] NEW_LINE l . sort ( key = lambda x : x [ 1 ] ) NEW_LINE dec = 0 NEW_LINE cur = 0 NEW_LINE for i in l : NEW_LINE INDENT if i [ 0 ] < cur <= i [ 1 ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT dec += 1 NEW_LINE cur = i [ 1 ] NEW_LINE DEDENT DEDENT print ( dec ) NEW_LINE
print ( 10 ** int ( input ( ) ) + 7 ) NEW_LINE
n = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE lis = [ int ( input ( ) ) for i in range ( n ) ] NEW_LINE lis . sort ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cou = 0 NEW_LINE for j in range ( n ) : NEW_LINE INDENT if i != j : NEW_LINE INDENT if lis [ i ] % lis [ j ] == 0 : NEW_LINE INDENT cou += 1 NEW_LINE DEDENT DEDENT DEDENT if cou % 2 == 1 : NEW_LINE INDENT ans += 0.5 NEW_LINE DEDENT else : NEW_LINE INDENT ans += ( cou + 2 ) / ( 2 * cou + 2 ) NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
def main ( ) : NEW_LINE INDENT H , W = map ( int , input ( ) . split ( ) ) NEW_LINE g_list = [ ] NEW_LINE for i in range ( 10 ) : NEW_LINE INDENT g_list . append ( list ( map ( int , input ( ) . split ( ) ) ) ) NEW_LINE DEDENT min_change = [ j [ 1 ] for j in g_list ] NEW_LINE flag = [ 0 for _ in range ( 10 ) ] NEW_LINE tep = [ ( j , g ) for j , g in enumerate ( min_change ) if j != 1 ] NEW_LINE min_g = min ( tep , key = lambda a : a [ 1 ] ) [ 0 ] NEW_LINE flag [ min_g ] = 1 NEW_LINE while sum ( flag ) != 9 : NEW_LINE INDENT for j in range ( 10 ) : NEW_LINE INDENT if g_list [ j ] [ min_g ] + min_change [ min_g ] < min_change [ j ] : NEW_LINE INDENT min_change [ j ] = g_list [ j ] [ min_g ] + min_change [ min_g ] NEW_LINE DEDENT DEDENT tep = [ ( k , g ) for k , g in enumerate ( min_change ) if flag [ k ] == 0 and k != 1 ] NEW_LINE if tep != [ ] : NEW_LINE INDENT min_g = min ( tep , key = lambda a : a [ 1 ] ) [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT flag [ min_g ] = 1 NEW_LINE DEDENT s = 0 NEW_LINE for i in range ( H ) : NEW_LINE INDENT wall = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE s += sum ( [ min_change [ i ] for i in wall if i != - 1 ] ) NEW_LINE DEDENT return s NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( main ( ) ) NEW_LINE DEDENT
AB , BC , CA = map ( int , input ( ) . split ( ) ) NEW_LINE print ( AB * BC // 2 ) NEW_LINE
s = input ( ) NEW_LINE t = ' ' NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if s [ i ] == ' a ' or s [ i ] == ' i ' or s [ i ] == ' u ' or s [ i ] == ' e ' or s [ i ] == ' o ' : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT t += s [ i ] NEW_LINE DEDENT DEDENT print ( t ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n > 63 : NEW_LINE INDENT print ( 64 ) NEW_LINE DEDENT elif n > 31 : NEW_LINE INDENT print ( 32 ) NEW_LINE DEDENT elif n > 15 : NEW_LINE INDENT print ( 16 ) NEW_LINE DEDENT elif n > 7 : NEW_LINE INDENT print ( 8 ) NEW_LINE DEDENT elif n > 3 : NEW_LINE INDENT print ( 4 ) NEW_LINE DEDENT elif n > 1 : NEW_LINE INDENT print ( 2 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT
from collections import Counter NEW_LINE n = int ( input ( ) ) NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a . sort ( ) NEW_LINE c = Counter ( a ) NEW_LINE if len ( c ) > 2 or a [ 0 ] + 1 < a [ - 1 ] : print ( " No " ) NEW_LINE elif len ( c ) == 1 : NEW_LINE INDENT if a [ 0 ] + 1 == n or n >= 2 * a [ 0 ] : print ( " Yes " ) NEW_LINE else : print ( " No " ) NEW_LINE DEDENT else : NEW_LINE INDENT x , y = c [ a [ - 1 ] ] , c [ a [ 0 ] ] NEW_LINE if y + 1 <= a [ - 1 ] <= x // 2 + y : print ( " Yes " ) NEW_LINE else : print ( " No " ) NEW_LINE DEDENT
n = int ( input ( ) ) NEW_LINE for i in range ( 2 , n // 2 + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT print ( " NO " ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT
from numpy import * ; B = searchsorted ; a , b = split ( int32 ( open ( 0 ) . read ( ) . split ( ) [ 1 : ] ) , 2 ) ; c = 0 NEW_LINE for k in range ( 29 ) : l = 2 ** k ; h = 2 * l ; y = sort ( hstack ( ( b % h - h , b % h ) ) ) ; c += sum ( B ( y , h - a % h ) - B ( y , l - a % h ) ) % 2 * l NEW_LINE print ( c ) NEW_LINE
n = int ( input ( ) ) NEW_LINE p = 10 ** 9 + 7 NEW_LINE def fact ( n ) : NEW_LINE INDENT n_ = 1 NEW_LINE yield n_ NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT n_ = ( n_ * i ) % p NEW_LINE yield n_ NEW_LINE DEDENT DEDENT def invfact ( n , f , p ) : NEW_LINE INDENT m = pow ( f [ n ] , p - 2 , p ) NEW_LINE yield m NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT m = m * i % p NEW_LINE yield m NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE m = n - 1 NEW_LINE f = list ( fact ( m ) ) NEW_LINE rf = list ( invfact ( m , f , p ) ) NEW_LINE rf . reverse ( ) NEW_LINE perm = 0 NEW_LINE for k in range ( ( n + 1 ) // 2 , n ) : NEW_LINE INDENT b = m - k NEW_LINE a = ( m - 1 ) - ( 2 * b ) NEW_LINE perm_ = f [ a + b ] * rf [ a ] % p * f [ k ] % p NEW_LINE ans += ( perm_ - perm ) % p * k % p NEW_LINE ans %= p NEW_LINE perm = perm_ NEW_LINE DEDENT print ( ans ) NEW_LINE
import bisect NEW_LINE N = int ( input ( ) ) NEW_LINE L = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT L . append ( int ( input ( ) ) ) NEW_LINE DEDENT dp = [ float ( ' inf ' ) ] * N NEW_LINE dp [ 0 ] = L [ 0 ] NEW_LINE for i in range ( 1 , N ) : NEW_LINE INDENT k = bisect . bisect_left ( dp , L [ i ] ) NEW_LINE dp [ k ] = L [ i ] NEW_LINE DEDENT endnum = bisect . bisect_left ( dp , N + 1 ) NEW_LINE print ( N - endnum ) NEW_LINE
iipt = lambda : int ( input ( ) ) NEW_LINE miipt = lambda : list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE from pprint import pprint NEW_LINE n = iipt ( ) NEW_LINE hs = [ miipt ( ) for i in range ( n ) ] NEW_LINE a = 0 NEW_LINE b = int ( 1e15 ) NEW_LINE while b - a > 1 : NEW_LINE INDENT c = ( a + b ) // 2 NEW_LINE tl = sorted ( [ ( c - h ) // s for h , s in hs ] ) NEW_LINE if all ( t <= i for t , i in enumerate ( tl ) ) : NEW_LINE INDENT b = c NEW_LINE DEDENT else : NEW_LINE INDENT a = c NEW_LINE DEDENT DEDENT print ( b ) NEW_LINE
n = int ( input ( ) ) NEW_LINE print ( n * 2 ) NEW_LINE
from itertools import accumulate as ac NEW_LINE n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = [ 0 ] + list ( ac ( a ) ) NEW_LINE c = [ 0 ] + list ( ac ( [ ( 0 if i < 0 else i ) for i in a ] ) ) NEW_LINE d = 0 NEW_LINE for i in range ( n - k + 1 ) : NEW_LINE INDENT d = max ( d , max ( b [ i + k ] - b [ i ] , 0 ) + c [ i ] + c [ - 1 ] - c [ i + k ] ) NEW_LINE DEDENT print ( d ) NEW_LINE
n = int ( input ( ) ) NEW_LINE AB = [ list ( map ( int , input ( ) . split ( ) ) ) for i in range ( n ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT a = AB [ i ] [ 0 ] + ans NEW_LINE b = AB [ i ] [ 1 ] NEW_LINE if a % b == 0 : NEW_LINE INDENT tmp = 0 NEW_LINE DEDENT else : NEW_LINE INDENT tmp = b - ( a % b ) NEW_LINE DEDENT ans += tmp NEW_LINE DEDENT print ( ans ) NEW_LINE
N = input ( ) NEW_LINE cnt = 0 NEW_LINE for i in N : NEW_LINE INDENT cnt += int ( i ) NEW_LINE DEDENT if int ( N ) % cnt == 0 : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE if any ( [ a < b for a , b in zip ( A , B ) ] ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT if A == B : NEW_LINE INDENT print ( 0 ) NEW_LINE exit ( ) NEW_LINE DEDENT def reachable ( a , b , gr ) : NEW_LINE INDENT if a == b : return True NEW_LINE assert a > b NEW_LINE visited = [ 0 ] * ( a + 1 ) NEW_LINE stack = [ a ] NEW_LINE while stack : NEW_LINE INDENT v = stack . pop ( ) NEW_LINE if v == b : return True NEW_LINE visited [ v ] = 1 NEW_LINE for to in gr [ v ] : NEW_LINE INDENT if visited [ to ] : continue NEW_LINE stack . append ( to ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT permanent_use = [ ] NEW_LINE def need ( n ) : NEW_LINE INDENT gr = [ set ( ) for i in range ( 51 ) ] NEW_LINE for i in range ( 51 ) : NEW_LINE INDENT for p in permanent_use : NEW_LINE INDENT gr [ i ] . add ( i % p ) NEW_LINE DEDENT for j in range ( 1 , n ) : NEW_LINE INDENT gr [ i ] . add ( i % j ) NEW_LINE DEDENT DEDENT for a , b in zip ( A , B ) : NEW_LINE INDENT if not reachable ( a , b , gr ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if need ( 51 ) : NEW_LINE INDENT print ( - 1 ) NEW_LINE exit ( ) NEW_LINE DEDENT for i in range ( 50 , 0 , - 1 ) : NEW_LINE INDENT if need ( i ) : NEW_LINE INDENT permanent_use . append ( i ) NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for p in permanent_use : NEW_LINE INDENT ans += 2 ** p NEW_LINE DEDENT print ( ans ) NEW_LINE
def lower_bound ( l , x ) : NEW_LINE INDENT imin = - 1 NEW_LINE imax = len ( l ) NEW_LINE while imax - imin > 1 : NEW_LINE INDENT imid = ( imax + imin ) // 2 NEW_LINE if l [ imid ] >= x : NEW_LINE INDENT imax = imid NEW_LINE DEDENT else : NEW_LINE INDENT imin = imid NEW_LINE DEDENT DEDENT if imax == len ( l ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT return l [ imax ] NEW_LINE DEDENT NA , NB = map ( int , input ( ) . split ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE B . sort ( ) NEW_LINE AB = 0 NEW_LINE for i in A : NEW_LINE INDENT if lower_bound ( B , i ) == i : NEW_LINE INDENT AB += 1 NEW_LINE DEDENT DEDENT print ( AB / ( NA + NB - AB ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE print ( - ( - N // 2 ) ) NEW_LINE
n = int ( input ( ) ) NEW_LINE a = [ 0 ] * n NEW_LINE b = [ 0 ] * n NEW_LINE temp = 10 ** 10 NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] , b [ i ] = map ( int , input ( ) . split ( ) ) NEW_LINE if a [ i ] > b [ i ] : NEW_LINE INDENT temp = min ( temp , b [ i ] ) NEW_LINE DEDENT DEDENT if temp == 10 ** 10 : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( sum ( a ) - temp ) NEW_LINE DEDENT
N , L = map ( int , input ( ) . split ( ) ) NEW_LINE S = input ( ) NEW_LINE tab = 1 NEW_LINE ans = 0 NEW_LINE for s in S : NEW_LINE INDENT if s == ' + ' : NEW_LINE INDENT tab += 1 NEW_LINE DEDENT if s == ' - ' : NEW_LINE INDENT tab -= 1 NEW_LINE DEDENT if tab > L : NEW_LINE INDENT tab = 1 NEW_LINE ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
N = int ( input ( ) ) NEW_LINE A = int ( input ( ) ) NEW_LINE num = N % 500 NEW_LINE if ( num <= A ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
A , B , C = map ( int , input ( ) . split ( ) ) NEW_LINE ans = min ( C , A + B + 1 ) NEW_LINE ans += B NEW_LINE print ( ans ) NEW_LINE
n = int ( input ( ) ) NEW_LINE if n < 1200 : NEW_LINE INDENT print ( ' ABC ' ) NEW_LINE DEDENT elif n < 2800 : NEW_LINE INDENT print ( ' ARC ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' AGC ' ) NEW_LINE DEDENT
import math , string , itertools , fractions , heapq , collections , re , array , bisect , sys , random , time , copy , functools NEW_LINE sys . setrecursionlimit ( 10 ** 7 ) NEW_LINE inf = 10 ** 20 NEW_LINE mod = 10 ** 9 + 7 NEW_LINE def LI ( ) : return [ int ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LI_ ( ) : return [ int ( x ) - 1 for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LF ( ) : return [ float ( x ) for x in sys . stdin . readline ( ) . split ( ) ] NEW_LINE def LS ( ) : return sys . stdin . readline ( ) . split ( ) NEW_LINE def I ( ) : return int ( sys . stdin . readline ( ) ) NEW_LINE def F ( ) : return float ( sys . stdin . readline ( ) ) NEW_LINE def S ( ) : return input ( ) NEW_LINE def main ( ) : NEW_LINE INDENT n = I ( ) NEW_LINE a , b = LI ( ) NEW_LINE if n <= a : NEW_LINE INDENT return ' Takahashi ' NEW_LINE DEDENT if n <= b + 1 : NEW_LINE INDENT return ' Aoki ' NEW_LINE DEDENT if a == b and n % ( a + 1 ) == 0 : NEW_LINE INDENT return ' Aoki ' NEW_LINE DEDENT if a >= b : NEW_LINE INDENT return ' Takahashi ' NEW_LINE DEDENT return ' Aoki ' NEW_LINE DEDENT print ( main ( ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE ans = 0 NEW_LINE A = list ( int ( input ( ) ) for i in range ( N ) ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT ans += A [ i ] // 2 NEW_LINE if i != N - 1 : NEW_LINE INDENT if A [ i ] >= 2 : NEW_LINE INDENT A [ i + 1 ] += A [ i ] % 2 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
import itertools NEW_LINE n = int ( input ( ) ) NEW_LINE nums = [ ] NEW_LINE pre_nums = [ '3' , '5' , '7' ] NEW_LINE for i in range ( 3 , 10 ) : NEW_LINE INDENT for ids in itertools . product ( pre_nums , repeat = i ) : NEW_LINE INDENT if '3' in ids and '5' in ids and '7' in ids : NEW_LINE INDENT nums . append ( int ( ' ' . join ( ids ) ) ) NEW_LINE DEDENT DEDENT DEDENT for i , num in enumerate ( nums ) : NEW_LINE INDENT if n < num : NEW_LINE INDENT print ( i ) NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT print ( len ( nums ) ) NEW_LINE DEDENT
from math import ceil NEW_LINE N = int ( input ( ) ) NEW_LINE A = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE num2 = 0 NEW_LINE num4 = 0 NEW_LINE numO = 0 NEW_LINE for num in A : NEW_LINE INDENT if num % 4 == 0 : NEW_LINE INDENT num4 += 1 NEW_LINE continue NEW_LINE DEDENT elif num % 2 == 0 : NEW_LINE INDENT num2 += 1 NEW_LINE continue NEW_LINE DEDENT else : NEW_LINE INDENT numO += 1 NEW_LINE DEDENT DEDENT if num2 > 0 : NEW_LINE INDENT if numO > num4 : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if numO > ceil ( ( num4 + numO ) / 2 ) : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT DEDENT
a = int ( input ( ) ) NEW_LINE b = int ( input ( ) ) NEW_LINE c = int ( input ( ) ) NEW_LINE x = int ( input ( ) ) NEW_LINE cnt = 0 NEW_LINE for i in range ( a + 1 ) : NEW_LINE INDENT for j in range ( b + 1 ) : NEW_LINE INDENT for k in range ( c + 1 ) : NEW_LINE INDENT if 500 * i + 100 * j + 50 * k == x : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( cnt ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a <= 0 and b >= 0 : NEW_LINE INDENT print ( ' Zero ' ) NEW_LINE DEDENT elif a > 0 and b > 0 : NEW_LINE INDENT print ( ' Positive ' ) NEW_LINE DEDENT else : NEW_LINE INDENT num = b - a + 1 NEW_LINE if num % 2 == 1 : NEW_LINE INDENT print ( ' Negative ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' Positive ' ) NEW_LINE DEDENT DEDENT
def main ( ) : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE As = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ct = 1 NEW_LINE inc = False NEW_LINE dec = False NEW_LINE bef = As . pop ( 0 ) NEW_LINE for Ai in As : NEW_LINE INDENT if ( not inc ) and ( not dec ) : NEW_LINE INDENT if Ai < bef : NEW_LINE INDENT dec = True NEW_LINE DEDENT elif Ai > bef : NEW_LINE INDENT inc = True NEW_LINE DEDENT DEDENT elif inc : NEW_LINE INDENT if Ai < bef : NEW_LINE INDENT ct += 1 NEW_LINE inc = False NEW_LINE DEDENT DEDENT elif dec : NEW_LINE INDENT if Ai > bef : NEW_LINE INDENT ct += 1 NEW_LINE dec = False NEW_LINE DEDENT DEDENT bef = Ai NEW_LINE DEDENT print ( ct ) NEW_LINE DEDENT main ( ) NEW_LINE
n = int ( input ( ) ) NEW_LINE s = input ( ) . rstrip ( ' . ' ) . split ( ) NEW_LINE ans = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if s [ i ] == ' TAKAHASHIKUN ' or s [ i ] == ' Takahashikun ' or s [ i ] == ' takahashikun ' : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT print ( ans ) NEW_LINE
from bisect import bisect_right NEW_LINE N = int ( input ( ) ) NEW_LINE X = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE L = int ( input ( ) ) NEW_LINE P = [ [ 0 ] * N for i in range ( 30 ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT q = bisect_right ( X , X [ i ] + L ) NEW_LINE P [ 0 ] [ i ] = q - 1 NEW_LINE DEDENT for i in range ( 1 , 30 ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT P [ i ] [ j ] = P [ i - 1 ] [ P [ i - 1 ] [ j ] ] NEW_LINE DEDENT DEDENT Q = int ( input ( ) ) NEW_LINE for i in range ( Q ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a > b : NEW_LINE INDENT a , b = b , a NEW_LINE DEDENT a , b = a - 1 , b - 1 NEW_LINE num = 0 NEW_LINE for j in range ( 29 , - 1 , - 1 ) : NEW_LINE INDENT if P [ j ] [ a ] < b : NEW_LINE INDENT a = P [ j ] [ a ] NEW_LINE num += 2 ** j NEW_LINE DEDENT DEDENT print ( num + 1 ) NEW_LINE DEDENT
import numpy as np NEW_LINE def solve ( l , r ) : NEW_LINE INDENT l . reverse ( ) NEW_LINE stops = [ ] NEW_LINE if l and r : NEW_LINE INDENT while l and r : NEW_LINE INDENT lx , lp = l . pop ( ) NEW_LINE rx , rp = r . pop ( ) NEW_LINE if lp >= rp : NEW_LINE INDENT l . append ( ( lx , lp + rp ) ) NEW_LINE stops . append ( rx ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( ( rx , lp + rp ) ) NEW_LINE stops . append ( lx ) NEW_LINE DEDENT DEDENT DEDENT if l : NEW_LINE INDENT stops . append ( l [ - 1 ] [ 0 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT stops . append ( r [ - 1 ] [ 0 ] ) NEW_LINE DEDENT stops . append ( s ) NEW_LINE return abs ( np . diff ( np . array ( stops , dtype = np . int64 ) ) ) . sum ( ) NEW_LINE DEDENT n , s = map ( int , input ( ) . split ( ) ) NEW_LINE l , r = [ ] , [ ] NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , p = map ( int , input ( ) . split ( ) ) NEW_LINE if x < s : NEW_LINE INDENT l . append ( ( x , p ) ) NEW_LINE DEDENT else : NEW_LINE INDENT r . append ( ( x , p ) ) NEW_LINE DEDENT DEDENT print ( solve ( l , r ) ) NEW_LINE
print ( ' Yes ' if set ( input ( ) ) == { ' a ' , ' b ' , ' c ' } else ' No ' ) NEW_LINE
a , k = map ( int , input ( ) . split ( ) ) NEW_LINE if k == 0 : NEW_LINE INDENT print ( 2 * 10 ** 12 - a ) NEW_LINE DEDENT else : NEW_LINE INDENT count = 0 NEW_LINE while a < 2 * 10 ** 12 : NEW_LINE INDENT count += 1 NEW_LINE a += 1 + a * k NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE n = m = l = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE n = max ( n , a [ 0 ] ) NEW_LINE m = max ( m , a [ 1 ] ) NEW_LINE l = max ( l , a [ 2 ] ) NEW_LINE DEDENT print ( n * m * l ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) NEW_LINE count = [ 0 ] * n NEW_LINE for i in range ( m ) : NEW_LINE INDENT a , b = map ( int , input ( ) . split ( ) ) NEW_LINE a -= 1 NEW_LINE b -= 1 NEW_LINE count [ a ] += 1 NEW_LINE count [ b ] += 1 NEW_LINE DEDENT for i in count : NEW_LINE INDENT if i % 2 == 1 : NEW_LINE INDENT print ( " NO " ) NEW_LINE exit ( ) NEW_LINE DEDENT DEDENT print ( " YES " ) NEW_LINE
N , x = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE a = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE cnt = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if a [ i ] > x : NEW_LINE INDENT cnt += a [ i ] - x NEW_LINE a [ i ] = x NEW_LINE DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT su = a [ i - 1 ] + a [ i ] NEW_LINE if su > x : NEW_LINE INDENT sub = su - x NEW_LINE a [ i ] -= sub NEW_LINE cnt += sub NEW_LINE DEDENT DEDENT print ( cnt ) NEW_LINE
s1 , s2 = map ( str , input ( ) . split ( ) ) NEW_LINE if s1 == s2 : NEW_LINE INDENT print ( ' H ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' D ' ) NEW_LINE DEDENT
tx_a , ty_a , tx_b , ty_b , T , V = map ( int , input ( ) . split ( ) ) NEW_LINE n = int ( input ( ) ) NEW_LINE flag = False NEW_LINE for _ in range ( n ) : NEW_LINE INDENT x , y = map ( int , input ( ) . split ( ) ) NEW_LINE if ( ( x - tx_a ) ** 2 + ( y - ty_a ) ** 2 ) ** ( 1 / 2 ) + ( ( tx_b - x ) ** 2 + ( ty_b - y ) ** 2 ) ** ( 1 / 2 ) <= T * V : NEW_LINE INDENT flag = True NEW_LINE DEDENT DEDENT print ( ' YES ' if flag else ' NO ' ) NEW_LINE
N = set ( map ( int , input ( ) . split ( ) ) ) NEW_LINE A = { 1 , 3 , 5 , 7 , 8 , 10 , 12 } NEW_LINE B = { 4 , 6 , 9 , 11 } NEW_LINE C = { 2 } NEW_LINE if ( N <= A or N <= B or N <= C ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE d = defaultdict NEW_LINE n , c = map ( int , input ( ) . split ( ) ) NEW_LINE do = d ( int ) NEW_LINE de = d ( int ) NEW_LINE do [ 0 ] = 0 NEW_LINE de [ 0 ] = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT do [ input ( ) ] += 1 NEW_LINE de [ input ( ) ] += 1 NEW_LINE DEDENT if n % 2 : NEW_LINE INDENT do [ input ( ) ] += 1 NEW_LINE DEDENT o = max ( do , key = do . get ) NEW_LINE e = max ( de , key = de . get ) NEW_LINE if o != e : NEW_LINE INDENT print ( ( n - do [ o ] - de [ e ] ) * c ) NEW_LINE DEDENT else : NEW_LINE INDENT vo = do . pop ( o ) NEW_LINE ve = de . pop ( e ) NEW_LINE vo2 = max ( do . values ( ) ) NEW_LINE ve2 = max ( de . values ( ) ) NEW_LINE print ( ( n - max ( vo + ve2 , ve + vo2 ) ) * c ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE md = [ [ int ( _ ) for _ in input ( ) . split ( " / " ) ] for i in range ( N ) ] NEW_LINE day_of_month = [ 0 , 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 ] NEW_LINE from itertools import accumulate NEW_LINE index_of_month = list ( accumulate ( day_of_month ) ) NEW_LINE ds = [ 0 ] * 367 NEW_LINE for i in range ( 1 , len ( ds ) , 7 ) : NEW_LINE INDENT ds [ i ] = 1 NEW_LINE DEDENT for i in range ( 7 , len ( ds ) , 7 ) : NEW_LINE INDENT ds [ i ] = 1 NEW_LINE DEDENT for m , d in md : NEW_LINE INDENT i = index_of_month [ m - 1 ] + d NEW_LINE while ds [ i ] == 1 and i + 1 < len ( ds ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT ds [ i ] = 1 NEW_LINE DEDENT result = max ( len ( r ) for r in ( " " . join ( chr ( 32 + c ) for c in ds ) ) . split ( ) ) NEW_LINE print ( result ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) NEW_LINE x , y = map ( int , input ( ) . split ( ) ) NEW_LINE C = [ [ 0 for j in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE C [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT C [ i ] [ 0 ] = C [ i - 1 ] [ 0 ] / 2 NEW_LINE for j in range ( 1 , i + 1 ) : NEW_LINE INDENT C [ i ] [ j ] = ( C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ) / 2 NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT k = ( i * d - x ) // d NEW_LINE l = ( j * d - y ) // d NEW_LINE if 0 <= k <= n and 0 <= l <= n and ( i - k ) * d == x and ( j - l ) * d == y and i + j + k + l == n : NEW_LINE INDENT ans += C [ n ] [ i + k ] * C [ i + k ] [ i ] * C [ j + l ] [ j ] NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
a = int ( input ( ) ) NEW_LINE b = a + 1 NEW_LINE a = a * a NEW_LINE b = b * b - 1 NEW_LINE while ( a + 99 ) // 100 <= b // 100 : NEW_LINE INDENT a = ( a + 99 ) // 100 NEW_LINE b //= 100 NEW_LINE DEDENT print ( a ) NEW_LINE
from collections import defaultdict NEW_LINE A = list ( input ( ) ) NEW_LINE N = len ( A ) NEW_LINE D = defaultdict ( int ) NEW_LINE for i in A : NEW_LINE INDENT D [ i ] += 1 NEW_LINE DEDENT ans = 1 + int ( N * ( N - 1 ) / 2 ) NEW_LINE for i in D : NEW_LINE INDENT ans -= int ( D [ i ] * ( D [ i ] - 1 ) / 2 ) NEW_LINE DEDENT print ( ans ) NEW_LINE
N , M = map ( int , input ( ) . split ( ) ) NEW_LINE src = [ int ( input ( ) ) for i in range ( N ) ] NEW_LINE used = [ 0 ] * ( M + 1 ) NEW_LINE rtol = [ None ] * N NEW_LINE ans = 0 NEW_LINE r = 0 NEW_LINE for l in range ( N ) : NEW_LINE INDENT while r < N and not used [ src [ r ] ] : NEW_LINE INDENT used [ src [ r ] ] += 1 NEW_LINE rtol [ r ] = l NEW_LINE r += 1 NEW_LINE DEDENT used [ src [ l ] ] -= 1 NEW_LINE DEDENT MOD = 10 ** 9 + 7 NEW_LINE dp = [ 1 ] NEW_LINE cdp = [ 0 , 1 ] NEW_LINE for r in range ( N ) : NEW_LINE INDENT l = rtol [ r ] NEW_LINE dp . append ( cdp [ - 1 ] - cdp [ l ] ) NEW_LINE cdp . append ( ( cdp [ - 1 ] + dp [ - 1 ] ) % MOD ) NEW_LINE DEDENT print ( dp [ - 1 ] % MOD ) NEW_LINE
h , w , d = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( h ) ] NEW_LINE q = int ( input ( ) ) NEW_LINE l = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( q ) ] NEW_LINE dic = { } NEW_LINE for i in range ( len ( a ) ) : NEW_LINE INDENT for j in range ( len ( a [ i ] ) ) : NEW_LINE INDENT dic [ a [ i ] [ j ] ] = ( i , j ) NEW_LINE DEDENT DEDENT sum = [ 0 ] * ( h * w + 1 ) NEW_LINE for i in range ( d + 1 , h * w + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - d ] + abs ( dic [ i ] [ 0 ] - dic [ i - d ] [ 0 ] ) + abs ( dic [ i ] [ 1 ] - dic [ i - d ] [ 1 ] ) NEW_LINE DEDENT for l_ in l : NEW_LINE INDENT print ( sum [ l_ [ 1 ] ] - sum [ l_ [ 0 ] ] ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE def make_divisors ( n ) : NEW_LINE INDENT divisors = [ ] NEW_LINE for i in range ( 1 , int ( n ** 0.5 ) + 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT divisors . append ( i ) NEW_LINE if i != n // i : NEW_LINE INDENT divisors . append ( n // i ) NEW_LINE DEDENT DEDENT DEDENT return divisors NEW_LINE DEDENT ans = 0 NEW_LINE if N % 2 == 0 : NEW_LINE INDENT for j in range ( int ( N / 2 ) ) : NEW_LINE INDENT temp = len ( make_divisors ( 2 * j + 1 ) ) NEW_LINE if temp == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT for j in range ( int ( N / 2 ) + 1 ) : NEW_LINE INDENT temp = len ( make_divisors ( 2 * j + 1 ) ) NEW_LINE if temp == 8 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT DEDENT DEDENT print ( ans ) NEW_LINE
def max_mul ( A : int ) -> int : NEW_LINE INDENT return ( A * A ) // 4 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = int ( input ( ) ) NEW_LINE ans = max_mul ( A ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def eval_test ( N : int ) -> int : NEW_LINE INDENT if N < 60 : NEW_LINE INDENT return ' Bad ' NEW_LINE DEDENT if N < 90 : NEW_LINE INDENT return ' Good ' NEW_LINE DEDENT if N < 100 : NEW_LINE INDENT return ' Great ' NEW_LINE DEDENT return ' Perfect ' NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = int ( input ( ) ) NEW_LINE ans = eval_test ( N ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def inin ( ) : NEW_LINE INDENT return int ( input ( ) ) NEW_LINE DEDENT def insp ( ) : NEW_LINE INDENT return input ( ) . split ( ) NEW_LINE DEDENT s = [ ] NEW_LINE d = [ ] NEW_LINE r = [ ] NEW_LINE def dfs ( x , y ) : NEW_LINE INDENT global s NEW_LINE global d NEW_LINE global r NEW_LINE if d [ x ] [ y ] : NEW_LINE INDENT return r [ x ] [ y ] NEW_LINE DEDENT d [ x ] [ y ] = True NEW_LINE if s [ x ] [ y ] == ' # ' : NEW_LINE INDENT r [ x ] [ y ] = True NEW_LINE return r [ x ] [ y ] NEW_LINE DEDENT if not dfs ( x , y + 1 ) : NEW_LINE INDENT r [ x ] [ y ] = True NEW_LINE return r [ x ] [ y ] NEW_LINE DEDENT if not dfs ( x + 1 , y ) : NEW_LINE INDENT r [ x ] [ y ] = True NEW_LINE return r [ x ] [ y ] NEW_LINE DEDENT if not dfs ( x + 1 , y + 1 ) : NEW_LINE INDENT r [ x ] [ y ] = True NEW_LINE return r [ x ] [ y ] NEW_LINE DEDENT r [ x ] [ y ] = False NEW_LINE return r [ x ] [ y ] NEW_LINE DEDENT h , w = map ( int , insp ( ) ) NEW_LINE for i in range ( h + 2 ) : NEW_LINE INDENT d . append ( [ ] ) NEW_LINE r . append ( [ ] ) NEW_LINE for j in range ( w + 2 ) : NEW_LINE INDENT d [ i ] . append ( False ) NEW_LINE r [ i ] . append ( False ) NEW_LINE DEDENT DEDENT s . append ( [ ] ) NEW_LINE for i in range ( w + 2 ) : NEW_LINE INDENT s [ 0 ] . append ( ' # ' ) NEW_LINE DEDENT for i in range ( h ) : NEW_LINE INDENT s . append ( [ ' # ' ] + list ( input ( ) ) + [ ' # ' ] ) NEW_LINE DEDENT s . append ( [ ] ) NEW_LINE for i in range ( w + 2 ) : NEW_LINE INDENT s [ h + 1 ] . append ( ' # ' ) NEW_LINE DEDENT if dfs ( 1 , 1 ) : NEW_LINE INDENT print ( " First " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Second " ) NEW_LINE DEDENT
s = input ( ) . rstrip ( ) NEW_LINE t = input ( ) . rstrip ( ) NEW_LINE pushable = [ 1 ] * ( len ( s ) - len ( t ) + 1 ) NEW_LINE for i in range ( len ( s ) - len ( t ) + 1 ) : NEW_LINE INDENT for j in range ( len ( t ) ) : NEW_LINE INDENT if s [ i + j ] != t [ j ] and s [ i + j ] != " ? " : NEW_LINE INDENT pushable [ i ] = 0 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if 1 not in pushable : NEW_LINE INDENT print ( " UNRESTORABLE " ) NEW_LINE exit ( ) NEW_LINE DEDENT ans = [ ] NEW_LINE for i , p in enumerate ( pushable ) : NEW_LINE INDENT cand = s NEW_LINE if p : NEW_LINE INDENT for j in range ( len ( t ) ) : NEW_LINE INDENT cand = cand [ : i + j ] + t [ j ] + cand [ i + j + 1 : ] NEW_LINE DEDENT for j in range ( len ( s ) ) : NEW_LINE INDENT if cand [ j ] == " ? " : NEW_LINE INDENT cand = cand [ : j ] + " a " + cand [ j + 1 : ] NEW_LINE DEDENT DEDENT ans . append ( cand ) NEW_LINE DEDENT DEDENT print ( sorted ( ans ) [ 0 ] ) NEW_LINE
n = int ( input ( ) ) NEW_LINE c = [ ] NEW_LINE s = [ ] NEW_LINE f = [ ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT x , y , z = map ( int , input ( ) . split ( ) ) NEW_LINE c . append ( x ) NEW_LINE s . append ( y ) NEW_LINE f . append ( z ) NEW_LINE DEDENT for i in range ( n - 1 ) : NEW_LINE INDENT t = 0 NEW_LINE for j in range ( i , n - 1 ) : NEW_LINE INDENT if t <= s [ j ] : NEW_LINE INDENT w = s [ j ] - t NEW_LINE DEDENT else : NEW_LINE INDENT w = ( f [ j ] - ( t - s [ j ] ) % f [ j ] ) % f [ j ] NEW_LINE DEDENT t += w NEW_LINE t += c [ j ] NEW_LINE DEDENT print ( t ) NEW_LINE DEDENT print ( 0 ) NEW_LINE
n = input ( ) NEW_LINE if "9" in n : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
a , b = map ( int , input ( ) . split ( ) ) NEW_LINE d = [ " N " , " NNE " , " NE " , " ENE " , " E " , " ESE " , " SE " , " SSE " , " S " , " SSW " , " SW " , " WSW " , " W " , " WNW " , " NW " , " NNW " ] NEW_LINE if a < 112.5 or a >= 3487.5 : NEW_LINE INDENT a = d [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT a = d [ int ( ( a + 112.5 ) / 225 ) ] NEW_LINE DEDENT w = [ 0.2 , 1.5 , 3.3 , 5.4 , 7.9 , 10.7 , 13.8 , 17.1 , 20.7 , 24.4 , 28.4 , 32.6 ] NEW_LINE b /= 60 NEW_LINE b += 0.00001 NEW_LINE c = int ( b * 100 ) NEW_LINE if c % 10 >= 5 : NEW_LINE INDENT c += 10 NEW_LINE DEDENT c //= 10 NEW_LINE b = c / 10.0 NEW_LINE for i in range ( 12 ) : NEW_LINE INDENT if b <= w [ i ] : NEW_LINE INDENT b = i NEW_LINE break NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT b = 12 NEW_LINE DEDENT if b == 0 : NEW_LINE INDENT print ( ' C ▁ 0' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( a , b ) NEW_LINE DEDENT
import heapq NEW_LINE def coord_on_edge ( x , y , R , C ) : NEW_LINE INDENT if y == 0 : NEW_LINE INDENT return x NEW_LINE DEDENT if x == R : NEW_LINE INDENT return R + y NEW_LINE DEDENT if y == C : NEW_LINE INDENT return R + C + R - x NEW_LINE DEDENT if x == 0 : NEW_LINE INDENT return 2 * ( R + C ) - y NEW_LINE DEDENT return None NEW_LINE DEDENT def on_edge ( x1 , y1 , x2 , y2 , R , C , i , edge_points ) : NEW_LINE INDENT c1 = coord_on_edge ( x1 , y1 , R , C ) NEW_LINE c2 = coord_on_edge ( x2 , y2 , R , C ) NEW_LINE if c1 is not None and c2 is not None : NEW_LINE INDENT heapq . heappush ( edge_points , ( c1 , i ) ) NEW_LINE heapq . heappush ( edge_points , ( c2 , i ) ) NEW_LINE DEDENT DEDENT def solve ( ) : NEW_LINE INDENT R , C , N = map ( int , input ( ) . split ( ) ) NEW_LINE edge_points = [ ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE on_edge ( x1 , y1 , x2 , y2 , R , C , i , edge_points ) NEW_LINE DEDENT q = [ ] NEW_LINE while edge_points : NEW_LINE INDENT c , i = heapq . heappop ( edge_points ) NEW_LINE if len ( q ) and q [ - 1 ] == i : NEW_LINE INDENT q . pop ( ) NEW_LINE DEDENT else : NEW_LINE INDENT q . append ( i ) NEW_LINE DEDENT DEDENT if len ( q ) : NEW_LINE INDENT return " NO " NEW_LINE DEDENT return " YES " NEW_LINE DEDENT print ( solve ( ) ) NEW_LINE
A , B = map ( int , input ( ) . split ( ) ) NEW_LINE if abs ( A ) < abs ( B ) : NEW_LINE INDENT print ( " Ant " ) NEW_LINE DEDENT elif abs ( A ) > abs ( B ) : NEW_LINE INDENT print ( " Bug " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Draw " ) NEW_LINE DEDENT
A , B , C , X , Y = map ( int , input ( ) . split ( ) ) NEW_LINE cost = [ ] NEW_LINE for i in range ( 10 ** 5 + 1 ) : NEW_LINE INDENT x = i NEW_LINE y = i NEW_LINE a = max ( X - i , 0 ) NEW_LINE b = max ( Y - i , 0 ) NEW_LINE cost . append ( A * a + B * b + C * 2 * i ) NEW_LINE DEDENT print ( min ( cost ) ) NEW_LINE
print ( sum ( [ not '0' in s for s in input ( ) . split ( ' + ' ) ] ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE ps_ls = [ ] NEW_LINE def dfs ( s ) : NEW_LINE INDENT global ps_ls NEW_LINE if len ( s ) == N : NEW_LINE INDENT ps_ls . append ( s ) NEW_LINE return NEW_LINE DEDENT dfs ( s + ' a ' ) NEW_LINE dfs ( s + ' b ' ) NEW_LINE dfs ( s + ' c ' ) NEW_LINE DEDENT dfs ( ' ' ) NEW_LINE ps_ls = sorted ( ps_ls ) NEW_LINE for ps in ps_ls : NEW_LINE INDENT print ( ps ) NEW_LINE DEDENT
import bisect NEW_LINE def solve ( k , aaa ) : NEW_LINE INDENT aaa = aaa [ : bisect . bisect_left ( aaa , k ) ] NEW_LINE dp = [ False ] * k NEW_LINE dp [ 0 ] = True NEW_LINE curr_max = 0 NEW_LINE ans = len ( aaa ) NEW_LINE for i , a in reversed ( list ( enumerate ( aaa ) ) ) : NEW_LINE INDENT if curr_max + a >= k : NEW_LINE INDENT ans = i NEW_LINE DEDENT f = True NEW_LINE for j in range ( min ( curr_max , k - a - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT if dp [ j ] : NEW_LINE INDENT dp [ j + a ] = True NEW_LINE if f : NEW_LINE INDENT curr_max = max ( curr_max , j + a ) NEW_LINE f = False NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT n , k = map ( int , input ( ) . split ( ) ) NEW_LINE aaa = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE aaa . sort ( ) NEW_LINE print ( solve ( k , aaa ) ) NEW_LINE
N = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE a . sort ( ) NEW_LINE G = a [ 0 ] NEW_LINE for i in range ( 1 , N , 1 ) : NEW_LINE INDENT A = a [ i ] NEW_LINE while A % G != 0 : NEW_LINE INDENT A , G = G , A % G NEW_LINE DEDENT DEDENT print ( G ) NEW_LINE
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE if b - a == c - b : NEW_LINE INDENT print ( ' YES ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' NO ' ) NEW_LINE DEDENT
N = int ( input ( ) ) NEW_LINE list = [ int ( i ) for i in input ( ) . split ( ) ] NEW_LINE list . sort ( ) NEW_LINE result = 0 NEW_LINE for i in list [ : : - 1 ] [ 1 : : 2 ] [ : N ] : NEW_LINE INDENT result += i NEW_LINE DEDENT print ( result ) NEW_LINE
a , b , c , d = input ( ) . split ( ) NEW_LINE e , f , g , h = input ( ) . split ( ) NEW_LINE i , j , k , l = input ( ) . split ( ) NEW_LINE m , n , o , p = input ( ) . split ( ) NEW_LINE print ( p + " ▁ " + o + " ▁ " + n + " ▁ " + m ) NEW_LINE print ( l + " ▁ " + k + " ▁ " + j + " ▁ " + i ) NEW_LINE print ( h + " ▁ " + g + " ▁ " + f + " ▁ " + e ) NEW_LINE print ( d + " ▁ " + c + " ▁ " + b + " ▁ " + a ) NEW_LINE
INPUT_MAX = 101010 NEW_LINE is_prime = [ 1 ] * INPUT_MAX NEW_LINE is_prime [ 0 ] = 0 NEW_LINE is_prime [ 1 ] = 0 NEW_LINE for i in range ( 2 , INPUT_MAX ) : NEW_LINE INDENT if not is_prime [ i ] : NEW_LINE INDENT continue NEW_LINE DEDENT for k in range ( i * 2 , INPUT_MAX , i ) : NEW_LINE INDENT is_prime [ k ] = 0 NEW_LINE DEDENT DEDENT a = [ 0 ] * INPUT_MAX NEW_LINE for i in range ( INPUT_MAX ) : NEW_LINE INDENT if i % 2 == 0 : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i + 1 ) % 2 != 0 : continue NEW_LINE if is_prime [ i ] and is_prime [ int ( ( i + 1 ) / 2 ) ] : NEW_LINE INDENT a [ i ] = 1 NEW_LINE DEDENT DEDENT s = [ 0 ] * ( INPUT_MAX + 1 ) NEW_LINE for i in range ( INPUT_MAX ) : NEW_LINE INDENT s [ i + 1 ] = s [ i ] + a [ i ] NEW_LINE DEDENT Q = int ( input ( ) ) NEW_LINE for q in range ( Q ) : NEW_LINE INDENT l , r = map ( int , input ( ) . split ( ) ) NEW_LINE r += 1 NEW_LINE print ( s [ r ] - s [ l ] ) NEW_LINE DEDENT
a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE l = sorted ( [ a , b , c ] ) NEW_LINE if l [ 0 ] + l [ 1 ] == l [ 2 ] : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
FILE_NAME_BASE = ' A - large ' NEW_LINE NUM_PROCESSES = 0 NEW_LINE MEM_LIMIT_GB = 1.5 NEW_LINE RECURSION_LIMIT = 1000 NEW_LINE def parse ( inp ) : NEW_LINE INDENT start , num = ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE motes = tuple ( int ( x ) for x in inp . readline ( ) . split ( ) ) NEW_LINE assert len ( motes ) == num NEW_LINE return start , motes NEW_LINE DEDENT def solve ( start , motes ) : NEW_LINE INDENT motes = sorted ( motes ) NEW_LINE num = len ( motes ) NEW_LINE best = num NEW_LINE size = start NEW_LINE added = 0 NEW_LINE i = 0 NEW_LINE while i < num : NEW_LINE INDENT if motes [ i ] < size : NEW_LINE INDENT size += motes [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT best = min ( best , added + num - i ) NEW_LINE if size <= 1 : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT while motes [ i ] - size >= 0 : NEW_LINE INDENT size += size - 1 NEW_LINE added += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT else : NEW_LINE INDENT best = min ( best , added ) NEW_LINE DEDENT return best NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT import sys NEW_LINE sys . setrecursionlimit ( RECURSION_LIMIT ) NEW_LINE import resource NEW_LINE soft , hard = resource . getrlimit ( resource . RLIMIT_AS ) NEW_LINE resource . setrlimit ( resource . RLIMIT_AS , ( MEM_LIMIT_GB * 1024 ** 3 , hard ) ) NEW_LINE inp = open ( FILE_NAME_BASE + ' . in ' , ' r ' ) NEW_LINE numCases = int ( inp . readline ( ) ) NEW_LINE if NUM_PROCESSES == 0 : NEW_LINE INDENT results = [ solve ( * parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT else : NEW_LINE INDENT from multiprocessing import Pool NEW_LINE pool = Pool ( NUM_PROCESSES ) NEW_LINE results = [ pool . apply_async ( solve , parse ( inp ) ) for _ in range ( numCases ) ] NEW_LINE DEDENT inp . close ( ) NEW_LINE out = open ( FILE_NAME_BASE + ' . out ' , ' w ' ) NEW_LINE for case , result in enumerate ( results ) : NEW_LINE INDENT value = result if NUM_PROCESSES == 0 else result . get ( ) NEW_LINE out . write ( ' Case ▁ # % d : ▁ % s \n ' % ( case + 1 , value ) ) NEW_LINE out . flush ( ) NEW_LINE DEDENT out . close ( ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def read ( parse ) : NEW_LINE INDENT return [ parse ( _ ) for _ in raw_input ( ) . split ( ) ] NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT B , N = read ( int ) NEW_LINE ar = read ( int ) NEW_LINE if N <= B : NEW_LINE INDENT return N NEW_LINE DEDENT def count ( t ) : NEW_LINE INDENT return sum ( t / x for x in ar ) NEW_LINE DEDENT lo = 0 NEW_LINE hi = N * min ( ar ) NEW_LINE while lo < hi : NEW_LINE INDENT mid = ( lo + hi ) / 2 NEW_LINE if count ( mid ) >= N - B : NEW_LINE INDENT hi = mid NEW_LINE DEDENT else : NEW_LINE INDENT lo = mid + 1 NEW_LINE DEDENT DEDENT place = ( N - B ) - count ( lo - 1 ) NEW_LINE lst = [ x for x in range ( B ) if lo % ar [ x ] == 0 ] NEW_LINE return lst [ place - 1 ] + 1 NEW_LINE DEDENT T = input ( ) NEW_LINE for t in range ( 1 , T + 1 ) : NEW_LINE INDENT print ' Case ▁ # % d : ▁ % d ' % ( t , solve ( ) ) NEW_LINE DEDENT
def genperm ( rem ) : NEW_LINE INDENT if rem : NEW_LINE INDENT for i in rem : NEW_LINE INDENT for perm in genperm ( rem - set ( [ i ] ) ) : NEW_LINE INDENT yield [ i ] + perm NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT yield [ ] NEW_LINE DEDENT DEDENT def permute ( perm , s ) : NEW_LINE INDENT return ' ' . join ( s [ p ] for p in perm ) NEW_LINE DEDENT def compress ( s ) : NEW_LINE INDENT prev = None NEW_LINE n = 0 NEW_LINE for c in s : NEW_LINE INDENT if c != prev : NEW_LINE INDENT n += 1 NEW_LINE prev = c NEW_LINE DEDENT DEDENT return n NEW_LINE DEDENT def solve ( ) : NEW_LINE INDENT permSize = int ( raw_input ( ) ) NEW_LINE data = raw_input ( ) NEW_LINE permutations = list ( genperm ( set ( range ( permSize ) ) ) ) NEW_LINE clen = 1000000000 NEW_LINE for perm in permutations : NEW_LINE INDENT permData = ' ' NEW_LINE for i in range ( 0 , len ( data ) , permSize ) : NEW_LINE INDENT permData += permute ( perm , data [ i : i + permSize ] ) NEW_LINE DEDENT clen = min ( clen , compress ( permData ) ) NEW_LINE DEDENT return clen NEW_LINE DEDENT import psyco NEW_LINE psyco . full ( ) NEW_LINE for case in range ( int ( raw_input ( ) ) ) : NEW_LINE INDENT print ' Case ▁ # % d : ▁ % s ' % ( case + 1 , solve ( ) ) NEW_LINE DEDENT
import sys NEW_LINE def readInput ( ) : NEW_LINE INDENT file = open ( sys . argv [ 1 ] ) NEW_LINE testCaseCount = int ( file . readline ( ) . rstrip ( ) ) NEW_LINE testCases = [ ] NEW_LINE for i in xrange ( testCaseCount ) : NEW_LINE INDENT n = int ( file . readline ( ) . rstrip ( ) ) NEW_LINE As = [ ] NEW_LINE Bs = [ ] NEW_LINE for j in xrange ( n ) : NEW_LINE INDENT a , b = [ int ( x ) for x in file . readline ( ) . rstrip ( ) . split ( ) ] NEW_LINE As . append ( a ) NEW_LINE Bs . append ( b ) NEW_LINE DEDENT testCases . append ( ( n , As , Bs ) ) NEW_LINE DEDENT return testCases NEW_LINE DEDENT def solve ( ( n , As , Bs ) ) : NEW_LINE INDENT intersections = 0 NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT for j in xrange ( n ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT continue NEW_LINE DEDENT if As [ i ] < As [ j ] and Bs [ i ] > Bs [ j ] : NEW_LINE INDENT intersections += 1 NEW_LINE DEDENT elif As [ i ] > As [ j ] and Bs [ i ] < Bs [ j ] : NEW_LINE INDENT intersections += 1 NEW_LINE DEDENT DEDENT DEDENT return intersections / 2 NEW_LINE DEDENT testCases = readInput ( ) NEW_LINE testCaseNr = 1 NEW_LINE for testCase in testCases : NEW_LINE INDENT print ' Case ▁ # % d : ▁ % s ' % ( testCaseNr , solve ( testCase ) ) NEW_LINE testCaseNr += 1 NEW_LINE DEDENT
import sys NEW_LINE global engines NEW_LINE global memo NEW_LINE global queries NEW_LINE sys . setrecursionlimit ( 3500 ) NEW_LINE def best ( s , q ) : NEW_LINE INDENT if ( q < 0 ) : NEW_LINE INDENT return ( 0 , [ ] ) NEW_LINE DEDENT if ( queries [ q ] == engines [ s ] ) : NEW_LINE INDENT memo [ ( s , q ) ] = ( 2 ** 30 , [ ] ) NEW_LINE return ( 2 ** 30 , [ ] ) NEW_LINE DEDENT if ( ( s , q ) in memo ) : NEW_LINE INDENT return memo [ ( s , q ) ] NEW_LINE DEDENT themin = 2 ** 30 NEW_LINE for i in range ( len ( engines ) ) : NEW_LINE INDENT if ( s != i ) : NEW_LINE INDENT cost = best ( i , q - 1 ) [ 0 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT cost = best ( i , q - 1 ) [ 0 ] NEW_LINE DEDENT if ( cost < themin ) : NEW_LINE INDENT res = ( cost , best ( i , q - 1 ) [ 1 ] + [ s ] ) NEW_LINE themin = cost NEW_LINE DEDENT DEDENT memo [ ( s , q ) ] = res NEW_LINE return res NEW_LINE DEDENT def findBest ( ) : NEW_LINE INDENT themin = 2 ** 30 NEW_LINE for i in range ( len ( engines ) ) : NEW_LINE INDENT cost = best ( i , len ( queries ) - 1 ) [ 0 ] NEW_LINE if ( cost < themin ) : NEW_LINE INDENT themin = cost NEW_LINE idx = i NEW_LINE DEDENT DEDENT return best ( idx , len ( queries ) - 1 ) NEW_LINE DEDENT f = open ( sys . argv [ 1 ] ) NEW_LINE nCases = int ( f . readline ( ) ) NEW_LINE for j in range ( nCases ) : NEW_LINE INDENT memo = { } NEW_LINE nEngines = int ( f . readline ( ) ) NEW_LINE engines = [ ] NEW_LINE for i in range ( nEngines ) : NEW_LINE INDENT engines . append ( f . readline ( ) . strip ( ) ) NEW_LINE DEDENT nQueries = int ( f . readline ( ) ) NEW_LINE queries = [ ] NEW_LINE for i in range ( nQueries ) : NEW_LINE INDENT queries . append ( f . readline ( ) . strip ( ) ) NEW_LINE DEDENT theBest = findBest ( ) NEW_LINE print " Case ▁ # % d : ▁ % d " % ( j + 1 , theBest [ 0 ] ) NEW_LINE NEW_LINE DEDENT
import sys NEW_LINE import math NEW_LINE fin = open ( ' input . txt ' , ' r ' ) NEW_LINE fout = open ( ' output . txt ' , ' w ' ) NEW_LINE l = int ( fin . readline ( ) ) NEW_LINE for case in range ( l ) : NEW_LINE INDENT P , Q = map ( int , fin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE frees = map ( int , fin . readline ( ) . strip ( ) . split ( ) ) NEW_LINE cache = { } NEW_LINE def rangeof ( lid , rid ) : NEW_LINE INDENT lrange = rrange = 0 NEW_LINE if lid == 0 : NEW_LINE INDENT lrange = 1 NEW_LINE DEDENT else : NEW_LINE INDENT lrange = frees [ lid - 1 ] + 1 NEW_LINE DEDENT if rid == len ( frees ) - 1 : NEW_LINE INDENT rrange = P NEW_LINE DEDENT else : NEW_LINE INDENT rrange = frees [ rid + 1 ] - 1 NEW_LINE DEDENT return rrange - lrange + 1 NEW_LINE DEDENT def getbetter ( lid , rid ) : NEW_LINE INDENT if lid > rid : NEW_LINE INDENT return 0 NEW_LINE DEDENT if lid == rid : NEW_LINE INDENT return rangeof ( lid , rid ) - 1 NEW_LINE DEDENT key = ( lid , rid ) NEW_LINE if key in cache : NEW_LINE INDENT return cache [ key ] NEW_LINE DEDENT else : NEW_LINE INDENT for i in range ( lid , rid + 1 ) : NEW_LINE INDENT cache [ key ] = rangeof ( lid , rid ) - 1 + min ( [ getbetter ( lid , i - 1 ) + getbetter ( i + 1 , rid ) for i in range ( lid , rid + 1 ) ] ) NEW_LINE DEDENT return cache [ key ] NEW_LINE DEDENT DEDENT fout . write ( " Case ▁ # % d : ▁ % d \n " % ( case + 1 , getbetter ( 0 , len ( frees ) - 1 ) ) ) NEW_LINE DEDENT fin . close ( ) NEW_LINE fout . close ( ) NEW_LINE
import sys NEW_LINE MAX_LIMIT = 2000000 NEW_LINE def get_min_mapped ( n ) : NEW_LINE INDENT n_min = n NEW_LINE x = str ( n ) NEW_LINE for i in xrange ( 1 , len ( x ) ) : NEW_LINE INDENT x = x [ 1 : ] + x [ 0 ] NEW_LINE if x [ 0 ] == '0' : NEW_LINE INDENT continue NEW_LINE DEDENT n_min = min ( n_min , int ( x ) ) NEW_LINE DEDENT return n_min NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT T = int ( sys . stdin . readline ( ) . strip ( ) ) NEW_LINE min_mapped = [ 0 ] * ( MAX_LIMIT + 1 ) NEW_LINE for i in xrange ( 1 , MAX_LIMIT + 1 ) : NEW_LINE INDENT min_mapped [ i ] = get_min_mapped ( i ) NEW_LINE DEDENT for r in xrange ( T ) : NEW_LINE INDENT values = map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE A , B = values NEW_LINE cnt_mapped = [ 0 ] * ( B + 1 ) NEW_LINE for i in xrange ( A , B + 1 ) : NEW_LINE INDENT cnt_mapped [ min_mapped [ i ] ] += 1 NEW_LINE DEDENT total = 0 NEW_LINE for i in xrange ( B + 1 ) : NEW_LINE INDENT if cnt_mapped [ i ] > 1 : NEW_LINE INDENT total += ( cnt_mapped [ i ] * ( cnt_mapped [ i ] - 1 ) ) / 2 NEW_LINE DEDENT DEDENT print " Case ▁ # % d : ▁ % s " % ( r + 1 , total ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def dbg ( a ) : sys . stderr . write ( str ( a ) ) NEW_LINE def readint ( ) : return int ( raw_input ( ) ) NEW_LINE def readfloat ( ) : return float ( raw_input ( ) ) NEW_LINE def readarray ( foo ) : return map ( foo , raw_input ( ) . split ( ) ) NEW_LINE def doit ( u , p ) : NEW_LINE INDENT c = k NEW_LINE s = len ( to [ u ] ) NEW_LINE if ( p >= 0 ) : NEW_LINE INDENT c -= len ( to [ p ] ) NEW_LINE s -= 1 NEW_LINE DEDENT cnks . append ( ( c , s ) ) NEW_LINE for v in to [ u ] : NEW_LINE INDENT if v == p : continue NEW_LINE doit ( v , u ) NEW_LINE DEDENT DEDENT M = 1000000009 NEW_LINE def cnk ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE for i in xrange ( k ) : NEW_LINE INDENT res *= n - i NEW_LINE res %= M NEW_LINE DEDENT return res NEW_LINE DEDENT for test in range ( readint ( ) ) : NEW_LINE INDENT dbg ( " Test ▁ % d \n " % ( test + 1 ) ) NEW_LINE n , k = readarray ( int ) NEW_LINE to = [ ] NEW_LINE cnks = [ ] NEW_LINE for i in xrange ( n ) : NEW_LINE INDENT to . append ( [ ] ) NEW_LINE DEDENT for i in xrange ( n - 1 ) : NEW_LINE INDENT ( u , v ) = readarray ( int ) NEW_LINE to [ u - 1 ] . append ( v - 1 ) NEW_LINE to [ v - 1 ] . append ( u - 1 ) NEW_LINE DEDENT doit ( 0 , - 1 ) NEW_LINE res = 1 NEW_LINE for ( c , s ) in cnks : NEW_LINE INDENT if ( s > c ) : res = 0 NEW_LINE res *= cnk ( c , s ) NEW_LINE res %= M NEW_LINE DEDENT print " Case ▁ # % d : ▁ % d " % ( test + 1 , res ) NEW_LINE DEDENT
infile = open ( ' airport _ walk . in ' ) NEW_LINE outfile = open ( ' airport _ walk . out ' , ' w ' ) NEW_LINE T = int ( infile . readline ( ) . strip ( ) ) NEW_LINE for t in xrange ( T ) : NEW_LINE INDENT X , S , R , runtime , N = [ int ( s ) for s in infile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE run_bonus = R - S NEW_LINE speeds , lengths = [ ] , [ ] NEW_LINE walkways = [ ] NEW_LINE for i in xrange ( N ) : NEW_LINE INDENT B , E , w = [ int ( s ) for s in infile . readline ( ) . strip ( ) . split ( ) ] NEW_LINE walkways . append ( ( w + S , E - B ) ) NEW_LINE DEDENT sum_lens = sum ( w [ 1 ] for w in walkways ) NEW_LINE walkways . append ( ( S , X - sum_lens ) ) NEW_LINE walkways = sorted ( walkways , key = lambda w : w [ 0 ] ) NEW_LINE answer = 0.0 NEW_LINE for speed , distance in walkways : NEW_LINE INDENT cur_runtime = min ( distance / float ( speed + run_bonus ) , float ( runtime ) ) NEW_LINE runtime -= cur_runtime NEW_LINE answer += cur_runtime + ( ( distance - ( speed + run_bonus ) * cur_runtime ) / float ( speed ) ) NEW_LINE DEDENT outfile . write ( ' Case ▁ # % d : ▁ % .9f \n ' % ( t + 1 , answer ) ) NEW_LINE DEDENT
from sympy import * NEW_LINE import random NEW_LINE n = 32 NEW_LINE j = 500 NEW_LINE arr = [ ] NEW_LINE f = open ( " out . txt " , " w " ) NEW_LINE def findDivisor ( x ) : NEW_LINE INDENT res = 2 NEW_LINE while x % res != 0 and res < 100 : NEW_LINE INDENT res += 1 NEW_LINE DEDENT return res NEW_LINE DEDENT for i in xrange ( 2 ** ( n - 2 ) ) : NEW_LINE INDENT t = bin ( i ) [ 2 : ] NEW_LINE t = "0" * ( n - 2 - len ( t ) ) + t NEW_LINE t = "1" + t + "1" NEW_LINE ok = True NEW_LINE for base in xrange ( 2 , 11 ) : NEW_LINE INDENT if isprime ( int ( t , base ) ) or findDivisor ( int ( t , base ) ) == 100 : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT if ok : NEW_LINE INDENT data = [ ] NEW_LINE data . append ( t ) NEW_LINE for base in xrange ( 2 , 11 ) : NEW_LINE INDENT num = int ( t , base ) NEW_LINE data . append ( str ( findDivisor ( num ) ) ) NEW_LINE DEDENT arr . append ( data ) NEW_LINE if len ( arr ) == j : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT print >> f , " Case ▁ # 1 : " NEW_LINE for l in arr : NEW_LINE INDENT print >> f , ' ▁ ' . join ( l ) NEW_LINE DEDENT
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT inFile = open ( " C - large . in " , " r " ) NEW_LINE outFile = open ( " realtest . out " , " w " ) NEW_LINE caseNum = int ( inFile . readline ( ) ) NEW_LINE for i in range ( 1 , caseNum + 1 ) : NEW_LINE INDENT items = inFile . readline ( ) . replace ( " \n " , " " ) . split ( " ▁ " ) NEW_LINE R = int ( items [ 0 ] ) NEW_LINE k = int ( items [ 1 ] ) NEW_LINE N = int ( items [ 2 ] ) NEW_LINE items = inFile . readline ( ) . replace ( " \n " , " " ) . split ( " ▁ " ) NEW_LINE if len ( items ) != N : NEW_LINE INDENT print " guest ▁ number ▁ error . " NEW_LINE continue NEW_LINE DEDENT dataList = [ ] NEW_LINE for item in items : NEW_LINE INDENT dataList . append ( int ( item ) ) NEW_LINE DEDENT roundData = [ ] NEW_LINE occurInfo = { } NEW_LINE posCnt = 0 NEW_LINE totalCnt = 0 NEW_LINE while posCnt not in occurInfo : NEW_LINE INDENT testSum = 0 NEW_LINE tmp_cnt = 0 NEW_LINE while tmp_cnt < N and testSum + dataList [ ( posCnt + tmp_cnt ) % N ] <= k : NEW_LINE INDENT testSum += dataList [ ( posCnt + tmp_cnt ) % N ] NEW_LINE tmp_cnt += 1 NEW_LINE DEDENT roundData . append ( testSum ) NEW_LINE occurInfo [ posCnt ] = totalCnt NEW_LINE posCnt = ( posCnt + tmp_cnt ) % N NEW_LINE totalCnt += 1 NEW_LINE DEDENT roundSum = 0 NEW_LINE loopLen = len ( roundData ) - occurInfo [ posCnt ] NEW_LINE for j in range ( occurInfo [ posCnt ] , len ( roundData ) ) : NEW_LINE INDENT roundSum += roundData [ j ] NEW_LINE DEDENT totalSum = 0 NEW_LINE for j in range ( occurInfo [ posCnt ] ) : NEW_LINE INDENT totalSum += roundData [ j ] NEW_LINE DEDENT for j in range ( ( R - occurInfo [ posCnt ] ) % loopLen ) : NEW_LINE INDENT totalSum += roundData [ j + occurInfo [ posCnt ] ] NEW_LINE DEDENT totalSum += ( ( R - occurInfo [ posCnt ] ) / loopLen ) * roundSum NEW_LINE outFile . write ( " Case ▁ # % d : ▁ % d \n " % ( i , totalSum ) ) NEW_LINE DEDENT outFile . close ( ) NEW_LINE inFile . close ( ) NEW_LINE DEDENT
import sys NEW_LINE def prework ( argv ) : NEW_LINE INDENT l = range ( 1000 ) NEW_LINE def test ( func ) : NEW_LINE INDENT lg = list ( l ) NEW_LINE func ( lg ) NEW_LINE return check ( lg ) NEW_LINE DEDENT ans = [ ( test ( good ) , test ( bad ) ) for _ in range ( 20 ) ] NEW_LINE print ( * ans , sep = ' \n ' , file = sys . stderr ) NEW_LINE return " above " NEW_LINE DEDENT import random NEW_LINE def good ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( k , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT def bad ( l ) : NEW_LINE INDENT n = len ( l ) NEW_LINE for k in range ( n ) : NEW_LINE INDENT p = random . randint ( 0 , n - 1 ) NEW_LINE l [ k ] , l [ p ] = l [ p ] , l [ k ] NEW_LINE DEDENT DEDENT def check ( l ) : NEW_LINE INDENT a = len ( [ 1 for i , x in enumerate ( l ) if i - x > 0 ] ) NEW_LINE b = len ( [ 1 for i , x in enumerate ( l ) if i - x < 0 ] ) NEW_LINE r = a / b NEW_LINE return r > 0.94 NEW_LINE DEDENT def once ( ) : NEW_LINE INDENT n = int ( input ( ) ) NEW_LINE l = [ int ( x ) for x in input ( ) . split ( ) ] NEW_LINE return " GOOD " if check ( l ) else " BAD " NEW_LINE pass NEW_LINE DEDENT def printerr ( * v ) : NEW_LINE INDENT print ( * v , file = sys . stderr ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT TT = int ( input ( ) ) NEW_LINE for tt in range ( 1 , TT + 1 ) : NEW_LINE INDENT printerr ( " coping ▁ Case ▁ % d . . " % ( tt ) ) NEW_LINE ans = once ( ) NEW_LINE print ( " Case ▁ # % d : ▁ % s " % ( tt , ( ans ) ) ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT msg = prework ( sys . argv ) NEW_LINE print ( " prework ▁ down ▁ with " , msg , file = sys . stderr ) NEW_LINE main ( ) NEW_LINE DEDENT
n = 0 NEW_LINE b = 0 NEW_LINE used = set ( [ ] ) NEW_LINE counter = 0 NEW_LINE def count ( n , minnum , b ) : NEW_LINE INDENT global counter NEW_LINE for num in range ( minnum , n + 1 ) : NEW_LINE INDENT rep = [ ] NEW_LINE nnum = num NEW_LINE while nnum > 0 : NEW_LINE INDENT rep . append ( nnum % b ) NEW_LINE nnum = nnum / b NEW_LINE DEDENT ok = True NEW_LINE for i in range ( len ( rep ) ) : NEW_LINE INDENT if ( i , rep [ i ] ) in used : NEW_LINE INDENT ok = False NEW_LINE break NEW_LINE DEDENT DEDENT if ok : NEW_LINE INDENT for i in range ( len ( rep ) ) : NEW_LINE INDENT used . add ( ( i , rep [ i ] ) ) NEW_LINE DEDENT if n - num == 0 : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count ( n - num , num + 1 , b ) NEW_LINE DEDENT for i in range ( len ( rep ) ) : NEW_LINE INDENT used . remove ( ( i , rep [ i ] ) ) NEW_LINE DEDENT DEDENT DEDENT DEDENT T = int ( raw_input ( ) ) NEW_LINE for i in range ( T ) : NEW_LINE INDENT [ n , b ] = map ( lambda x : int ( x ) , raw_input ( ) . split ( ) ) NEW_LINE counter = 0 NEW_LINE used = set ( [ ] ) NEW_LINE count ( n , 1 , b ) NEW_LINE print ( " Case ▁ # % d : ▁ % d " % ( i + 1 , counter ) ) NEW_LINE DEDENT
if __name__ == " _ _ main _ _ " : n = int ( input ( ) ) grades = list ( map ( int , input ( ) . split ( ) ) ) grades . sort ( ) required = 4.5 redo = 0 i = 0 while round ( sum ( grades ) / n , 2 ) < required : redo = redo + 1 grades [ i ] = 5 i = i + 1 print ( redo ) NEW_LINE
t = int ( input ( ) ) for i in range ( t ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) e = [ ] o = [ ] for i in range ( 2 * n ) : if l [ i ] % 2 == 0 : e . append ( i + 1 ) else : o . append ( i + 1 ) for i in range ( n - 1 ) : if len ( e ) > 1 : print ( str ( e . pop ( 0 ) ) + " ▁ " + str ( e . pop ( 0 ) ) ) else : print ( str ( o . pop ( 0 ) ) + " ▁ " + str ( o . pop ( 0 ) ) )             	         NEW_LINE
cases = int ( input ( ) ) for i in range ( cases ) : a , b , c = map ( int , input ( ) . split ( ) ) print ( max ( a - b , a - c ) + 1 ) NEW_LINE
import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   def main ( ) : n = int ( input ( ) ) ans = 0 while n > 0 : sm_p = n if n % 2 == 0 : ans += n // 2 break else : i = 3 while i * i <= n : if n % i == 0 : sm_p = i break i += 2 n -= sm_p ans += 1 print ( ans )   main ( ) NEW_LINE
n , x = map ( int , input ( ) . split ( ) ) a = [ int ( i ) for i in input ( ) . split ( ) ] if ( sum ( a ) + n - 1 == x ) : print ( " YES " ) else : print ( " NO " ) NEW_LINE
from sys import stdoutn = int ( input ( ) ) ans = [ 10 ** 10 ] * nth = 1 while th < n : ask = [ i % ( 2 * th ) < th for i in range ( n ) ] for _ in range ( 2 ) : inds = [ key for key , value in enumerate ( ask ) if value ] print ( len ( inds ) ) print ( ' ▁ ' . join ( [ str ( i + 1 ) for i in inds ] ) ) stdout . flush ( ) reply = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) ans = [ ans [ i ] if ask [ i ] else min ( ans [ i ] , reply [ i ] ) for i in range ( n ) ] ask = [ not v for v in ask ] th *= 2 print ( - 1 ) print ( ' ▁ ' . join ( map ( str , ans ) ) ) stdout . flush ( )       NEW_LINE
cases = int ( input ( ) ) while cases : cases -= 1 num = int ( input ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) )   base = min ( arr [ - 1 ] , arr [ - 2 ] ) - 1   ans = min ( base , num - 2 )   print ( ans )   NEW_LINE
import sysinput = sys . stdin . readline   t = 1   for _ in range ( t ) : n = int ( input ( ) ) l = [ 1 , 7 , 9 , 10 , 11 , 13 , 14 , 15 , 16 , 17 , 18 , 19 ] flag = 1 d = n // 10 if d == 2 or d == 7 or d == 9 : flag = 0 if n in l : flag = 0 n %= 10 if n in l : flag = 0 if flag : print ( " YES " ) else : print ( " NO " ) NEW_LINE
n = int ( input ( ) ) ai = [ int ( x ) for x in input ( ) . split ( ) ] m = int ( input ( ) ) bj = [ int ( x ) for x in input ( ) . split ( ) ] gears = [ ] for i in ai : for j in bj : if ( j % i == 0 ) : gears . append ( int ( j / i ) ) maxgear = max ( gears ) print ( gears . count ( maxgear ) ) NEW_LINE
import sysinput_ = lambda : sys . stdin . readline ( ) . strip ( " \n " ) from math import gcdsa = lambda : input_ ( ) sb = lambda : int ( input_ ( ) ) sc = lambda : input_ ( ) . split ( ) sd = lambda : list ( map ( int , input_ ( ) . split ( ) ) ) se = lambda : float ( input_ ( ) ) sf = lambda : list ( input_ ( ) ) flsh = lambda : sys . stdout . flush ( ) mod = 10 ** 9 + 7 def hnbhai ( ) : n = sb ( ) a = sd ( ) b = list ( set ( a ) ) sum_ = sum ( a ) min_ = min ( a ) minus = 0 for i in b : fact = 2 while ( i // fact ) > min_ : if i % fact == 0 : temp = i // fact + min_ * fact - i - min_ minus = min ( minus , temp ) fact += 1 print ( sum_ + minus ) for _ in range ( 1 ) : hnbhai ( ) NEW_LINE
from sys import * f = lambda : map ( int , stdin . readline ( ) . split ( ) ) n , k = f ( ) t = sorted ( f ( ) ) s = [ 0 ] * ( n + 1 ) for i in range ( n ) : s [ i + 1 ] = s [ i ] + t [ i ] t = [ 0 ] + td = s [ n ] l , r = 0 , nwhile l < r : m = l + r + 1 >> 1 if t [ m ] * m - s [ m ] > k : r = m - 1 else : l = mx = ll , r = 0 , nwhile l < r : m = l + r >> 1 if d - s [ m ] - t [ m ] * ( n - m ) > k : l = m + 1 else : r = my = rq = ( d - s [ y - 1 ] - k + n - y ) // ( n - y + 1 ) - ( s [ x ] + k ) // xprint ( max ( q , int ( d % n > 0 ) ) ) NEW_LINE
n = int ( input ( ) ) lucky = [ 4 , 7 , 47 , 74 , 447 , 474 , 477 , 774 , 747 , 744 ] count = 0 for i in range ( len ( lucky ) ) : if ( ( n == lucky [ i ] ) or ( n % lucky [ i ] == 0 ) ) : print ( ' YES ' ) break else : count += 1 if count == 10 : print ( ' NO ' ) NEW_LINE
n = int ( input ( ) ) a = [ ] for i in range ( n ) : s = input ( ) a . append ( s ) b = [ ] for i in range ( n ) : s = input ( ) b . append ( s ) d = dict ( ) d2 = dict ( ) res = 0 for elem in a : if elem in d : d [ elem ] += 1 else : d [ elem ] = 1 for elem in b : if elem in d2 : d2 [ elem ] += 1 else : d2 [ elem ] = 1 for elem in d : if elem not in d2 : d2 [ elem ] = 0 res += min ( d [ elem ] , d2 [ elem ] ) print ( n - res ) NEW_LINE
events_num = input ( ) events = input ( )   rooms = [ 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 ]   for e in events : if ( e == ' L ' ) : rooms [ rooms . index ( 0 ) ] = 1 elif ( e == ' R ' ) : rooms [ len ( rooms ) - 1 - rooms [ : : - 1 ] . index ( 0 ) ] = 1 else : rooms [ int ( e ) ] = 0           print ( * rooms , sep = " " )   NEW_LINE
n = int ( input ( ) ) a = [ int ( x ) for x in input ( ) . split ( ) ] s = sum ( a ) // ( n // 2 ) checked = [ ] for i in range ( n ) : if i not in checked : for j in range ( i + 1 , n ) : if a [ i ] + a [ j ] == s and j not in checked : print ( i + 1 , j + 1 ) checked . append ( i ) checked . append ( j ) break NEW_LINE
import sysn = int ( input ( ) ) sys . stdout . write ( str ( n ) ) for i in range ( n + 1 , 2 * n ) : sys . stdout . write ( " ▁ " + str ( i ) ) NEW_LINE
n = int ( input ( ) ) dp = [ 0 ] * 101 dp [ 1 ] = 1 dp [ 2 ] = 2 for i in range ( 3 , 101 ) : dp [ i ] = dp [ i - 2 ] + iprint ( dp [ n ] ) NEW_LINE
""" ▁ Created ▁ by ▁ Henrikh ▁ Kantuni ▁ on ▁ 3/23/17 ▁ """   n , m = map ( int , input ( ) . split ( ) ) destroy = False   while m > 0 : group = [ int ( g ) for g in input ( ) . split ( ) ] [ 1 : ]   if len ( group ) == 1 : destroy = True break   group = [ abs ( g ) for g in list ( set ( group ) ) ] old_size = len ( group ) group = list ( set ( group ) )   if len ( group ) == old_size : destroy = True break   m -= 1   if destroy : print ( " YES " ) else : print ( " NO " ) NEW_LINE
n , p = map ( int , input ( ) . split ( ) ) a = [ ] NEW_LINE
import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = " x " in file . mode or " r " not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b " \n " ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( " ascii " ) ) self . read = lambda : self . buffer . read ( ) . decode ( " ascii " ) self . readline = lambda : self . buffer . readline ( ) . decode ( " ascii " )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( " \n " ) NEW_LINE
n , k , t = map ( int , input ( ) . split ( ) ) NEW_LINE ans = [ 0 ] * ni = 0 NEW_LINE a = n * k * t // 100 NEW_LINE while a > 0 : if NEW_LINE a >= k : ans [ i ] += k NEW_LINE i += 1 NEW_LINE a -= k else : ans [ i ] += int ( a ) NEW_LINE a -= int ( a ) NEW_LINE print ( * ans ) NEW_LINE
from sys import stdinfrom collections import deque   n , k = map ( int , stdin . readline ( ) . split ( ) )   graph = [ [ ] for _ in range ( n ) ] leaf = - 1 for _ in range ( n - 1 ) : a , b = map ( int , stdin . readline ( ) . split ( ) ) graph [ a - 1 ] . append ( b - 1 ) graph [ b - 1 ] . append ( a - 1 )   def bfs ( G , s ) : NEW_LINE
import datetimex = datetime . datetime . strptime ( input ( ) , " % Y : % m : % d " ) y = datetime . datetime . strptime ( input ( ) , " % Y : % m : % d " ) print ( abs ( ( x - y ) . days ) ) NEW_LINE
import sysfrom collections import Counter   def main ( ) : s = list ( map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) ) return sum ( s ) - max ( ( i * min ( j , 3 ) for i , j in Counter ( s ) . items ( ) if j > 1 ) , default = 0 )   print ( main ( ) ) NEW_LINE
n = int ( input ( ) ) a = str ( input ( ) )   l = r = int ( n / 2 ) while ( l > 0 and a [ l ] == '0' ) : l -= 1 while ( r < len ( a ) and a [ r ] == '0' ) : r += 1   ans = float ( ' inf ' ) if ( l > 0 ) : ans = min ( ans , int ( a [ : l ] ) + int ( a [ l : ] ) ) if ( l + 1 < len ( a ) and a [ l + 1 ] != '0' ) : ans = min ( ans , int ( a [ : l + 1 ] ) + int ( a [ l + 1 : ] ) ) if ( r < len ( a ) ) : ans = min ( ans , int ( a [ : r ] ) + int ( a [ r : ] ) ) print ( ans ) NEW_LINE
import syss , n = 0 , int ( input ( ) ) t = list ( map ( int , sys . stdin . read ( ) . split ( ) ) ) p = [ ( t [ 2 * i ] , t [ 2 * i + 1 ] ) for i in range ( n ) ] for x , i in enumerate ( p , 1 ) : for j in p [ x : ] : a = b = 0 for k in p : d = ( i [ 0 ] - k [ 0 ] ) * ( j [ 1 ] - k [ 1 ] ) - ( i [ 1 ] - k [ 1 ] ) * ( j [ 0 ] - k [ 0 ] ) a , b = min ( d , a ) , max ( d , b ) if a and b : s = max ( s , b - a ) print ( s / 2 ) NEW_LINE
from collections import * from sys import * input = stdin . readlined = defaultdict ( list ) n , m = map ( int , input ( ) . split ( ) ) s = input ( ) flag = 0 flag2 = 0 temp , temp1 = 0 , 0 for i in range ( m ) : x , y = input ( ) . strip ( ) . split ( " ▁ " ) if x in d . keys ( ) : flag = 1 for i in d . keys ( ) : if d [ i ] == x : temp = i break else : flag = 0 d [ x ] = y if y in d . keys ( ) : flag2 = 1 for i in d . keys ( ) : if d [ i ] == y : temp1 = i break else : flag2 = 0 d [ y ] = x if flag == 1 : d [ temp ] = y if flag2 == 1 : d [ temp1 ] = x for i in s : if d [ i ] != [ ] : print ( d [ i ] , end = " " ) else : print ( i , end = " " )     NEW_LINE
li = [ ] for i in range ( 0 , 4 ) : s = input ( ) li . append ( list ( s ) ) fl = 0 for i in range ( 0 , 3 ) : for j in range ( 0 , 3 ) : se = [ li [ i ] [ j ] , li [ i ] [ j + 1 ] , li [ i + 1 ] [ j ] , li [ i + 1 ] [ j + 1 ] ] if se . count ( ' # ' ) >= 3 or se . count ( ' . ' ) >= 3 : fl = 1 break if fl == 1 : breakif fl == 1 : print ( " YES " ) else : print ( " NO " ) NEW_LINE
def check ( ) : a . sort ( ) if len ( set ( a ) ) == 1 : print ( " - 1" ) else : if sum ( a [ : n ] ) != sum ( a [ : 2 * n ] ) : for item in a : print ( item , end = " ▁ " ) else : print ( " - 1" )   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( " ▁ " ) ) ) check ( ) NEW_LINE
from collections import defaultdictfrom NEW_LINE math NEW_LINE import inf   n , m , x = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE keyboard , shift = [ ] , set ( ) NEW_LINE for i in range ( n ) : ip = input ( ) NEW_LINE line = [ x for x in ip ] NEW_LINE for j in range ( m ) : if NEW_LINE ip [ j ] == ' S ' : shift . add ( ( i , j ) ) NEW_LINE keyboard . append ( line )   q = int ( input ( ) ) NEW_LINE text = input ( )   NEW_LINE
import mathn , m , k = map ( int , input ( ) . strip ( ) . split ( ' ▁ ' ) ) NEW_LINE
r , c , n , k = map ( int , input ( ) . split ( ) )   M = [ [ ' * ' ] * c for i in range ( r ) ]   for i in range ( n ) : x , y = map ( int , input ( ) . split ( ) ) M [ x - 1 ] [ y - 1 ] = ' # '   def contain ( M , k , x1 , y1 , x2 , y2 ) : for i in range ( x1 , x2 + 1 ) : for j in range ( y1 , y2 + 1 ) : if M [ i ] [ j ] == ' # ' : k -= 1 return k <= 0   ans = 0 for x1 in range ( r ) : for y1 in range ( c ) : for x2 in range ( x1 , r ) : for y2 in range ( y1 , c ) : if contain ( M , k , x1 , y1 , x2 , y2 ) : ans += 1 print ( ans ) NEW_LINE
n , m , k = list ( map ( int , input ( ) . split ( ) ) ) a = [ [ ] for i in range ( m ) ] for i in range ( n ) : r , c = list ( map ( int , input ( ) . split ( ) ) ) a [ r - 1 ] . append ( c ) b = 0 for i in range ( m ) : d = - 1 for j in a [ i ] : if d == - 1 or j < d : d = j b += dprint ( min ( b , k ) ) NEW_LINE
from sys import stdinfrom NEW_LINE math NEW_LINE import prod   input = stdin . readline   for test in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE lst = sorted ( list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) , reverse = True ) NEW_LINE
import sys , mathimport NEW_LINE copyimport NEW_LINE heapq   from collections import NEW_LINE INDENT dequeinput = sys . stdin . readline   NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) a = set ( map ( int , input ( ) . split ( ) ) ) b = set ( map ( int , input ( ) . split ( ) ) )   c = a & bif c : print ( min ( c ) ) else : x , y = min ( a ) , min ( b ) print ( min ( x , y ) * 10 + max ( x , y ) ) NEW_LINE
from sys import stdin , stdoutinput = stdin . readlineprint = stdout . writen = int ( input ( ) ) a , g = 0 , 0 sol = " " for i in range ( n ) : prva , druga = map ( int , input ( ) . split ( ) ) if a + prva - g <= 500 : a += prva print ( " A " ) else : g += druga print ( " G " ) NEW_LINE
from sys import stdin , stdout , stderrimport time , mathfrom collections import defaultdict as dd , Counter def pn ( ob ) : stdout . write ( str ( ob ) ) def inp ( ) : return stdin . readline ( )   def main ( ) : t = int ( inp ( ) ) for testNumber in range ( 1 , t + 1 , 1 ) : process ( ) 	   def process ( ) : n , r = map ( int , inp ( ) . split ( ) ) arr = list ( map ( int , inp ( ) . split ( ) ) )   arr . sort ( )   res = 0 missiles_launched = 0 i = n - 1 while ( i >= 0 ) : if ( arr [ i ] - missiles_launched * r <= 0 ) : break   while ( i - 1 >= 0 and arr [ i ] == arr [ i - 1 ] ) : i -= 1 missiles_launched += 1 i -= 1   pn ( str ( missiles_launched ) + ' \n ' )   if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE
arr = sorted ( map ( int , input ( ) . split ( ) ) ) a , b , c , d = arr   if a + b > c or b + c > d : print ( " TRIANGLE " ) elif a + b == c or b + c == d : print ( " SEGMENT " ) else : print ( " IMPOSSIBLE " ) NEW_LINE
n = int ( input ( ) ) ans = 1   A = list ( map ( int , input ( ) . split ( ) ) ) h = [ 0 for i in range ( n + 1 ) ] B = [ 0 for i in range ( n + 1 ) ]   for i in range ( n - 1 ) : h [ i + 2 ] = h [ A [ i ] ] + 1 B [ h [ i + 2 ] ] += 1 for x in B : if x % 2 != 0 : ans += 1 print ( ans ) NEW_LINE
def solve ( na , nb , k , m , a , b ) : res_a = max ( a [ : k ] ) res_b = min ( b [ - m : ] ) return " NO " if res_a >= res_b else " YES "                         def main ( ) : na , nb = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) k , m = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) a = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) b = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE
a , b , c , d = map ( int , input ( ) . split ( ) ) if ( a == c and b == d ) : rook = 0 elif ( a == c or b == d ) : rook = 1 else : rook = 1 + 1   king = max ( abs ( a - c ) , abs ( b - d ) )   if ( abs ( a - c ) % 2 != abs ( b - d ) % 2 ) : bishop = 0 else : if ( a == c and b == d ) : bishop = 0 elif ( abs ( a - c ) == abs ( b - d ) ) : bishop = 1 else : bishop = 1 + 1 print ( rook , bishop , king ) NEW_LINE
import sysfrom collections import defaultdictD = [ "1110111" , "0010010" , "1011101" , "1011011" , "0111010" , "1101011" , "1101111" , "1010010" , "1111111" , "1111011" ] SIGN = [ bin ( i ) [ 2 : ] . zfill ( 7 ) for i in range ( 1 << 7 ) ] RESTORE = { SIGN [ i ] : i for i in range ( 1 << 7 ) } COST = [ [ - 1 ] * ( 10 ) for i in range ( 1 << 7 ) ] for i in range ( 1 << 7 ) : for j in range ( 10 ) : si = SIGN [ i ] sj = D [ j ] cost = 0 possible = True for k in range ( 7 ) : if si [ k ] == "1" and sj [ k ] == "0" : COST [ i ] [ j ] = - 1 possible = False break elif si [ k ] == "0" and sj [ k ] == "1" : cost += 1 if possible : COST [ i ] [ j ] = cost     def input ( ) : return sys . stdin . readline ( ) . rstrip ( )     NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) a = sorted ( list ( map ( int , input ( ) . split ( ) ) ) ) s = a [ - 1 ] - a [ 0 ] for i in range ( n - 1 , m ) : s = min ( s , a [ i ] - a [ i - n + 1 ] ) print ( s ) NEW_LINE
import mathimport collectionsimport bisect   def solve ( n , d , m ) : for i in range ( m ) : x , y = [ int ( s ) for s in input ( ) . split ( ) ] if d <= x + y and x + y <= 2 * n - d and - d <= x - y and x - y <= d : print ( " YES " ) else : print ( " NO " )   n , d = [ int ( s ) for s in input ( ) . split ( ) ] m = int ( input ( ) ) solve ( n , d , m ) NEW_LINE
import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = " x " in file . mode or " r " not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b " \n " ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( " ascii " ) ) self . read = lambda : self . buffer . read ( ) . decode ( " ascii " ) self . readline = lambda : self . buffer . readline ( ) . decode ( " ascii " )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( " \n " ) NEW_LINE
import mathn , m = map ( int , input ( ) . split ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) B = [ ] max = 0 last = 0 for i in range ( n ) : if math . ceil ( A [ i ] / m ) >= max : last = i max = math . ceil ( A [ i ] / m ) print ( last + 1 ) NEW_LINE
def stoned ( arr ) : NEW_LINE INDENT s = sum ( arr ) NEW_LINE if max ( arr ) > s // 2 : return " T " NEW_LINE if s % 2 == 0 : NEW_LINE INDENT return " HL " NEW_LINE DEDENT else : NEW_LINE INDENT return " T " NEW_LINE DEDENT DEDENT for i in range ( int ( input ( ) ) ) : NEW_LINE INDENT a = input ( ) NEW_LINE lst = list ( map ( int , input ( ) . strip ( ) . split ( ) ) ) NEW_LINE print ( stoned ( lst ) ) NEW_LINE DEDENT
print ( ( int ( input ( ) ) - 1 ) // 2 ) NEW_LINE
import itertools   def check ( curr_words , line ) : if curr_words == [ ] : return True for i in range ( len ( line ) ) : if line [ i ] == curr_words [ 0 ] : return check ( curr_words [ 1 : ] , line [ i + 1 : ] ) return False   n = int ( input ( ) ) words = input ( ) . split ( ) m = int ( input ( ) ) res , idx = 0 , 0 for i in range ( m ) : line = input ( ) . split ( ) [ 1 : ] for p in itertools . permutations ( range ( n ) ) : curr_words = [ words [ j ] for j in p ] cnt = 0 for j in range ( n ) : cnt += len ( [ k for k in range ( j + 1 , n ) if p [ k ] < p [ j ] ] ) v = n * ( n - 1 ) // 2 - cnt + 1 if check ( curr_words , line [ : ] ) and v > res : res , idx = v , i + 1 if res > 0 : print ( idx ) print ( ' [ : ' + str ( ' | ' * res ) + ' : ] ' ) else : print ( ' Brand ▁ new ▁ problem ! ' ) NEW_LINE
import collections   n = int ( input ( ) ) for i in range ( n ) : move = input ( ) counter = collections . Counter ( move ) ver , hor = min ( counter [ ' U ' ] , counter [ ' D ' ] ) , min ( counter [ ' L ' ] , counter [ ' R ' ] ) if ver and hor : print ( 2 * ( ver + hor ) ) print ( " L " * hor + " U " * ver + " R " * hor + " D " * ver ) elif not ver and not hor : print ( "0" ) else : print ( "2" ) if ver : print ( " UD " ) elif hor : print ( " LR " ) NEW_LINE
R = lambda : map ( int , input ( ) . split ( ) ) NEW_LINE n , q = R ( ) NEW_LINE r = sum ( a : = [ 0 , * R ( ) ] ) NEW_LINE while q : NEW_LINE INDENT q -= 1 ; NEW_LINE t , x = R ( ) NEW_LINE if t < 2 or print ( + ( x <= r ) ) : a [ x ] ^= 1 ; r += 2 * a [ x ] - 1 NEW_LINE DEDENT
ax , ay , bx , by , cx , cy = map ( int , input ( ) . split ( ) ) ans = ( by - ay ) * ( cx - bx ) == ( cy - by ) * ( bx - ax ) if ans : ans = 0 else : ans = 1 d1 = ( by - ay ) ** 2 + ( bx - ax ) ** 2 d2 = ( cy - by ) ** 2 + ( cx - bx ) ** 2 if d1 == d2 : ans2 = 1 else : ans2 = 0 if ans and ans2 : print ( " Yes " ) else : print ( " No " )   NEW_LINE
for _ in range ( int ( input ( ) ) ) : a , b = map ( int , input ( ) . split ( ) ) print ( min ( 1 + ( a * ( a - 1 ) // 2 ) , b * ( b + 1 ) // 2 ) ) NEW_LINE
import mathn = int ( input ( ) ) s = input ( ) num = 0 nums = [ ]   for i in range ( n ) : if s [ i ] == ' W ' and num != 0 : nums . append ( num ) num = 0 elif s [ i ] == ' B ' : num += 1     if num != 0 : nums . append ( num )   print ( len ( nums ) ) print ( * nums )     NEW_LINE
def R ( ) : return map ( int , input ( ) . split ( ) ) def I ( ) : return int ( input ( ) ) def S ( ) : return str ( input ( ) )   def L ( ) : return list ( R ( ) )   from collections import Counter     import mathimport sys   from itertools import permutations   import bisect   a , b = R ( )   s = S ( ) l = len ( s ) step = [ ]   x , y = 0 , 0   d = { ' U ' : ( 0 , 1 ) , ' D ' : ( 0 , - 1 ) , ' L ' : ( - 1 , 0 ) , ' R ' : ( 1 , 0 ) }   step . append ( ( 0 , 0 ) )   for i in range ( l ) : dx , dy = d [ s [ i ] ] x += dx y += dy   step . append ( ( x , y ) )   tx , ty = step [ l ]   for j in range ( l ) : xj , yj = step [ j ]   if tx == 0 and ty == 0 : if a == xj and b == yj : print ( ' Yes ' ) exit ( )   else : continue   if tx == 0 and ( a != xj or ( b - yj ) % ty != 0 or ( ( b - yj ) % ty == 0 and ( b - yj ) / ty < 0 ) ) : continue   if ty == 0 and ( b != yj or ( a - xj ) % tx != 0 or ( ( a - xj ) % tx == 0 and ( a - xj ) / tx < 0 ) ) : continue   if tx == 0 or ty == 0 : print ( ' Yes ' ) exit ( )   if ( a - xj ) % tx == 0 and ( b - yj ) % ty == 0 and ( a - xj ) / tx == ( b - yj ) / ty >= 0 : print ( ' Yes ' ) exit ( )     print ( ' No ' )                   NEW_LINE
f = lambda : map ( int , input ( ) . split ( ) ) n , p = f ( ) s = [ 0 ] * nx , y = - p , 0 for i in range ( n ) : a , b = f ( ) x += a y += b s [ i ] = ( a , b ) s . sort ( key = lambda q : q [ 0 ] / q [ 1 ] ) for a , b in s : if b * x > a * y : x -= a y -= b   print ( y / x if x > 0 else - 1 ) NEW_LINE
for s in [ * open ( 0 ) ] [ 1 : ] : p , * a = map ( int , s . split ( ) ) ; print ( min ( - p % x for x in a ) ) NEW_LINE
for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE a = [ ] NEW_LINE i = 0 NEW_LINE while i < n : print ( 1 , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE print ( " " ) NEW_LINE
import sys , math , itertoolsfrom collections import Counter , deque , defaultdictfrom bisect import bisect_left , bisect_right from heapq import heappop , heappush , heapify , nlargestfrom copy import deepcopymod = 10 ** 9 + 7 INF = float ( ' inf ' ) def inp ( ) : return int ( sys . stdin . readline ( ) ) def inpl ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def inpl_1 ( ) : return list ( map ( lambda x : int ( x ) - 1 , sys . stdin . readline ( ) . split ( ) ) ) def inps ( ) : return sys . stdin . readline ( ) def inpsl ( x ) : tmp = sys . stdin . readline ( ) ; return tmp [ : x ] def err ( x ) : print ( x ) ; exit ( )   for _ in range ( inp ( ) ) : l , r = inpl ( ) y = r // l * l print ( l , y ) NEW_LINE
def prime ( n ) : for i in range ( 2 , n ) : if n % i == 0 : return False return Truen = int ( input ( ) ) ans = [ ] for i in range ( 2 , n + 1 ) : if prime ( i ) : ans . append ( i ) k = 2 while i ** k <= n : ans . append ( i ** k ) k += 1 print ( len ( ans ) ) print ( * ans ) NEW_LINE
hh , mm = input ( ) . split ( " : " ) def ispalindrome ( H , M ) : if ( H [ 0 ] == M [ 1 ] and H [ 1 ] == M [ 0 ] ) : return True return False   flag = minute = 0 while True : if ( ispalindrome ( hh , mm ) ) : print ( minute ) break if ( int ( mm [ 1 ] ) == 9 ) : temp = mm mm = str ( int ( temp [ 0 ] ) + 1 ) + "0" else : temp = mm mm = temp [ 0 ] + str ( int ( temp [ 1 ] ) + 1 ) minute += 1 if ( int ( mm ) > 59 ) : mm = "00" if ( int ( hh ) < 23 ) : temp = hh hh = str ( int ( temp ) + 1 ) if ( len ( hh ) < 2 ) : hh = "0" + hh else : hh = "00" NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) )   s = [ i + 1 for i in range ( n ) ]   for i in range ( m ) : for j in range ( len ( s ) ) : if ( s [ j ] >= 0 and s [ j ] >= l [ i ] ) : s [ j ] = - ( l [ i ] )   for i in s : print ( abs ( i ) , end = " ▁ " ) NEW_LINE
n = int ( input ( ) ) for i in range ( n ) : n , k = list ( map ( int , input ( ) . split ( ) ) ) if ( n == 1 or k == 1 ) or n == 2 and k == 2 : print ( ' YES ' ) else : print ( ' NO ' ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) s = input ( ) x = 0 a -= 1 b -= 1   if ( b < a - b ) : for i in range ( b ) : print ( " LEFT " ) x = 1 else : for i in range ( a - b ) : print ( " RIGHT " ) x = - 1 s = s [ : : - 1 ]     for i in s [ : - 1 ] : print ( f " PRINT ▁ { i } " ) if x == - 1 : print ( " LEFT " ) else : print ( " RIGHT " )     print ( f " PRINT ▁ { s [ -1 ] } " ) NEW_LINE
n = int ( input ( ) )   arr1 = set ( ) arr2 = set ( )   for i in range ( n ** 2 ) : a , b = map ( int , input ( ) . split ( ) ) if a not in arr1 and b not in arr2 : print ( i + 1 , end = " ▁ " ) arr1 . add ( a ) arr2 . add ( b )         NEW_LINE
n , h , a , b , k = map ( int , input ( ) . split ( ) ) for _ in range ( k ) : t1 , f1 , t2 , f2 = map ( int , input ( ) . split ( ) ) if t1 == t2 : ans = abs ( f1 - f2 ) else : if f1 < a : d1 = a elif f1 in range ( a , b + 1 ) : d1 = f1 else : d1 = b ans = abs ( d1 - f1 ) + abs ( t1 - t2 ) + abs ( d1 - f2 ) print ( ans ) NEW_LINE
def binary_search ( arr , low , high , x ) : if high >= low : mid = ( high + low ) // 2 if arr [ mid ] == x : return 1 elif arr [ mid ] > x : return binary_search ( arr , low , mid - 1 , x ) else : return binary_search ( arr , mid + 1 , high , x ) else : return 0   import mathn = int ( input ( ) ) n = n * ( 1 + 1 ) t = [ ] flag = 1 for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : t . append ( i * ( i + 1 ) ) k = len ( t ) - 1 for i in range ( 1 , int ( math . sqrt ( n ) ) + 1 ) : if ( binary_search ( t , 0 , k , n - i * ( i + 1 ) ) ) : print ( " YES " ) flag = 0 breakif ( flag ) : print ( " NO " ) NEW_LINE
def string_list ( s , char ) : output_list = [ ] intermediator = " " for i in range ( len ( s ) ) : if s [ i ] != char : intermediator += s [ i ] if i == len ( s ) - 1 : output_list . append ( int ( intermediator ) ) else : if intermediator : output_list . append ( int ( intermediator ) ) intermediator = " " return output_list     def list_string ( l , char ) : output_str = " " for i in range ( len ( l ) - 1 ) : output_str += str ( l [ i ] ) + char output_str += str ( l [ len ( l ) - 1 ] ) return output_str     def merge_sort ( l ) : def merge ( l1 , l2 ) : i , j = 0 , 0 output_list = [ ] while i < len ( l1 ) and j < len ( l2 ) : if l1 [ i ] < l2 [ j ] : output_list . append ( l1 [ i ] ) i += 1 else : output_list . append ( l2 [ j ] ) j += 1 if i == len ( l1 ) : output_list += ( l2 [ j : ] ) else : output_list += ( l1 [ i : ] ) return output_list   def sorts ( l ) : if len ( l ) < 2 : return l else : mid = len ( l ) // 2 left = sorts ( l [ : mid ] ) right = sorts ( l [ mid : ] ) return merge ( left , right ) return sorts ( l )       def main_function ( ) : output_list = [ ] t = int ( input ( ) ) for i in range ( t ) : x = int ( input ( ) ) output_list . append ( x // 2 ) return list_string ( output_list , " ▁ " )       print ( main_function ( ) )   NEW_LINE
n = int ( input ( ) ) NEW_LINE if n & ( n - 1 ) : NEW_LINE INDENT print ( " NO " ) else : NEW_LINE print ( " YES " ) NEW_LINE DEDENT
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = [ int ( s ) for s in input ( ) . split ( " ▁ " ) ] NEW_LINE ans = 0 NEW_LINE for x in a : ans = max ( 0 , ans + x ) NEW_LINE print ( ans ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) )     total = n * nlines = set ( ) len_lines = 0 cols = set ( ) len_cols = 0 res = [ ] for i in range ( m ) : x , y = map ( int , input ( ) . split ( ) )   aux = 0 if x not in lines : lines . add ( x ) aux += n - len_cols len_lines += 1   if y not in cols : cols . add ( y ) aux += n - len_lines len_cols += 1   total -= aux res . append ( str ( total ) )         print ( ' ▁ ' . join ( res ) )   NEW_LINE
n , k , x = list ( map ( int , input ( ) . split ( ) ) ) a = list ( map ( int , input ( ) . split ( ) ) ) c = x ** kpr = [ 0 ] su = [ 0 ] b = 0 for i in range ( n - 1 ) : b = a [ i ] | b pr . append ( b ) b = 0 for i in range ( n - 1 , 0 , - 1 ) : b = a [ i ] | b su . append ( b ) su = su [ : : - 1 ] d = [ ] for i in range ( n ) : d . append ( pr [ i ] | a [ i ] * c | su [ i ] ) print ( max ( d ) ) NEW_LINE
import sysimport mathimport itertoolsimport functoolsimport collectionsimport operatorimport fileinputimport copy   ORDA = 97 NEW_LINE
from sys import stdin   n , k = [ int ( x ) for x in stdin . readline ( ) . split ( ) ]   a = [ int ( x ) for x in stdin . readline ( ) . split ( ) ]   if sum ( a ) < k : NEW_LINE INDENT print ( - 1 ) elif sum ( a ) == k : NEW_LINE passelse : diff = 0 NEW_LINE DEDENT kCopy = k NEW_LINE sortA = sorted ( a , reverse = True )   while sortA : nxt = sortA [ - 1 ] NEW_LINE nxt -= diff   if len ( sortA ) * nxt <= k : diff += nxt NEW_LINE k -= len ( sortA ) * nxt NEW_LINE sortA . pop ( ) else : break NEW_LINE p = k % len ( sortA ) NEW_LINE diff += k // len ( sortA ) NEW_LINE ind = 0   while p : if NEW_LINE a [ ind ] > diff : p -= 1 NEW_LINE ind += 1 NEW_LINE outL = [ ]   for x in range ( ind , len ( a ) ) : if NEW_LINE a [ x ] > diff : outL . append ( str ( x + 1 ) ) NEW_LINE for x in range ( ind ) : if NEW_LINE a [ x ] > diff + 1 : outL . append ( str ( x + 1 ) ) NEW_LINE if outL : print ( ' ▁ ' . join ( outL ) ) NEW_LINE
def solve ( str_ ) : res = " " for i in str_ : if i == "7" or i == "4" : res += i if len ( res ) > 0 : ans = int ( res ) else : ans = 0 return ans   a , b = map ( int , input ( ) . split ( ) ) while True : a += 1 a_str = str ( a ) res = " " if solve ( a_str ) == b : print ( a ) break NEW_LINE
n , s = map ( int , input ( ) . split ( " ▁ " ) ) ans = - 1 for _ in range ( n ) : a , b = map ( int , input ( ) . split ( " ▁ " ) ) if a < s : if ( b != 0 ) : ans = max ( ans , 100 - b ) if a <= s and b == 0 : ans = max ( ans , 0 ) print ( ans ) NEW_LINE
n = int ( input ( ) ) l1 = [ int ( x ) for x in input ( ) . split ( ) ] c1 , c2 , c3 = l1 . count ( 1 ) , l1 . count ( 2 ) , l1 . count ( 3 ) pos_1 , pos_2 , pos_3 = [ ] , [ ] , [ ] for i in range ( len ( l1 ) ) : if l1 [ i ] == 1 : pos_1 . append ( i + 1 ) elif l1 [ i ] == 2 : pos_2 . append ( i + 1 ) elif l1 [ i ] == 3 : pos_3 . append ( i + 1 ) if c1 != 0 and c2 != 0 and c3 != 0 : teams = min ( c1 , c2 , c3 ) print ( teams ) for i in range ( teams ) : print ( pos_1 [ i ] , pos_2 [ i ] , pos_3 [ i ] ) else : print ( 0 ) NEW_LINE
import ioimport osimport mathinput = io . BytesIO ( os . read ( 0 , os . fstat ( 0 ) . st_size ) ) . readline NEW_LINE
a , b , c = list ( map ( int , input ( ) . split ( ) ) )   size = a * c   wait = 0 while b * c < size - b * wait : wait += 1   print ( wait ) NEW_LINE
F = open ( ' input . txt ' ) I = lambda : map ( int , F . readline ( ) . split ( ) ) n , k = I ( ) ; a = sorted ( zip ( I ( ) , range ( n ) ) ) [ : : - 1 ] print ( a [ k - 1 ] [ 0 ] , ' \n ' , * ( y + 1 for x , y in a [ : k ] ) , file = open ( ' output . txt ' , ' w ' ) ) NEW_LINE
from sys import stdout   def transpose ( m ) : NEW_LINE
from collections import defaultdictdef check ( arr ) : arr . sort ( ) value = [ i + 1 for i in range ( len ( arr ) ) ] if ( arr == value ) : return True return False   for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) high = max ( l ) low = len ( l ) - high ans = [ ] if ( check ( l [ : low ] ) == True and check ( l [ low : ] ) == True ) : ans . append ( [ low , high ] ) if ( low != high and check ( l [ : high ] ) == True and check ( l [ high : ] ) == True ) : ans . append ( [ high , low ] ) print ( len ( ans ) ) for i in ans : print ( * i ) NEW_LINE
n , pos , l , r = map ( int , input ( ) . split ( ) ) result = abs ( pos - l ) + r - l + 2 if ( l == 1 ) : if ( abs ( pos - r ) + 1 < result ) : result = abs ( pos - r ) + 1 if ( r == n ) : if ( abs ( pos - l ) + 1 < result ) : result = abs ( pos - l ) + 1 if ( l == 1 and r == n ) : result = 0 if ( abs ( pos - r ) + r - l + 2 < result ) : result = abs ( pos - r ) + r - l + 2 print ( result ) NEW_LINE
dc = input ( ) t = dc . istitle ( ) if t : print ( dc ) else : s = list ( dc ) b = s . pop ( 0 ) b = b . upper ( ) s . insert ( 0 , b ) print ( ' ' . join ( s ) ) NEW_LINE
n , m = map ( int , input ( ) . split ( ) ) s = [ input ( ) for _ in range ( n ) ] l = [ ] for i in range ( n ) : se = set ( ) for j in range ( m ) : if s [ i ] [ j ] == ' # ' : se . add ( j ) for li in l : if len ( se & li ) != 0 and se != li : print ( ' No ' ) exit ( ) l . append ( se ) print ( ' Yes ' ) NEW_LINE
import sys , functools , collections , bisect , math , NEW_LINE INDENT heapqinput = sys . stdin . readline NEW_LINE DEDENT
num = int ( input ( ) )   ans = [ ]   while num : ans . append ( 1 ) while len ( ans ) > 1 and ans [ - 1 ] == ans [ - 2 ] : x = ans . pop ( ) + 1 ans [ - 1 ] = x num -= 1 print ( * ans )   NEW_LINE
n = int ( input ( ) ) if n != 1 : array = [ 1 for k in range ( n + 1 ) ] array [ 1 ] = 1 array [ 2 ] = 2 sumi = 3 for k in range ( 3 , n + 1 ) : array [ k ] = array [ k - 1 ] + array [ k - 2 ] % int ( 1e9 + 7 ) sumi += array [ k ] % int ( 1e9 + 7 ) print ( sumi % int ( 1e9 + 7 ) ) else : print ( 1 ) NEW_LINE
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( " input . txt " , " r " ) import time NEW_LINE
import sysinput = sys . stdin . readline   '''   '''   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) swaps = 0 for i in range ( 0 , 2 * n , 2 ) : if a [ i ] == a [ i + 1 ] : continue c = a [ i ] j = i + 2 while c != a [ j ] : j += 1 MIN = i + 1 while j > MIN : a [ j ] , a [ j - 1 ] = a [ j - 1 ] , a [ j ] j -= 1 swaps += 1   print ( swaps ) NEW_LINE
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( " input . txt " , " r " ) import time , math NEW_LINE
a = [ * open ( 0 ) ] [ 1 ] . count ; print ( * [ 1 ] * a ( ' n ' ) + [ 0 ] * a ( ' r ' ) ) NEW_LINE
import sysfrom math import *   def minp ( ) : return sys . stdin . readline ( ) . strip ( )   def mint ( ) : return int ( minp ( ) )   def mints ( ) : return map ( int , minp ( ) . split ( ) )   def add ( a , x , v ) : while x < len ( a ) : a [ x ] += v x |= x + 1 def get ( a , x ) : r = 0 while x >= 0 : r += a [ x ] x = ( x & ( x + 1 ) ) - 1 return r     n , k , a , b , q = mints ( ) h1 = [ 0 ] * nh2 = [ 0 ] * nz = [ 0 ] * nfor i in range ( q ) : t = tuple ( mints ( ) ) if t [ 0 ] == 1 : p = z [ t [ 1 ] - 1 ] pp = p + t [ 2 ] add ( h1 , t [ 1 ] - 1 , min ( a , pp ) - min ( a , p ) ) add ( h2 , t [ 1 ] - 1 , min ( b , pp ) - min ( b , p ) ) z [ t [ 1 ] - 1 ] = pp else : print ( get ( h2 , t [ 1 ] - 2 ) + get ( h1 , n - 1 ) - get ( h1 , t [ 1 ] + k - 2 ) ) NEW_LINE
for x in range ( int ( input ( ) ) ) : n = int ( input ( ) ) print ( n // 2 - 1 ) if n % 2 == 0 else print ( n // 2 ) NEW_LINE
N = int ( input ( ) ) b = bin ( N ) [ 2 : ] [ : : - 1 ] count = len ( b ) - 1   def print_matrix ( m ) : print ( len ( m ) ) for i in range ( len ( m ) ) : print ( " " . join ( m [ i ] ) )   m = [ [ ' N ' for i in range ( 2 * ( len ( b ) ) + count ) ] for j in range ( 2 * ( len ( b ) ) + count ) ] for i in range ( count - 1 ) : val = len ( m ) - count + i m [ val ] [ val + 1 ] = ' Y ' m [ val + 1 ] [ val ] = ' Y '   if count > 0 : m [ len ( m ) - 1 ] [ 1 ] = ' Y ' m [ 1 ] [ len ( m ) - 1 ] = ' Y '   NEW_LINE
for _ in range ( int ( input ( ) ) ) : x , y = [ int ( i ) for i in input ( ) . split ( ) ] a , b = [ int ( i ) for i in input ( ) . split ( ) ] print ( min ( ( max ( x , y ) - min ( x , y ) ) * a + min ( x , y ) * b , ( x + y ) * a ) ) NEW_LINE
h1 , h2 = map ( int , input ( ) . split ( ) )   up , down = map ( int , input ( ) . split ( ) )   v = up - downif v <= 0 : if ( ( h2 - h1 ) <= 8 * up ) : print ( 0 ) else : print ( - 1 ) else : days = 0 h1 += 8 * up while h1 < h2 : h1 -= 12 * down h1 += 12 * up days += 1 print ( days ) NEW_LINE
e = 10 ** 9 + 9 n , m = map ( int , input ( ) . split ( ) ) t = pow ( 2 , m , e ) r = 1 for i in range ( n ) : r = ( r * ( t - i - 1 ) ) % eprint ( r ) NEW_LINE
import mathfor NEW_LINE _ in range ( int ( input ( ) ) ) : n , k = map ( int , input ( ) . split ( ) ) NEW_LINE a = [ * map ( int , input ( ) . split ( ) ) ] NEW_LINE x = a [ 1 ] - a [ 0 ] NEW_LINE for i in range ( 1 , n ) : x = math . gcd ( a [ i ] - a [ 0 ] , x ) NEW_LINE k -= a [ 0 ] NEW_LINE if k % x == 0 : NEW_LINE INDENT print ( " YES " ) else : NEW_LINE print ( " NO " ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ' ▁ ' ) ) matiz = [ list ( input ( ) + ' . ' ) for i in range ( n ) ] matiz += [ list ( ' . ' * ( m + 1 ) ) ] def dfs ( ) : flag = False for i in range ( n ) : for j in range ( m ) : if matiz [ i ] [ j ] != ' . ' : d = 0 d += ( matiz [ i + 1 ] [ j ] == matiz [ i ] [ j ] ) d += ( matiz [ i - 1 ] [ j ] == matiz [ i ] [ j ] ) d += ( matiz [ i ] [ j + 1 ] == matiz [ i ] [ j ] ) d += ( matiz [ i ] [ j - 1 ] == matiz [ i ] [ j ] ) if d < 2 : matiz [ i ] [ j ] = ' . ' flag = True return flag for i in range ( 500 ) : dfs ( ) for i in range ( n ) : for j in range ( m ) : if matiz [ i ] [ j ] != ' . ' : print ( ' Yes ' ) exit ( ) print ( ' No ' ) NEW_LINE
import math   n , t = list ( map ( int , input ( ) . split ( ) ) )   matrix = [ list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( n ) ]   def calc_xi ( s , d ) : if t < s : return s u = math . ceil ( ( t - s ) / d ) return s + u * d   xis = [ calc_xi ( s , d ) for [ s , d ] in matrix ]   print ( xis . index ( min ( xis ) ) + 1 ) NEW_LINE
import osimport sysfrom io import BytesIO , IOBase   BUFSIZE = 8192     class FastIO ( IOBase ) : newlines = 0   def __init__ ( self , file ) : self . _fd = file . fileno ( ) self . buffer = BytesIO ( ) self . writable = " x " in file . mode or " r " not in file . mode self . write = self . buffer . write if self . writable else None   def read ( self ) : while True : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) if not b : break ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines = 0 return self . buffer . read ( )   def readline ( self ) : while self . newlines == 0 : b = os . read ( self . _fd , max ( os . fstat ( self . _fd ) . st_size , BUFSIZE ) ) self . newlines = b . count ( b " \n " ) + ( not b ) ptr = self . buffer . tell ( ) self . buffer . seek ( 0 , 2 ) , self . buffer . write ( b ) , self . buffer . seek ( ptr ) self . newlines -= 1 return self . buffer . readline ( )   def flush ( self ) : if self . writable : os . write ( self . _fd , self . buffer . getvalue ( ) ) self . buffer . truncate ( 0 ) , self . buffer . seek ( 0 )     class IOWrapper ( IOBase ) : def __init__ ( self , file ) : self . buffer = FastIO ( file ) self . flush = self . buffer . flush self . writable = self . buffer . writable self . write = lambda s : self . buffer . write ( s . encode ( " ascii " ) ) self . read = lambda : self . buffer . read ( ) . decode ( " ascii " ) self . readline = lambda : self . buffer . readline ( ) . decode ( " ascii " )     sys . stdin , sys . stdout = IOWrapper ( sys . stdin ) , IOWrapper ( sys . stdout ) input = lambda : sys . stdin . readline ( ) . rstrip ( " \n " ) NEW_LINE
    t = list ( map ( int , input ( ) . split ( ) ) )   g = list ( map ( int , input ( ) . split ( ) ) )     re = 0 for j in range ( 3 ) : if t [ j ] > g [ j ] : re += ( t [ j ] - g [ j ] ) // 2   u = 0     for k in range ( 3 ) : if t [ k ] < g [ k ] : if re >= g [ k ] - t [ k ] : re -= ( g [ k ] - t [ k ] ) else : print ( ' No ' ) u += 1 breakif u == 0 : print ( ' Yes ' ) NEW_LINE
def solve ( arr , n ) : good = [ ] for i in range ( n ) : is_good = True for j in arr [ i ] : if j not in [ - 1 , 0 , 2 ] : is_good = False break if is_good : good . append ( i + 1 ) print ( len ( good ) ) print ( * good )                             def main ( ) : n = int ( input ( ) ) NEW_LINE
import math , sys , bisect , heapq , osfrom collections import defaultdict , Counter , dequefrom itertools import groupby , accumulatefrom functools import lru_cache NEW_LINE
import sysdef get_list ( ) : return list ( map ( int , sys . stdin . readline ( ) . strip ( ) . split ( ) ) ) n = int ( sys . stdin . readline ( ) . strip ( ) ) ar = get_list ( ) prev = 0 for i in ar : print ( i + prev ) if ( i + prev ) > prev : prev += i NEW_LINE
n = int ( input ( ) ) lst = list ( map ( int , input ( ) . split ( ) ) ) k = 0 m = 0 folders = [ ] for i in range ( n ) : if lst [ i ] < 0 : k += 1 if k == 3 : folders . append ( i - m ) m = i k = 1 if m < n : folders . append ( n - m ) print ( len ( folders ) ) for i in range ( len ( folders ) ) : if i == len ( folders ) - 1 : print ( folders [ i ] , end = ' \n ' ) else : print ( folders [ i ] , end = ' ▁ ' ) NEW_LINE
n = int ( input ( ) ) print ( 9 * n , end = " ▁ " ) print ( 8 * n ) NEW_LINE
r1 , r2 = [ int ( y ) for y in input ( ) . split ( ) ] c1 , c2 = [ int ( y ) for y in input ( ) . split ( ) ] d1 , d2 = [ int ( y ) for y in input ( ) . split ( ) ] a = ( r1 + c1 - d2 ) // 2 b = r1 - ac = c1 - ad = d1 - aif a not in range ( 1 , 10 ) or b not in range ( 1 , 10 ) or c not in range ( 1 , 10 ) or d not in range ( 1 , 10 ) : print ( - 1 ) elif a == b or a == c or a == d or b == c or b == d or c == d : print ( - 1 ) elif a + b != r1 or c + d != r2 or a + c != c1 or b + d != c2 or a + d != d1 or b + c != d2 : print ( - 1 ) else : print ( a , b ) print ( c , d ) NEW_LINE
n = int ( input ( ) ) count = 0 for i in range ( 0 , n ) : x = input ( ) if x . count ( '1' ) >= 2 : count += 1 print ( count ) NEW_LINE
n , c = map ( int , input ( ) . split ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) mn = min ( l ) mx = max ( l ) if mx - mn > c : print ( " NO " ) else : print ( " YES " ) for i in range ( n ) : h = l [ i ] for j in range ( mn ) : print ( 1 , end = " ▁ " ) for j in range ( h - mn ) : print ( j + 1 , end = " ▁ " ) print ( ) NEW_LINE
from math import * n , o = int ( input ( ) ) , 0 for i in range ( n ) : r , t = map ( int , input ( ) . split ( ) ) r += ceil ( log ( t , 4 ) ) r += t == 1 o = max ( o , r ) print ( o ) NEW_LINE
a = input ( ) NEW_LINE b = input ( ) NEW_LINE c = int ( a ) + int ( b )   new_a = int ( str ( a ) . replace ( '0' , ' ' ) ) NEW_LINE new_b = int ( str ( b ) . replace ( '0' , ' ' ) ) NEW_LINE new_c = int ( str ( c ) . replace ( '0' , ' ' ) )   print ( " YES " if new_a + new_b == new_c else " NO " ) NEW_LINE
import sys   n = int ( sys . stdin . readline ( ) )   iterations = 0 NEW_LINE prev_idx = 0 NEW_LINE idx = 1   step = 5 NEW_LINE width = 1   while idx <= n : prev_idx = idx NEW_LINE idx += step NEW_LINE step *= 2 NEW_LINE width *= 2   step //= 2 NEW_LINE width //= 2   assert n >= prev_idxif NEW_LINE n < prev_idx + width : print ( " Sheldon " ) elif n < prev_idx + 2 * width : print ( " Leonard " ) elif n < prev_idx + 3 * width : print ( " Penny " ) elif n < prev_idx + 4 * width : print ( " Rajesh " ) else : print ( " Howard " ) NEW_LINE
from collections import Counter   def solve ( ) : n = int ( input ( ) ) sum , c_o , c_e = 0 , 0 , 0   array = list ( map ( int , input ( ) . split ( ) ) )   for i in array : if i % 2 : c_o += 1 else : c_e += 1 sum += i   if sum % 2 : return " YES "   else : if c_e == 0 and n % 2 == 0 : return " NO " if c_o == 0 : return " NO " return " YES "     for i in range ( int ( input ( ) ) ) : print ( solve ( ) ) NEW_LINE
def solve ( arr , n ) : arr = sorted ( arr ) res = sum ( arr ) if res % 2 == 0 : return res for i in range ( n ) : if arr [ i ] % 2 != 0 : res -= arr [ i ] if res % 2 == 0 : return res return 0                           def main ( ) : NEW_LINE
primLinea = input ( ) . split ( ) iteraciones = int ( primLinea [ 0 ] ) indiv = int ( primLinea [ 1 ] ) par = int ( primLinea [ 2 ] ) parParaIndiv = 0 personas = input ( ) . split ( ) negados = 0 for i in range ( 0 , iteraciones ) : costumer = int ( personas [ i ] ) if costumer == 1 : if indiv > 0 : indiv -= 1 elif par > 0 : par -= 1 parParaIndiv += 1 elif parParaIndiv > 0 : parParaIndiv -= 1 else : negados += 1 elif costumer == 2 : if par > 0 : par -= 1 else : negados += 2 print ( negados ) NEW_LINE
import sysimport mathfrom collections import defaultdict , dequeimport heapq   n , k = map ( int , sys . stdin . readline ( ) . split ( ) ) graph = defaultdict ( list ) st = 2 q = deque ( ) for i in range ( k ) : graph [ 1 ] . append ( st ) q . append ( st ) st += 1 leaves = [ 1 for _ in range ( k ) ] cnt = 0 while q and st <= n : a = q . popleft ( ) graph [ a ] . append ( st ) q . append ( st ) leaves [ ( cnt ) % k ] += 1 cnt += 1 st += 1 NEW_LINE
from sys import stdin , stdoutnmbr = lambda : int ( stdin . readline ( ) ) lst = lambda : list ( map ( int , stdin . readline ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE
R = lambda : map ( int , input ( ) . split ( ) ) n , m = R ( ) if n < 3 or m < 9 : print ( - 1 ) exit ( ) a = [ [ 0 ] * ( n - 2 ) for i in range ( n - 2 ) ] for i in range ( 1 , m + 1 ) : x , y = R ( ) x -= 1 y -= 1 for x0 in range ( x - 2 , x + 1 ) : for y0 in range ( y - 2 , y + 1 ) : if x0 < 0 or y0 < 0 or x0 >= n - 2 or y0 >= n - 2 : continue a [ x0 ] [ y0 ] += 1 if a [ x0 ] [ y0 ] == 9 : print ( i ) exit ( ) print ( - 1 ) NEW_LINE
n = int ( input ( ) ) for i in range ( 2 , 10 ** 6 ) : while n % ( i * i ) == 0 : n //= iprint ( n ) NEW_LINE
s1 = ' qwertyuiop ' s2 = ' asdfghjkl ; ' s3 = ' zxcvbnm , . / ' shift = input ( ) s = input ( ) news = ' ' if ( shift == ' R ' ) :   for i in s : if i in s1 : u = s1 . index ( i ) news += s1 [ u - 1 ] elif i in s2 : u = s2 . index ( i ) news += s2 [ u - 1 ] elif i in s3 : u = s3 . index ( i ) news += s3 [ u - 1 ] print ( news ) else : for i in s : if i in s1 : u = s1 . index ( i ) news += s1 [ u + 1 ] elif i in s2 : u = s2 . index ( i ) news += s2 [ u + 1 ] elif i in s3 : u = s3 . index ( i ) news += s3 [ u + 1 ] print ( news )       NEW_LINE
import sys , os , iodef rs ( ) : return sys . stdin . readline ( ) . rstrip ( ) def ri ( ) : return int ( sys . stdin . readline ( ) ) def ria ( ) : return list ( map ( int , sys . stdin . readline ( ) . split ( ) ) ) def ws ( s ) : sys . stdout . write ( s + ' \n ' ) def wi ( n ) : sys . stdout . write ( str ( n ) + ' \n ' ) def wia ( a ) : sys . stdout . write ( ' ▁ ' . join ( [ str ( x ) for x in a ] ) + ' \n ' ) import math , datetime , functools , itertools , operator , bisect , fractions , statisticsfrom collections import deque , defaultdict , OrderedDict , Counterfrom fractions import Fractionfrom decimal import Decimalfrom sys import stdoutfrom heapq import heappush , heappop , heapify , _heapify_max , _heappop_max , nsmallest , nlargest NEW_LINE
def STR ( ) : return list ( input ( ) ) def INT ( ) : return int ( input ( ) ) def MAP ( ) : return map ( int , input ( ) . split ( ) ) def MAP2 ( ) : return map ( float , input ( ) . split ( ) ) def LIST ( ) : return list ( map ( int , input ( ) . split ( ) ) ) def STRING ( ) : return input ( ) import stringimport sysfrom heapq import heappop , heappushfrom bisect import * from collections import deque , Counter , defaultdictfrom math import * from itertools import permutations , accumulatedx = [ - 1 , 1 , 0 , 0 ] dy = [ 0 , 0 , 1 , - 1 ] NEW_LINE
n = int ( input ( ) ) s = " " for i in range ( 1 , 1001 ) : s = s + str ( i ) print ( s [ n - 1 ] ) NEW_LINE
n = int ( input ( ) ) s = list ( input ( ) )     if s == sorted ( s ) : print ( " NO " ) else : print ( " YES " ) for i in range ( 0 , n - 1 ) : if s [ i ] > s [ i + 1 ] : print ( i + 1 , i + 2 ) break     NEW_LINE
t = int ( input ( ) ) for _ in range ( t ) : s = input ( ) s = list ( s ) for i in range ( len ( s ) - 1 ) : if s [ i ] == s [ i + 1 ] : s [ i ] = " ▁ " s [ i + 1 ] = " ▁ " print ( " " . join ( sorted ( set ( s ) ) ) ) NEW_LINE
v = [ int ( i ) for i in input ( ) . split ( ) ]   a = v [ 0 ] - 1 b = v [ 1 ] - 1 x = v [ 2 ]   ans = [ '0' , '1' ] dif = 1   while a > 0 and b > 0 and dif < x : NEW_LINE
import mathn , m , a = list ( map ( int , input ( ) . split ( ) ) ) print ( ( math . ceil ( n / a ) ) * ( math . ceil ( m / a ) ) ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) ) ans = float ( " inf " )   for n in arr : if b % n == 0 : if b // n < ans : ans = b // n     print ( ans ) NEW_LINE
n = int ( input ( ) ) m = int ( input ( ) ) if n >= 27 : print ( m ) else : print ( m % 2 ** n ) NEW_LINE
s = input ( ) ans = 0 for i in range ( len ( s ) ) : if i == 0 : ans += ( min ( abs ( ord ( s [ i ] ) - ord ( ' a ' ) ) , 26 - abs ( ord ( s [ i ] ) - ord ( ' a ' ) ) ) ) else : ans += ( min ( abs ( ord ( s [ i ] ) - ord ( s [ i - 1 ] ) ) , 26 - abs ( ord ( s [ i ] ) - ord ( s [ i - 1 ] ) ) ) ) print ( ans ) NEW_LINE
n = int ( input ( ) ) + 1 c = 1 while '8' not in str ( n ) : n += 1 c += 1   print ( c ) NEW_LINE
import pdb   def correct_colouring ( x0 , edges , visited , colouring ) : s = [ x0 ] visited [ x0 ] = True colouring [ x0 ] = 1 while s : x = s . pop ( ) for neigh in edges [ x ] : if not visited [ neigh ] : visited [ neigh ] = True colouring [ neigh ] = - colouring [ x ] s . append ( neigh ) elif colouring [ neigh ] == colouring [ x ] : return False return True   def solve ( ) : n , m = map ( int , input ( ) . split ( ) ) edges = [ [ ] for _ in range ( n + 1 ) ] for _ in range ( m ) : i , j = map ( int , input ( ) . split ( ) ) edges [ i ] . append ( j ) edges [ j ] . append ( i ) visited = [ False for _ in range ( n + 1 ) ] colouring = [ 0 for _ in range ( n + 1 ) ] removed = 0 for x0 in range ( 1 , n + 1 ) : if not visited [ x0 ] : correct = correct_colouring ( x0 , edges , visited , colouring ) if not correct : removed += 1 if ( n - removed ) % 2 : removed += 1 print ( removed )                   if __name__ == ' _ _ main _ _ ' : solve ( ) NEW_LINE
for i in range ( int ( input ( ) ) ) : s = input ( ) if min ( s . count ( '1' ) , s . count ( '0' ) ) % 2 != 0 : print ( ' DA ' ) else : print ( ' NET ' )                           NEW_LINE
t = int ( input ( ) ) NEW_LINE for i in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE count0 = 0 NEW_LINE count1 = 0 NEW_LINE for i in range ( n ) : if NEW_LINE a [ i ] == 1 : count1 += 1 else : count0 += 1 NEW_LINE if count1 <= n // 2 : res = [ 0 ] * ( n - count1 ) NEW_LINE print ( len ( res ) ) NEW_LINE print ( * res ) else : if count1 % 2 != 0 : NEW_LINE INDENT res = [ 1 ] * ( n - count0 - 1 ) else : NEW_LINE res = [ 1 ] * ( n - count0 ) NEW_LINE DEDENT print ( len ( res ) ) NEW_LINE print ( * res ) NEW_LINE
n , x , y = map ( int , input ( ) . split ( ) )   print ( - 1 if n > y or ( y - n + 1 ) ** 2 + ( n - 1 ) < x else '1 \n ' * ( n - 1 ) + str ( y - n + 1 ) ) NEW_LINE
n = int ( input ( ) ) karts = list ( map ( int , input ( ) . split ( ) ) ) output = [ ] output2 = [ ] karts . sort ( )   repeat = 0 for i in range ( n - 1 , 0 , - 1 ) : if karts [ i ] == karts [ i - 1 ] : repeat += 1 if repeat == 1 : output2 . append ( karts [ i ] ) else : repeat = 0 output . append ( karts [ i ] ) output . append ( karts [ 0 ] ) if len ( output2 ) > 0 and output [ 0 ] == output2 [ 0 ] : output2 . pop ( 0 )   print ( len ( output2 ) + len ( output ) ) for i in range ( len ( output2 ) - 1 , - 1 , - 1 ) : print ( output2 [ i ] , end = " ▁ " ) print ( * output ) NEW_LINE
n , m , k = map ( int , input ( ) . split ( ) ) M = int ( 1e9 + 7 ) N = n * niv = [ 0 ] * ( N + 1 ) iv [ 1 ] = 1 for i in range ( 2 , N + 1 ) : iv [ i ] = M - M // i * iv [ M % i ] % Mf1 = [ 1 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : f1 [ i ] = f1 [ i - 1 ] * i % Mf2 = [ 1 ] * ( N + 1 ) for i in range ( 1 , N + 1 ) : f2 [ i ] = f2 [ i - 1 ] * iv [ i ] % Mleft = m % n NEW_LINE
import sys , os . pathif __name__ == ' _ _ main _ _ ' : if ( os . path . exists ( ' input . txt ' ) ) : sys . stdin = open ( " input . txt " , " r " ) sys . stdout = open ( " output . txt " , " w " ) k = int ( input ( ) ) r = k ** .1 st = " codeforces " ans = " " r = int ( r ) ind = 0 while ( ( r + 1 ) ** ( ind ) ) * ( r ** ( 10 - ind ) ) < k : ind += 1 for i in range ( 10 ) : for j in range ( r ) : ans += st [ i ] if i < ind : ans += st [ i ] print ( ans ) NEW_LINE
import sysfrom os import pathif ( path . exists ( ' input . txt ' ) and path . exists ( ' output . txt ' ) ) : sys . stdout = open ( ' output . txt ' , ' w ' ) sys . stdin = open ( ' input . txt ' , ' r ' )   def main ( ) : s = input ( ) n = len ( s ) l , r = 0 , n - 1 left , right = [ ] , [ ] while l < r : while l < r and s [ l ] == ' ) ' : l += 1 while l < r and s [ r ] == ' ( ' : r -= 1 if l < r and s [ l ] == ' ( ' and s [ r ] == ' ) ' : left . append ( l + 1 ) right . append ( r + 1 ) l += 1 r -= 1   if not left : print ( 0 ) else : print ( f " 1 \n { 2 ▁ * ▁ len ( left ) } " ) for l in left : print ( l , end = ' ▁ ' ) for r in reversed ( right ) : print ( r , end = ' ▁ ' )     main ( ) NEW_LINE
s = input ( ) c = len ( s ) for i in range ( len ( s ) - 1 , 0 , - 1 ) : k = s [ 0 : i + 1 ] if ( k != k [ : : - 1 ] ) : print ( c ) exit ( ) c -= 1 if ( c == 1 ) : print ( "0" ) NEW_LINE
t = int ( input ( ) ) NEW_LINE for _ in range ( t ) : n = int ( input ( ) ) NEW_LINE a = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE b = sorted ( a ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 1 ) else : NEW_LINE mini = - 1 NEW_LINE DEDENT if b [ 0 ] != b [ 1 ] : NEW_LINE INDENT mini = b [ 0 ] else : NEW_LINE for NEW_LINE DEDENT i in range ( 1 , n - 1 ) : NEW_LINE if b [ i ] != b [ i + 1 ] and b [ i ] != b [ i - 1 ] : mini = b [ i ] NEW_LINE break NEW_LINE if mini == - 1 and b [ n - 1 ] != b [ n - 2 ] : mini = b [ n - 1 ] NEW_LINE if mini == - 1 : NEW_LINE INDENT print ( - 1 ) else : NEW_LINE print ( a . index ( mini ) + 1 ) NEW_LINE DEDENT
z = 0 x = list ( map ( int , input ( ) . rstrip ( ) . split ( ) ) ) for i in range ( 1 , x [ 2 ] + 1 ) : z = z + ( i * x [ 0 ] ) if x [ 1 ] - z < 0 : print ( abs ( z - x [ 1 ] ) ) else : print ( 0 ) NEW_LINE
for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) NEW_LINE if n == 1 : NEW_LINE INDENT print ( 9 ) elif n == 2 : NEW_LINE print ( 98 ) elif n == 3 : NEW_LINE print ( 989 ) else : NEW_LINE print ( 989 , end = ' ' ) NEW_LINE DEDENT for i in range ( n - 3 ) : print ( i % 10 , end = ' ' ) NEW_LINE print ( ) NEW_LINE
from sys import stdin , stdoutstdin . readlinedef mp ( ) : return list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) def it ( ) : return int ( stdin . readline ( ) . strip ( ) ) from collections import defaultdict as dd , Counter as C , dequefrom math import ceil   n = it ( ) l = mp ( ) ans = 1 flag = 0 for i in range ( n ) : if l [ i ] == 1 and flag == 0 : ind = i flag = 1 elif l [ i ] == 1 and flag : ans *= ( i - ind ) ind = iif not flag : print ( 0 ) else : print ( ans ) NEW_LINE
n = int ( input ( ) ) s = input ( )   while ' ogo ' in s : x = s . replace ( " ogo " , " * * * " , 1 ) while x != s : s = x x = s . replace ( " * go " , ' * ' )     print ( s ) NEW_LINE
num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) )   mx = max ( arr )   print ( max ( 0 , mx - 25 ) )                   NEW_LINE
import sysfrom functools import lru_cache , cmp_to_keyfrom heapq import merge , heapify , heappop , heappush NEW_LINE
if __name__ == " _ _ main _ _ " : boxes = int ( input ( ) ) candy_supply = [ ] for i in range ( boxes ) : candies = int ( input ( ) ) candy_supply . append ( candies ) candy_supply = sorted ( candy_supply ) if boxes == 4 : c_range = candy_supply [ 3 ] - candy_supply [ 0 ] a_mean = ( candy_supply [ 0 ] + candy_supply [ 1 ] + candy_supply [ 2 ] + candy_supply [ 3 ] ) / 4 median = ( candy_supply [ 2 ] + candy_supply [ 1 ] ) / 2 if c_range == a_mean == median : print ( ' YES ' ) else : print ( ' NO ' ) elif boxes == 0 : print ( ' YES ' ) candy_supply = [ 1 , 2 , 2 , 3 ] for box in candy_supply : print ( box ) elif boxes == 1 : print ( ' YES ' ) x1 = candy_supply [ 0 ] candy_supply . append ( 2 * x1 ) candy_supply . append ( 2 * x1 ) candy_supply . append ( 3 * x1 ) print ( candy_supply [ 1 ] ) print ( candy_supply [ 2 ] ) print ( candy_supply [ 3 ] ) elif boxes == 3 : NEW_LINE
t , s , q = map ( int , input ( ) . split ( ) ) init = q count = 1 while ( init < t / s ) : init = init * q count = count + 1 print ( count ) NEW_LINE
import mathn = int ( input ( ) ) lis = [ ] wall = [ ] for _ in range ( n ) : a , b , c = map ( int , input ( ) . split ( ) ) lis . append ( [ a , b , c ] ) m = int ( input ( ) ) for _ in range ( m ) : a , b , c = map ( int , input ( ) . split ( ) ) wall . append ( [ a , b , c ] ) ans = 0 for i in range ( n ) : tmp = 1000000000000000 x , y , z = lis [ i ] for j in range ( m ) : a , b , c = wall [ j ] if a // z == 0 : continue else : cove = ( a // z ) * b tmp = min ( tmp , math . ceil ( ( 2 * ( x + y ) ) / cove ) * c ) ans += tmpprint ( ans ) NEW_LINE
  def check ( a , x ) : for i in range ( len ( a ) ) : if a [ i ] < len ( a ) - i : return False return True   n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) a = sorted ( a )   piles = [ ]   for i in a : if len ( piles ) == 0 : piles . append ( [ i ] ) else : flg = 1 for j in range ( len ( piles ) ) : if len ( piles [ j ] ) <= i : piles [ j ] . append ( i ) flg = 0 break if flg : piles . append ( [ i ] )   print ( len ( piles ) )       NEW_LINE
t = int ( input ( ) ) for _ in range ( t ) : n = int ( input ( ) ) ali = list ( map ( int , input ( ) . split ( ) ) ) q = - 1 w = - 1 e = - 1 f = 0 for i in range ( 1 , n - 1 ) : if ( ali [ i ] > ali [ i - 1 ] and ali [ i ] > ali [ i + 1 ] ) : f = 1 q = i w = i + 1 e = i + 2 break if ( f == 1 ) : print ( " YES " ) print ( q , w , e ) else : print ( " NO " ) NEW_LINE
def solution ( ) : n = int ( input ( ) ) num = str ( input ( ) ) first = [ int ( nm ) for nm in num [ : n ] ] second = [ int ( nm ) for nm in num [ n : ] ] idx = 0 first . sort ( ) second . sort ( )   while idx < n and first [ idx ] < second [ idx ] : idx += 1 if idx == n : print ( ' YES ' ) return idx = 0 while idx < n and first [ idx ] > second [ idx ] : idx += 1 if idx == n : print ( ' YES ' ) return print ( ' NO ' ) return     solution ( ) NEW_LINE
import math     def calc ( n , i ) : num1 , num2 = 1 , 1   for j in range ( i ) : num1 *= n - j num2 *= j + 1 return num1 / num2     str1 = input ( ) str2 = input ( )   value1 , value2 , cnt = 0 , 0 , 0 prob = { }   for char in str1 : if char == " + " : value1 += 1 elif char == " - " : value1 -= 1   for char in str2 : if char == " + " : value2 += 1 elif char == " - " : value2 -= 1 elif char == " ? " : cnt += 1   value = value1 - value2   for i in range ( len ( str1 ) // 2 + 1 ) : prob [ ( cnt - i ) * - 1 + i ] = calc ( cnt , i ) prob [ ( ( cnt - i ) * - 1 + i ) * - 1 ] = calc ( cnt , i )   if cnt == 0 and value == 0 : print ( 1.0 ) elif cnt == 0 and value != 0 : print ( 0.0 ) else : if value in prob : print ( prob [ value ] / math . pow ( 2 , cnt ) ) else : print ( 0.0 ) NEW_LINE
cases = int ( input ( ) ) NEW_LINE while cases : cases -= 1 NEW_LINE a , b = map ( int , input ( ) . split ( ) ) NEW_LINE arr = list ( map ( int , input ( ) . split ( ) ) ) NEW_LINE ln = a * b NEW_LINE cut = ( a - 1 ) // 2 * b NEW_LINE a -= ( a - 1 ) // 2 NEW_LINE arr = arr [ cut : ]   ans = 0 NEW_LINE for i in range ( 0 , ln - cut , a ) : ans += arr [ i ] NEW_LINE
n = int ( input ( ) ) print ( ' First ' if any ( int ( i ) % 2 != 0 for i in input ( ) . split ( ) ) else ' Second ' )     ''' c = 0flag = 0for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ if ▁ a [ i ] %2 ! = 0 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ flag = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ breakif ▁ flag = = 1 : ▁ ▁ ▁ ▁ print ( ' First ' ) else : ▁ ▁ ▁ ▁ print ( ' Second ' ) ▁ ''' NEW_LINE
print ( " composite " if sum ( input ( ) == ' yes ' for i in [ 2 , 3 , 4 , 5 , 7 , 9 , 11 , 13 , 17 , 19 , 23 , 25 , 29 , 31 , 37 , 41 , 43 , 47 , 49 ] if not print ( i ) ) > 1 else " prime " ) NEW_LINE
n = int ( input ( ) ) minX = 10 ** 10 maxX = - ( 10 ** 10 ) minY = 10 ** 10 maxY = - ( 10 ** 10 ) for i in range ( n ) : mine = list ( map ( int , input ( ) . split ( ) ) ) minX = min ( mine [ 0 ] , minX ) maxX = max ( mine [ 0 ] , maxX ) minY = min ( mine [ 1 ] , minY ) maxY = max ( mine [ 1 ] , maxY ) print ( max ( maxX - minX , maxY - minY ) ** 2 ) NEW_LINE
t = int ( input ( ) ) for _ in range ( t ) : l = list ( map ( int , input ( ) . split ( ) ) ) l . sort ( ) if l [ 1 ] == l [ 2 ] : print ( " Yes " ) print ( l [ 0 ] , l [ 0 ] , l [ 1 ] ) else : print ( " No " ) NEW_LINE
import syss = [ item . strip ( ) for item in sys . stdin ]   l = 0 for item in s : l = max ( l , len ( item ) ) arr = [ ] one = 0 two = 1 arr . append ( [ ' * ' for _ in range ( l + 2 ) ] ) for item in s : temp = [ ' * ' ] z = len ( item ) temp += [ ' ▁ ' for _ in range ( ( l - z + one ) // 2 ) ] temp += [ c for c in item ] temp += [ ' ▁ ' for _ in range ( ( l - z + two ) // 2 ) ] temp . append ( ' * ' ) if ( l - z ) % 2 == 1 : one = 1 - one two = 1 - two arr . append ( temp ) arr . append ( [ ' * ' for _ in range ( l + 2 ) ] ) for item in arr : print ( ' ' . join ( item ) ) NEW_LINE
import sysn , m , * inp = map ( int , sys . stdin . read ( ) . split ( ) )   inp . reverse ( ) f = [ [ 0 for x in range ( 201 ) ] for y in range ( 201 ) ] NEW_LINE
from sys import stdin , stdout   n , m = [ int ( x ) for x in stdin . readline ( ) . split ( ) ]   if n == 2 : c = 1 way = [ ] mult = 1 for x in range ( m - 1 , - 1 , - 1 ) : way . append ( c ) c += x * mult mult *= - 1 for x in way : print ( 1 , x ) for x in way [ : : - 1 ] : print ( 2 , x ) elif n == 1 : c = 1 way = [ ] mult = 1 for x in range ( m - 1 , - 1 , - 1 ) : way . append ( c ) c += x * mult mult *= - 1 for x in way : print ( 1 , x )   elif m == 2 : c = 1 way = [ ] mult = 1 for x in range ( n - 1 , - 1 , - 1 ) : way . append ( c ) c += x * mult mult *= - 1 for x in way : print ( x , 1 ) for x in way [ : - 1 : - 1 ] : print ( x , 2 )   elif m == 1 : c = 1 way = [ ] mult = 1 for x in range ( n - 1 , - 1 , - 1 ) : way . append ( c ) c += x * mult mult *= - 1 for x in way : print ( x , 1 ) else : outStr = ' ' for x in range ( n // 2 ) : for y in range ( 1 , m + 1 ) : stdout . write ( str ( x + 1 ) + ' ▁ ' + str ( y ) + ' \n ' ) stdout . write ( str ( n - x ) + ' ▁ ' + str ( m + 1 - y ) + ' \n ' ) if n % 2 == 1 : c = 1 way = [ ] mult = 1 for x in range ( m - 1 , - 1 , - 1 ) : way . append ( c ) c += x * mult mult *= - 1 for x in way : stdout . write ( str ( n // 2 + 1 ) + ' ▁ ' + str ( x ) + ' \n ' )         NEW_LINE
n = int ( input ( ) ) A = list ( map ( int , input ( ) . split ( ) ) ) A = [ a - 1 for a in A ] C = [ [ ] for i in range ( n ) ] for i , a in enumerate ( A ) : C [ a ] . append ( i ) from collections import defaultdictINF = 10 ** 18 dp = defaultdict ( lambda : INF ) dp [ ( 0 , 0 ) ] = 0 for i in range ( n ) : nx = defaultdict ( lambda : INF ) for ( s , d ) , v in dp . items ( ) : ns = C [ i ] [ 0 ] nd = C [ i ] [ 1 ] nv = v + abs ( ns - s ) + abs ( nd - d ) nx [ ( ns , nd ) ] = min ( nx [ ( ns , nd ) ] , nv ) ns = C [ i ] [ 1 ] nd = C [ i ] [ 0 ] nv = v + abs ( ns - s ) + abs ( nd - d ) nx [ ( ns , nd ) ] = min ( nx [ ( ns , nd ) ] , nv ) dp = nxprint ( min ( dp . values ( ) ) ) NEW_LINE
def solve ( arr , n ) : res = [ ] for i in range ( n - 2 ) : temp = arr [ : ] temp . pop ( i + 1 ) max_val = 0 for j in range ( n - 2 ) : if temp [ j + 1 ] - temp [ j ] > max_val : max_val = temp [ j + 1 ] - temp [ j ] res . append ( max_val )   return min ( res )                           def main ( ) : n = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ' ▁ ' ) ) ) NEW_LINE
num = int ( input ( ) ) arr = list ( map ( int , input ( ) . split ( ) ) ) + [ 10000 ]   sub_arr = [ ] mx = 0 ans_arr = [ ] for i in range ( num ) : if arr [ i + 1 ] - arr [ i ] == 1 : sub_arr . append ( arr [ i ] ) else : if sub_arr : sub_arr . append ( arr [ i ] ) if len ( sub_arr ) > mx : mx = len ( sub_arr ) ans_arr = sub_arr [ : ] if len ( sub_arr ) == mx > 1 and ( sub_arr [ 0 ] == 1 or sub_arr [ - 1 ] == 1000 ) : ans_arr = sub_arr [ : ] sub_arr = [ ] if not ans_arr : print ( 0 ) elif ans_arr [ 0 ] == 1 or ans_arr [ - 1 ] == 1000 : print ( max ( 0 , mx - 1 ) ) else : print ( max ( 0 , mx - 2 ) ) NEW_LINE
s = input ( )   ok = { " a " , " o " , " u " , " i " , " e " } nn = { " n " }   if s [ - 1 ] not in ok . union ( nn ) : print ( " NO " ) else : for i in range ( len ( s ) - 1 ) : if s [ i ] not in ok . union ( nn ) and s [ i + 1 ] not in ok : print ( " NO " ) exit ( ) print ( " YES " )       NEW_LINE
import itertoolsimport math N , x , y = [ int ( n ) for n in input ( ) . split ( ) ] pills = [ ] for i in range ( N ) : pills . append ( tuple ( int ( n ) for n in input ( ) . split ( ) ) + ( i + 1 , ) ) pills . sort ( ) rques = xqauto = 0 time = 0 used = [ ] possible = set ( ) while rques > 0 : while len ( pills ) > 0 and pills [ - 1 ] [ 0 ] >= 100 * rques / x : possible . add ( pills . pop ( ) [ 1 : ] ) if len ( possible ) > 0 : best = max ( possible ) used . append ( ( best , time ) ) possible . remove ( best ) qauto += best [ 0 ] elif qauto <= y : print ( ' NO ' ) break rques = min ( rques + y - qauto , x ) time += 1 else : print ( ' YES ' ) print ( time , len ( used ) ) for scroll in used : print ( scroll [ 1 ] , scroll [ 0 ] [ 1 ] ) NEW_LINE
n , d = map ( int , input ( ) . split ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) sets = 0 a . sort ( ) for i in range ( 0 , n - 1 ) : A = a [ i ] for j in range ( i + 1 , n ) : B = a [ j ] diff = B - A if diff <= d : sets += 1 else : breakprint ( 2 * sets ) NEW_LINE
n , b , p = map ( int , input ( ) . split ( ) ) ans = 0 x = nwhile ( n > 1 ) : ans = ( ( n // 2 ) * 2 * b ) + ( n // 2 ) + ans n = ( n // 2 ) + ( n - ( ( n // 2 ) * 2 ) ) print ( ans , x * p ) NEW_LINE
def solve ( ) : s = input ( ) digit_sum = 0 even_cnt = 0 zero_cnt = 0 for x in s : if int ( x ) == 0 : zero_cnt += 1 elif int ( x ) % 2 == 0 : even_cnt += 1 digit_sum += int ( x ) if digit_sum % 3 == 0 and ( zero_cnt >= 2 or even_cnt >= 1 and zero_cnt >= 1 ) : print ( ' red ' ) else : print ( ' cyan ' )   t = int ( input ( ) ) for _ in range ( t ) : solve ( ) NEW_LINE
n = int ( input ( ) ) a = 0 m = 0 i = n - 1 s = str ( input ( ) ) while ( i >= 0 ) : if s [ i ] == ' + ' : m += 1 else : m -= 1 a = max ( a , m ) i -= 1 print ( a )           NEW_LINE
s = input ( )   ln = cap = low = digit = False     for char in s : if len ( s ) > 4 : ln = True if char . isupper ( ) : cap = True if char . islower ( ) : low = True if char . isdigit ( ) : digit = True   if ln == cap == low == digit != False : print ( " Correct " ) else : print ( " Too ▁ weak " )   NEW_LINE
from sys import stdin , stdoutfrom os import pathrd = lambda : stdin . readline ( ) . strip ( ) wr = stdout . writeif ( path . exists ( ' input . txt ' ) ) : stdin = open ( " input . txt " , " r " ) import time , math NEW_LINE
from math import ceiln , m , k , p = map ( int , input ( ) . split ( ) )   if n - k < p : print ( - 1 ) else : an = ceil ( ( p + k + m - 1 ) // m ) if an * m > n : print ( - 1 ) else : print ( an ) NEW_LINE
ans1 = 0 ans2 = 0 l1 = [ ] l2 = [ ] for _ in range ( int ( input ( ) ) ) : n = int ( input ( ) ) if ( n > 0 ) : ans1 += n l1 . append ( n ) else : ans2 += abs ( n ) l2 . append ( - n ) if ( ans1 > ans2 or ( ans1 == ans2 and l1 > l2 ) or ( l1 == l2 and n > 0 ) ) : print ( " first " ) else : print ( " second " ) NEW_LINE
a , b = map ( int , input ( ) . split ( ) ) cur , dead = a , 0 h = awhile cur > 0 : dead += cur cur = dead // b dead = dead % b h += cur   print ( h ) NEW_LINE
import sysfrom string import ascii_lowercase   def main ( ) : _ , * l = map ( int , sys . stdin . read ( ) . strip ( ) . split ( ) ) out = [ ] for i , j in zip ( l [ : : 2 ] , l [ 1 : : 2 ] ) : r = ascii_lowercase [ : j ] out . append ( i // j * r + r [ : i % j ] ) return out print ( * main ( ) , sep = ' \n ' ) NEW_LINE
import math def dist ( p1 , p2 ) : return math . sqrt ( ( p1 [ 0 ] - p2 [ 0 ] ) ** 2 + ( p1 [ 1 ] - p2 [ 1 ] ) ** 2 ) def cross ( p1 , p2 ) : return p1 [ 0 ] * p2 [ 1 ] - p1 [ 1 ] * p2 [ 0 ] def parse_point ( line ) : tokens = line . split ( ) return int ( tokens [ 0 ] ) , int ( tokens [ 1 ] ) n = int ( input ( ) ) pt = [ parse_point ( input ( ) ) for _ in range ( n ) ] res = 1e100 pr1 , pr2 = None , Nonefor i in range ( len ( pt ) ) : pr1 = pt [ i - 2 ] pr2 = pt [ i - 1 ] cur = pt [ i ] p1 = ( pr1 [ 0 ] - pr2 [ 0 ] , pr1 [ 1 ] - pr2 [ 1 ] ) p2 = ( cur [ 0 ] - pr2 [ 0 ] , cur [ 1 ] - pr2 [ 1 ] ) c = dist ( pr1 , cur )   if abs ( cross ( p1 , p2 ) / 2 ) / c < res : res = abs ( cross ( p1 , p2 ) / 2 ) / c print ( res ) NEW_LINE
a , b = map ( int , input ( ) . strip ( ) . split ( ) ) c = input ( ) . strip ( ) . split ( ) d = input ( ) . strip ( ) . split ( ) e = int ( input ( ) . strip ( ) ) for i in range ( e ) : f = int ( input ( ) . strip ( ) ) print ( c [ ( ( f - 1 ) ) % a ] + d [ ( f - 1 ) % b ] ) NEW_LINE
months = [ ' January ' , ' February ' , ' March ' , ' April ' , ' May ' , ' June ' , ' July ' , ' August ' , ' September ' , ' October ' , ' November ' , ' December ' ] month , skip = input ( ) , int ( input ( ) ) years = int ( skip / 12 )   remaining = skip - years * 12 if remaining + months . index ( month ) <= 11 : print ( months [ remaining + months . index ( month ) ] ) else : print ( months [ remaining + months . index ( month ) - 12 ] ) NEW_LINE
import os , sys , bisectfrom collections import defaultdict , Counter , deque ; from functools import lru_cache NEW_LINE
def main ( a , b , l , r ) :             qL = ( l - 1 ) // ( 2 * a + 2 * b )   rL = ( l - 1 ) % ( 2 * a + 2 * b ) + 1             qR = ( r - 1 ) // ( 2 * a + 2 * b )   rR = ( r - 1 ) % ( 2 * a + 2 * b ) + 1   NEW_LINE
def solve ( ) : n , k = map ( int , input ( ) . split ( ) )   arr = [ int ( i ) for i in input ( ) . split ( ) ]   price = 1   while k >= price and price < len ( arr ) : if arr [ price ] == 0 : price += 1 continue   arr [ price ] -= 1 k -= price arr [ 0 ] += 1   print ( arr [ 0 ] )   t = int ( input ( ) )   while t : solve ( ) t -= 1 NEW_LINE
def find ( A , target ) : for i in range ( len ( A ) ) : for j in range ( len ( A [ i ] ) ) : if A [ i ] [ j ] == target : return [ i + 1 , j + 1 ] n = int ( input ( ) ) C = list ( map ( int , input ( ) . split ( ) ) ) X = [ ] for i in range ( n ) : Y = list ( map ( int , input ( ) . split ( ) ) ) X . append ( Y ) cnt = 1     tot = 0 ans = [ ] for i in range ( len ( X ) ) : for j in range ( len ( X [ i ] ) ) : t = find ( X , cnt ) X [ t [ 0 ] - 1 ] [ t [ 1 ] - 1 ] , X [ i ] [ j ] = X [ i ] [ j ] , X [ t [ 0 ] - 1 ] [ t [ 1 ] - 1 ] if t [ 0 ] != i + 1 or t [ 1 ] != j + 1 : ans . append ( str ( i + 1 ) + " ▁ " + str ( j + 1 ) + " ▁ " + str ( t [ 0 ] ) + " ▁ " + str ( t [ 1 ] ) ) tot += 1 cnt += 1 print ( tot ) for i in ans : print ( i ) NEW_LINE
a = int ( input ( ) ) for i in range ( a ) : b , c , d , e = map ( int , input ( ) . split ( ) ) f = min ( b - 1 , abs ( e - d ) + c ) print ( f ) NEW_LINE
a1 = int ( input ( ) ) a2 = int ( input ( ) ) k1 = int ( input ( ) ) k2 = int ( input ( ) ) n = int ( input ( ) ) def minc ( a1 , a2 , k1 , k2 , n ) : res = 0 if k1 > k2 : n = n - ( ( k1 - 1 ) * a1 ) if n <= 0 : return res else : n = n - ( ( k2 - 1 ) * a2 ) if n <= 0 : return res else : res = abs ( ( a1 + a2 ) - abs ( ( a1 + a2 ) - n ) ) return res else : n = n - ( ( k2 - 1 ) * a2 ) if n <= 0 : return res else : n = n - ( ( k1 - 1 ) * a1 ) if n <= 0 : return res else : res = abs ( ( a1 + a2 ) - abs ( ( a1 + a2 ) - n ) ) return res   def maxc ( a1 , a2 , k1 , k2 , n ) : res = 0 if k1 > k2 : k1 , k2 = k2 , k1 a1 , a2 = a2 , a1 if n <= a1 * k1 : res = n // k1 else : res = a1 + ( n - a1 * k1 ) // k2 return res   print ( minc ( a1 , a2 , k1 , k2 , n ) , end = ' ▁ ' ) print ( maxc ( a1 , a2 , k1 , k2 , n ) ) NEW_LINE
import sysinput = sys . stdin . readline   n = int ( input ( ) ) p = list ( map ( int , input ( ) . split ( ) ) ) flag = [ 1 ] * nr = n - 1 cnt = 0   print ( 1 , end = ' ▁ ' )   for i in range ( n - 1 ) : flag [ p [ i ] - 1 ] = 0 while flag [ r ] == 0 : r -= 1 cnt += 1 print ( i + 2 - cnt , end = ' ▁ ' )   print ( 1 ) NEW_LINE
n , p1 , p2 , p3 , t1 , t2 = map ( int , input ( ) . split ( ) ) l , r = map ( int , input ( ) . split ( ) ) power = ( r - l ) * p1last_time = rfor _ in range ( n - 1 ) : l , r = map ( int , input ( ) . split ( ) ) if l - last_time <= t1 : power += ( l - last_time ) * p1 elif l - last_time <= t1 + t2 : power += t1 * p1 + ( l - last_time - t1 ) * p2 else : power += t1 * p1 + t2 * p2 + ( l - last_time - t1 - t2 ) * p3 power += ( r - l ) * p1 last_time = rprint ( power ) NEW_LINE
class CodeforcesTask397BSolution : def __init__ ( self ) : self . result = ' ' self . t = 0 self . queries = [ ]   def read_input ( self ) : self . t = int ( input ( ) ) for _ in range ( self . t ) : self . queries . append ( [ int ( x ) for x in input ( ) . split ( " ▁ " ) ] )   def process_task ( self ) : res = [ ] for query in self . queries : k = query [ 0 ] // query [ 1 ] res . append ( " Yes " if k * query [ 2 ] >= query [ 0 ] else " No " ) self . result = " \n " . join ( res )   def get_result ( self ) : return self . result     if __name__ == " _ _ main _ _ " : Solution = CodeforcesTask397BSolution ( ) Solution . read_input ( ) Solution . process_task ( ) print ( Solution . get_result ( ) ) NEW_LINE
n , p , t = map ( int , input ( ) . split ( ) ) arr = sorted ( map ( int , input ( ) . split ( ) ) ) arr = [ 0 ] + arr [ : : - 1 ] for i in range ( 1 , n + 1 ) : arr [ i ] += arr [ i - 1 ] maxi = 0 count = 0 for i in range ( n , 0 , - 1 ) : if ( t == - 1 ) : break maxi = max ( maxi , ( arr [ i ] + max ( 0 , min ( i * p , t ) ) ) / i ) t -= 1 print ( maxi ) NEW_LINE
from collections import Countert = int ( input ( ) ) NEW_LINE for _ in range ( t ) : a , b , c = map ( int , input ( ) . split ( ) ) NEW_LINE q = a + b + c NEW_LINE e = min ( a , b , c ) NEW_LINE w = q // 9 NEW_LINE if ( q % 9 == 0 and e >= w ) : NEW_LINE INDENT print ( " YES " ) else : NEW_LINE print ( " NO " ) NEW_LINE DEDENT
n = input ( ) arr = [ int ( i ) for i in input ( ) . split ( ) ]   print ( max ( arr ) ) NEW_LINE
inp = lambda : map ( int , input ( ) . split ( ) ) n , m , k = inp ( )   data = [ ( 0 , 0 , i ) for i in range ( n + m ) ]   for i in range ( k ) : query , id , color = inp ( ) if query == 1 : data [ id - 1 ] = ( i , color , id - 1 ) else : data [ id - 1 + n ] = ( i , color , id - 1 + n )   data . sort ( ) field = [ [ 0 ] * m for _ in range ( n ) ]     for _ , color , id in data : if color != 0 : if id < n : for i in range ( m ) : field [ id ] [ i ] = color else : for i in range ( n ) : field [ i ] [ id - n ] = color   for i in range ( n ) : print ( * field [ i ] ) NEW_LINE
from math import ceilt = int ( input ( ) ) NEW_LINE for x in range ( t ) : a , b = map ( int , input ( ) . split ( ) ) NEW_LINE if a == 1 or a == 2 : print ( 1 ) NEW_LINE continue NEW_LINE a -= 2 NEW_LINE print ( ceil ( a / b ) + 1 ) NEW_LINE
from sys import stdin , stdoutimport math , bisectfrom collections import Counter , deque , defaultdictL = lambda : list ( map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) ) M = lambda : map ( int , stdin . readline ( ) . strip ( ) . split ( ) ) I = lambda : int ( stdin . readline ( ) . strip ( ) ) S = lambda : stdin . readline ( ) . strip ( ) C = lambda : stdin . readline ( ) . strip ( ) . split ( ) def pr ( a ) : return ( " ▁ " . join ( list ( map ( str , a ) ) ) ) NEW_LINE
n , x1 , y1 , x2 , y2 = map ( int , input ( ) . split ( ) ) NEW_LINE d = { }   if x1 == 0 : d [ ( x1 , y1 ) ] = 1 NEW_LINE if x1 == n : d [ ( x1 , y1 ) ] = - 1 NEW_LINE if x2 == 0 : d [ ( x2 , y2 ) ] = 1 NEW_LINE if x2 == n : d [ ( x2 , y2 ) ] = - 1 NEW_LINE if y1 == 0 : d [ ( x1 , y1 ) ] = 2 NEW_LINE if y1 == n : d [ ( x1 , y1 ) ] = - 2 NEW_LINE if y2 == 0 : d [ ( x2 , y2 ) ] = 2 NEW_LINE if y2 == n : d [ ( x2 , y2 ) ] = - 2   if abs ( abs ( d [ ( x1 , y1 ) ] ) - abs ( d [ ( x2 , y2 ) ] ) ) == 1 : NEW_LINE INDENT print ( min ( 4 * n - ( abs ( x1 - x2 ) + abs ( y1 - y2 ) ) , ( abs ( x1 - x2 ) + abs ( y1 - y2 ) ) ) ) elif ( x1 == 0 and x2 == n ) or ( x1 == n and x2 == 0 ) : NEW_LINE print ( min ( 4 * n - ( y1 + y2 + n ) , y1 + y2 + n ) ) elif ( y1 == 0 and y2 == n ) or ( y1 == n and y2 == 0 ) : NEW_LINE print ( min ( 4 * n - ( x1 + x2 + n ) , x1 + x2 + n ) ) elif ( x1 == 0 and x2 == 0 ) or ( x1 == n and x2 == n ) : NEW_LINE print ( abs ( y2 - y1 ) ) elif ( y1 == 0 and y2 == 0 ) or ( y1 == n and y2 == n ) : NEW_LINE print ( abs ( x2 - x1 ) ) NEW_LINE DEDENT
n = input ( ) s = str ( input ( ) ) a = set ( ) res = 0 for i in s : if i . islower ( ) : a . add ( i ) res = max ( res , len ( a ) ) else : a . clear ( ) print ( res ) NEW_LINE
x = abs ( int ( input ( ) ) ) k , s , i = 0 , 0 , 1 while s < x or ( s - x ) % 2 == 1 : s += i i += 1 print ( i - 1 ) NEW_LINE
def string_to_list ( s , char ) : collector = " " output_list = [ ] for i in range ( len ( s ) ) : if s [ i ] != char : collector += s [ i ] if i == len ( s ) - 1 : output_list . append ( int ( collector ) ) else : output_list . append ( int ( collector ) ) collector = " " return output_list     NEW_LINE
from collections import Counter   def solve ( ) : str1 = input ( ) str2 = input ( ) count , j = 1 , 0   for i in range ( len ( str2 ) ) : if str1 [ j ] == str2 [ i ] : count += 1 j += 1   return count         print ( solve ( ) ) NEW_LINE
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) ans = 0 x = nfor i in range ( n - 1 , - 1 , - 1 ) : if ( i < x ) : ans += 1 x = min ( x , i - l [ i ] ) print ( ans ) NEW_LINE
s , k = map ( int , input ( ) . split ( ) ) f = [ 0 ] f . append ( 1 ) while ( True ) : cur = sum ( f [ - k : ] ) if cur > s : break f . append ( cur ) f = list ( set ( f ) ) f . sort ( ) ans = [ ] i = len ( f ) - 1 while ( s and i > 0 ) : if f [ i ] <= s : s -= f [ i ] ans . append ( f [ i ] ) i -= 1 print ( len ( ans ) + 1 ) print ( * ( ans + [ 0 ] ) ) NEW_LINE
def solve ( s ) : d = { ' B ' : 0 , ' u ' : 0 , ' l ' : 0 , ' b ' : 0 , ' a ' : 0 , ' u ' : 0 , ' r ' : 0 , ' s ' : 0 } for c in s : if c in ' Bulbbasaur ' : d [ c ] += 1 min_val = 1000000000 l = [ ' a ' , ' u ' ] for i in d : if not d [ i ] : return 0 if d [ ' a ' ] < 2 or d [ ' u ' ] < 2 : return 0 if i in l and d [ i ] // 2 < min_val : min_val = d [ i ] // 2 if d [ i ] < min_val : min_val = d [ i ] return min_val                   def main ( ) : NEW_LINE
s = open ( ' input . txt ' ) . readlines ( ) [ 1 ] ; n = len ( s ) // 2 for i in range ( n ) : print ( * [ i + 1 + n , i + 1 ] [ : : 2 * ( s [ i ] > ' L ' ) - 1 ] , file = open ( ' output . txt ' , ' a ' ) ) NEW_LINE
start , end , k = input ( ) , input ( ) , int ( input ( ) ) n , mod = len ( end ) , 10 ** 9 + 7 dp = [ 1 , 0 ] psum = 1 for i in range ( k ) : dp [ 0 ] = psum - dp [ 0 ] dp [ 1 ] = psum - dp [ 1 ] psum = ( dp [ 0 ] + ( ( n - 1 ) * dp [ 1 ] ) % mod ) % modans = 0 for i in range ( n ) : if start [ i : ] + start [ : i ] == end : if i == 0 : ans += dp [ 0 ] else : ans += dp [ 1 ] print ( ans % mod ) NEW_LINE
n = int ( input ( ) ) p = input ( ) list = p . split ( " ▁ " ) for i in range ( 0 , n ) : list [ i ] = int ( list [ i ] ) l = 0 h = 0 max = list [ 0 ] min = list [ 0 ] for i in range ( 1 , n ) : if list [ i ] > max : max = list [ i ] h = h + 1 if list [ i ] < min : min = list [ i ] l = l + 1 print ( l + h ) NEW_LINE
n = int ( input ( ) ) a = list ( map ( int , input ( ) . split ( ) ) ) mxi = a . index ( max ( a ) ) a . reverse ( ) mni = n - 1 - a . index ( min ( a ) ) res = mxi + n - 1 - mniif mxi > mni : res -= 1 print ( res ) NEW_LINE
n = int ( input ( ) ) + 1 d = 1000000007 g = [ [ 1 ] * n for i in range ( n ) ] for i in range ( 1 , n ) : g [ i ] [ 0 ] = g [ i - 1 ] [ i - 1 ] for j in range ( 1 , i + 1 ) : g [ i ] [ j ] = ( g [ i ] [ j - 1 ] + g [ i - 1 ] [ j - 1 ] ) % dprint ( ( g [ - 1 ] [ - 1 ] - g [ - 1 ] [ 0 ] ) % d ) NEW_LINE
""" def ▁ main ( ) : ▁ ▁ ▁ ▁ t ▁ = ▁ int ( input ( ) ) ▁ ▁ ▁ ▁ for ▁ _ ▁ in ▁ range ( t ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ n , m ▁ = ▁ sep ( ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a = list ( sep ( ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ b = list ( sep ( ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ans = 0 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a ▁ = ▁ sorted ( a , reverse = True ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ a [ i ] > = i + 1 : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ans + = b [ i ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ans + = b [ a [ i ] -1 ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ans ) if ▁ _ _ name _ _ ▁ = = ▁ ' _ _ main _ _ ' : ▁ ▁ ▁ ▁ main ( ) """   """ def ▁ main ( ) : ▁ ▁ ▁ ▁ n = int ( input ( ) ) ▁ ▁ ▁ ▁ x ▁ = ▁ int ( input ( ) ) ▁ ▁ ▁ ▁ p = 7 - x ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ c ▁ = ▁ list ( sep ( ) ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ x ▁ in ▁ c ▁ or ▁ p ▁ in ▁ c : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( " NO " ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( " YES " ) if ▁ _ _ name _ _ ▁ = = ▁ ' _ _ main _ _ ' : ▁ ▁ ▁ ▁ main ( ) """ """ def ▁ main ( ) : ▁ ▁ ▁ ▁ s , k ▁ = ▁ sep ( ) ▁ ▁ ▁ ▁ a = [ 0,1 ] ▁ ▁ ▁ ▁ ans = [ ] ▁ ▁ ▁ ▁ # print ( ans ) ▁ ▁ ▁ ▁ while ( a [ -1 ] < s ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ a . append ( sum ( a [ - k : ] ) ) ▁ ▁ ▁ ▁ a . reverse ( ) ▁ ▁ ▁ ▁ # print ( list ( a ) ) ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ a : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ i < = s : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ans . append ( i ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ s - = i ▁ ▁ ▁ ▁ print ( len ( ans ) ) ▁ ▁ ▁ ▁ print ( * ans ) if ▁ _ _ name _ _ ▁ = = ▁ ' _ _ main _ _ ' : ▁ ▁ ▁ ▁ main ( ) """   def sep ( ) : return map ( int , input ( ) . split ( ) ) """ def ▁ main ( ) : ▁ ▁ ▁ ▁ n ▁ = ▁ int ( input ( ) ) ▁ ▁ ▁ ▁ a ▁ = ▁ list ( sep ( ) ) ▁ ▁ ▁ ▁ d ▁ = ▁ { } ▁ ▁ ▁ ▁ f ▁ = ▁ True ▁ ▁ ▁ ▁ for ▁ i ▁ in ▁ range ( n ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ ( f ▁ = = ▁ False ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ for ▁ j ▁ in ▁ range ( i ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ # ▁ print ( d )   ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ ( a [ i ] ▁ + ▁ a [ j ] ▁ in ▁ d ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ii , ▁ jj ▁ = ▁ d [ a [ i ] ▁ + ▁ a [ j ] ] ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ if ▁ ( len ( set ( [ i , ▁ j , ▁ ii , ▁ jj ] ) ) ▁ = = ▁ 4 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' YES ' ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ f ▁ = ▁ False ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( i ▁ + ▁ 1 , ▁ j ▁ + ▁ 1 , ▁ ii ▁ + ▁ 1 , ▁ jj ▁ + ▁ 1 ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ break ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ else : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ d [ a [ i ] ▁ + ▁ a [ j ] ] ▁ = ▁ ( i , ▁ j )   ▁ ▁ ▁ ▁ if ▁ ( f ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( ' NO ' ) if ▁ _ _ name _ _ ▁ = = ▁ ' _ _ main _ _ ' : ▁ ▁ ▁ ▁ main ( ) """ """ def ▁ main ( ) : ▁ ▁ ▁ ▁ s = input ( ) ▁ ▁ ▁ ▁ d = { } ▁ ▁ ▁ ▁ i = - 1 ▁ ▁ ▁ ▁ for ▁ _ ▁ in ▁ range ( 10 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ i + = 1 ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ t ▁ = ▁ input ( ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ d [ t ] = i ▁ ▁ ▁ ▁ # print ( d ) ▁ ▁ ▁ ▁ j = 0 ▁ ▁ ▁ ▁ while ( j < 80 ) : ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ print ( d [ s [ j : 10 + j ] ] , end = " " ) ▁ ▁ ▁ ▁ ▁ ▁ ▁ ▁ j + = 10if ▁ _ _ name _ _ ▁ = = ▁ ' _ _ main _ _ ' : ▁ ▁ ▁ ▁ main ( ) """ import mathdef prime ( x ) : if x == 1 : return False else : for i in range ( 2 , int ( math . sqrt ( x ) ) + 1 ) : if ( x % i == 0 ) : return False else : return Truedef main ( ) : n , a , b = sep ( ) n = 6 * n flag = 0 if a > b : flag = 1 a , b = min ( a , b ) , max ( a , b ) ans = ( a , b ) tans = 1e12 if a * b < n : for l in range ( a , int ( n ** 0.5 ) + 2 ) : tmp = l * math . ceil ( n / l ) if tans > tmp and math . ceil ( n / l ) >= b : tans = tmp ans = ( l , math . ceil ( n / l ) ) else : pass print ( ans [ 0 ] * ans [ 1 ] ) if flag == 1 : print ( ans [ 1 ] , ans [ 0 ] ) else : print ( ans [ 0 ] , ans [ 1 ] ) if __name__ == ' _ _ main _ _ ' : main ( ) NEW_LINE
import sysfrom math import sqrt , gcd , ceil , log NEW_LINE
if __name__ == ' _ _ main _ _ ' : s = input ( ) d = [ 2 , 7 , 2 , 3 , 3 , 4 , 2 , 5 , 1 , 2 ] print ( d [ int ( s [ 0 ] ) ] * d [ int ( s [ 1 ] ) ] ) NEW_LINE
from sys import stdin , stdoutfrom collections import Counternmbr = lambda : int ( input ( ) ) lst = lambda : list ( map ( int , input ( ) . split ( ) ) ) for _ in range ( 1 ) : NEW_LINE
n = int ( input ( ) ) l = list ( map ( int , input ( ) . split ( ) ) ) if 5 not in l and 7 not in l : try : if 2 in l and 4 not in l and 6 not in l : raise Exception if l . count ( 1 ) != n // 3 or l . count ( 4 ) > l . count ( 2 ) : raise Exception if l . count ( 3 ) > l . count ( 6 ) or l . count ( 2 ) + l . count ( 3 ) != l . count ( 4 ) + l . count ( 6 ) : raise Exception except Exception as e : print ( - 1 ) else : if l . count ( 3 ) != 0 : for j in range ( l . count ( 3 ) ) : print ( 1 , 3 , 6 ) for j in range ( l . count ( 6 ) - l . count ( 3 ) ) : print ( 1 , 2 , 6 ) for j in range ( l . count ( 2 ) - l . count ( 6 ) + l . count ( 3 ) ) : print ( 1 , 2 , 4 ) else : for j in range ( l . count ( 6 ) ) : print ( 1 , 2 , 6 ) for j in range ( l . count ( 2 ) - l . count ( 6 ) ) : print ( 1 , 2 , 4 ) else : print ( - 1 ) NEW_LINE
from math import ceil , log2   for t in range ( int ( input ( ) ) ) : n = int ( input ( ) ) x = n for k in range ( 2 , ceil ( log2 ( n ) ) + 1 ) : if n % ( 2 ** k - 1 ) == 0 : x = n // ( 2 ** k - 1 ) break print ( x ) NEW_LINE
import sys   def ask ( x , y ) : print ( f " ? ▁ { x } ▁ { y } " ) sys . stdin . flush ( ) ans = input ( ) if ans == " e " : exit ( ) return ans == " y "     while True : s = input ( ) if s == " mistake " or s == " end " : exit ( ) lower = 0 while ask ( lower , max ( 2 * lower , 1 ) ) : lower = max ( 1 , 2 * lower ) lo = lower hi = max ( 1 , lower * 2 ) while lo + 1 < hi : mid = ( lo + hi ) // 2 if ask ( lower , mid ) : lo = mid else : hi = mid print ( f " ! ▁ { hi } " ) NEW_LINE
for s in [ * open ( 0 ) ] [ 2 : : 2 ] : NEW_LINE INDENT a = * map ( int , s . split ( ) ) , ; NEW_LINE i = 7 ** 6 NEW_LINE for x , j in sorted ( zip ( a , range ( i ) ) ) [ : : - 1 ] : print ( * a [ j : i ] ) ; i = min ( i , j ) NEW_LINE DEDENT
n , m = map ( int , input ( ) . split ( ) ) ; a = list ( map ( int , input ( ) . split ( ) ) ) ; p = 0 ; t = [ 0 ] * 3 for i in range ( n ) : if ( a [ i ] < a [ p ] ) : p = i if ( n == 2 ) : print ( '0 \n 1 ▁ 1 \n ' ) else : a . sort ( ) ; t [ 0 ] = min ( a [ 0 ] + a [ 1 ] + m , a [ 1 ] + a [ 2 ] ) ; t [ 1 ] = max ( a [ 0 ] + a [ n - 1 ] + m , a [ n - 2 ] + a [ n - 1 ] ) ; t [ 2 ] = ( a [ n - 2 ] + a [ n - 1 ] ) - ( a [ 0 ] + a [ 1 ] ) if ( t [ 1 ] - t [ 0 ] > t [ 2 ] ) : p = n else : t [ 2 ] = t [ 1 ] - t [ 0 ] print ( t [ 2 ] ) for i in range ( n ) : print ( int ( i == p ) + 1 , end = ' ▁ ' ) NEW_LINE
n = int ( input ( ) ) t , c = [ ] , [ ] for i in range ( n ) : tt , cc = list ( map ( int , input ( ) . split ( ) ) ) t . append ( tt ) c . append ( cc )   def find ( i : int , cnt : int ) -> int : if cnt >= n : return 0 if i == n : return int ( 1e18 ) return min ( find ( i + 1 , cnt ) , c [ i ] + find ( i + 1 , cnt + 1 + t [ i ] ) )   f = [ int ( 1e18 ) ] * ( n + 1 ) f [ 0 ] = 0 NEW_LINE
n = int ( input ( ) ) c = 0 ; while n > 0 : NEW_LINE
import math as mpdef parallelepiped ( areas ) : a = areas [ 0 ] / areas [ 1 ] b2 = mp . sqrt ( areas [ 2 ] / a ) a1 = areas [ 1 ] / b2 b1 = areas [ 0 ] / a1 edge_sum = ( 4 * a1 ) + ( 4 * b1 ) + ( 4 * b2 ) return ( int ( edge_sum ) )   areas = list ( map ( int , input ( ) . split ( ) ) ) result = parallelepiped ( areas ) print ( result ) NEW_LINE
a , b = input ( ) . split ( ' | ' ) c = input ( ) for i in range ( len ( c ) ) : if len ( a ) <= len ( b ) : a += c [ i ] elif len ( a ) > len ( b ) : b += c [ i ] if len ( a ) == len ( b ) : print ( a + ' | ' + b ) else : print ( ' Impossible ' ) NEW_LINE
def gcd ( a , b ) : NEW_LINE INDENT if a == 0 or b == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT if a == b : NEW_LINE INDENT return a NEW_LINE DEDENT if a > b : NEW_LINE INDENT return gcd ( a - b , b ) NEW_LINE DEDENT return gcd ( a , b - a ) NEW_LINE DEDENT def cpFact ( x , y ) : NEW_LINE INDENT while gcd ( x , y ) != 1 : NEW_LINE INDENT x = x / gcd ( x , y ) NEW_LINE DEDENT return int ( x ) NEW_LINE DEDENT x = 15 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 14 NEW_LINE y = 28 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE x = 7 NEW_LINE y = 3 NEW_LINE print ( cpFact ( x , y ) ) NEW_LINE
import math NEW_LINE def powerNumbers ( n ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 2 , int ( math . pow ( n , 1.0 / 3.0 ) ) + 1 ) : NEW_LINE INDENT j = i * i NEW_LINE while ( j * i <= n ) : NEW_LINE INDENT j = j * i NEW_LINE s = int ( math . sqrt ( j ) ) NEW_LINE if ( s * s != j ) : NEW_LINE INDENT v . append ( j ) NEW_LINE DEDENT DEDENT DEDENT v . sort ( ) NEW_LINE v = list ( dict . fromkeys ( v ) ) NEW_LINE return len ( v ) + int ( math . sqrt ( n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( powerNumbers ( 50 ) ) NEW_LINE DEDENT
def next_permutation ( L ) : NEW_LINE INDENT n = len ( L ) NEW_LINE i = n - 2 NEW_LINE while i >= 0 and L [ i ] >= L [ i + 1 ] : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if i == - 1 : NEW_LINE INDENT return False NEW_LINE DEDENT j = i + 1 NEW_LINE while j < n and L [ j ] > L [ i ] : NEW_LINE INDENT j += 1 NEW_LINE DEDENT j -= 1 NEW_LINE L [ i ] , L [ j ] = L [ j ] , L [ i ] NEW_LINE left = i + 1 NEW_LINE right = n - 1 NEW_LINE while left < right : NEW_LINE INDENT L [ left ] , L [ right ] = L [ right ] , L [ left ] NEW_LINE left += 1 NEW_LINE right -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def nPermute ( string , n ) : NEW_LINE INDENT string = list ( string ) NEW_LINE new_string = [ ] NEW_LINE string . sort ( ) NEW_LINE j = 2 NEW_LINE while next_permutation ( string ) : NEW_LINE INDENT new_string = string NEW_LINE if j == n : NEW_LINE INDENT break NEW_LINE DEDENT j += 1 NEW_LINE DEDENT print ( ' ' . join ( new_string ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GEEKSFORGEEKS " NEW_LINE n = 100 NEW_LINE nPermute ( string , n ) NEW_LINE DEDENT
sz = 1000 NEW_LINE fib = set ( ) NEW_LINE def fibonacci ( ) : NEW_LINE INDENT prev , curr , length = 0 , 1 , 2 NEW_LINE fib . add ( prev ) NEW_LINE fib . add ( curr ) NEW_LINE while ( length <= sz ) : NEW_LINE INDENT temp = curr + prev NEW_LINE fib . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE length += 1 NEW_LINE DEDENT DEDENT def printArray ( arr , length ) : NEW_LINE INDENT for i in range ( length ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT def removeFibonacci ( arr , length ) : NEW_LINE INDENT fibonacci ( ) NEW_LINE for i in fib : NEW_LINE INDENT if i in arr : NEW_LINE INDENT arr . remove ( i ) NEW_LINE length -= 1 NEW_LINE DEDENT DEDENT printArray ( arr , length ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 ] NEW_LINE length = len ( arr ) NEW_LINE removeFibonacci ( arr , length ) NEW_LINE DEDENT
def product ( mat , n ) : NEW_LINE INDENT d1 = 0 NEW_LINE d2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT d1 += mat [ i ] [ i ] NEW_LINE d2 += mat [ i ] [ n - i - 1 ] NEW_LINE DEDENT return d1 * d2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 5 , 8 , 1 ] , [ 5 , 10 , 3 ] , [ - 6 , 17 , - 9 ] ] NEW_LINE n = len ( mat ) NEW_LINE print ( product ( mat , n ) ) NEW_LINE DEDENT
from collections import deque ; NEW_LINE def remainingDigit ( S , N ) : NEW_LINE INDENT c = [ i for i in S ] NEW_LINE de = [ 0 , 0 ] NEW_LINE count = [ 0 , 0 ] NEW_LINE q = deque ( ) NEW_LINE for i in c : NEW_LINE INDENT x = 0 NEW_LINE if i == '1' : NEW_LINE INDENT x = 1 NEW_LINE DEDENT count [ x ] += 1 NEW_LINE q . append ( x ) NEW_LINE DEDENT while ( count [ 0 ] > 0 and count [ 1 ] > 0 ) : NEW_LINE INDENT t = q . popleft ( ) NEW_LINE if ( de [ t ] > 0 ) : NEW_LINE INDENT de [ t ] -= 1 NEW_LINE count [ t ] -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT de [ t ^ 1 ] += 1 NEW_LINE q . append ( t ) NEW_LINE DEDENT DEDENT if ( count [ 0 ] > 0 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT return "1" NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT S = "1010100100000" NEW_LINE N = len ( S ) NEW_LINE print ( remainingDigit ( S , N ) ) NEW_LINE DEDENT
import math NEW_LINE def incrementVector ( a ) : NEW_LINE INDENT n = len ( a ) NEW_LINE a [ n - 1 ] += 1 NEW_LINE carry = a [ n - 1 ] / 10 NEW_LINE a [ n - 1 ] = a [ n - 1 ] % 10 NEW_LINE for i in range ( n - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( carry == 1 ) : NEW_LINE INDENT a [ i ] += 1 NEW_LINE carry = a [ i ] / 10 NEW_LINE a [ i ] = a [ i ] % 10 NEW_LINE DEDENT DEDENT if ( carry == 1 ) : NEW_LINE INDENT a . insert ( 0 , 1 ) NEW_LINE DEDENT DEDENT vect = [ 1 , 7 , 8 , 9 ] NEW_LINE incrementVector ( vect ) NEW_LINE for i in range ( 0 , len ( vect ) ) : NEW_LINE INDENT print ( vect [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def primeCount ( arr , n ) : NEW_LINE INDENT max_val = max ( arr ) NEW_LINE prime = [ True ] * ( max_val + 1 ) NEW_LINE prime [ 0 ] = prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE while p * p <= max_val : NEW_LINE INDENT if prime [ p ] == True : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if prime [ arr [ i ] ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT def getPrefixArray ( arr , n , pre ) : NEW_LINE INDENT pre [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + arr [ i ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 4 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE pre = [ None ] * n NEW_LINE getPrefixArray ( arr , n , pre ) NEW_LINE print ( primeCount ( pre , n ) ) NEW_LINE DEDENT
def Sum ( k , n ) : NEW_LINE INDENT Summ = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT p = 1 NEW_LINE for j in range ( n - i ) : NEW_LINE INDENT p = p * k NEW_LINE DEDENT for j in range ( i ) : NEW_LINE INDENT p = p * ( k - 1 ) NEW_LINE DEDENT Summ = Summ + p NEW_LINE DEDENT return Summ NEW_LINE DEDENT n = 3 NEW_LINE K = 3 NEW_LINE print ( Sum ( K , n ) ) NEW_LINE
def power ( a , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if n & 1 : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def countIntegers ( l , r ) : NEW_LINE INDENT ans , i = 0 , 1 NEW_LINE v = power ( 2 , i ) NEW_LINE while v <= r : NEW_LINE INDENT while v <= r : NEW_LINE INDENT if v >= l : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT v = v * 3 NEW_LINE DEDENT i += 1 NEW_LINE v = power ( 2 , i ) NEW_LINE DEDENT if l == 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l , r = 12 , 21 NEW_LINE print ( countIntegers ( l , r ) ) NEW_LINE DEDENT
DP_s = 9 NEW_LINE def getNumMonotone ( ln ) : NEW_LINE INDENT DP = [ [ 0 ] * DP_s for i in range ( ln ) ] NEW_LINE for i in range ( DP_s ) : NEW_LINE INDENT DP [ 0 ] [ i ] = i + 1 NEW_LINE DEDENT for i in range ( ln ) : NEW_LINE INDENT DP [ i ] [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , ln ) : NEW_LINE INDENT for j in range ( 1 , DP_s ) : NEW_LINE INDENT DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] NEW_LINE DEDENT DEDENT return DP [ ln - 1 ] [ DP_s - 1 ] NEW_LINE DEDENT print ( getNumMonotone ( 10 ) ) NEW_LINE
print ( bin ( 4 ) . count ( '1' ) ) ; NEW_LINE print ( bin ( 15 ) . count ( '1' ) ) ; NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def printPaths ( root ) : NEW_LINE INDENT path = [ ] NEW_LINE printPathsRec ( root , path , 0 ) NEW_LINE DEDENT def printPathsRec ( root , path , pathLen ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT if ( len ( path ) > pathLen ) : NEW_LINE INDENT path [ pathLen ] = root . data NEW_LINE DEDENT else : NEW_LINE INDENT path . append ( root . data ) NEW_LINE DEDENT pathLen = pathLen + 1 NEW_LINE if root . left is None and root . right is None : NEW_LINE INDENT printArray ( path , pathLen ) NEW_LINE DEDENT else : NEW_LINE INDENT printPathsRec ( root . left , path , pathLen ) NEW_LINE printPathsRec ( root . right , path , pathLen ) NEW_LINE DEDENT DEDENT def printArray ( ints , len ) : NEW_LINE INDENT for i in ints [ 0 : len ] : NEW_LINE INDENT print ( i , " ▁ " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT root = Node ( 10 ) NEW_LINE root . left = Node ( 8 ) NEW_LINE root . right = Node ( 2 ) NEW_LINE root . left . left = Node ( 3 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . left = Node ( 2 ) NEW_LINE printPaths ( root ) NEW_LINE
import math NEW_LINE def countRectangles ( l , w ) : NEW_LINE INDENT squareSide = math . gcd ( l , w ) NEW_LINE return ( l * w ) / ( squareSide * squareSide ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT l = 4 NEW_LINE w = 6 NEW_LINE ans = countRectangles ( l , w ) NEW_LINE print ( int ( ans ) ) NEW_LINE DEDENT
import math NEW_LINE def factorize ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( ( n % 2 > 0 ) == False ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( 2 , count ) ; NEW_LINE DEDENT for i in range ( 3 , int ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n = int ( n / i ) ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT print ( i , count ) ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT print ( n , 1 ) ; NEW_LINE DEDENT DEDENT n = 1000000000000000000 ; NEW_LINE factorize ( n ) ; NEW_LINE
class newNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = self . right = None NEW_LINE DEDENT DEDENT def prInorder ( node ) : NEW_LINE INDENT if ( node == None ) : NEW_LINE INDENT return NEW_LINE DEDENT prInorder ( node . left ) NEW_LINE print ( node . data , end = " ▁ " ) NEW_LINE prInorder ( node . right ) NEW_LINE DEDENT def constructBinaryTreeUtil ( pre , preM , preIndex , l , h , size ) : NEW_LINE INDENT if ( preIndex >= size or l > h ) : NEW_LINE INDENT return None , preIndex NEW_LINE DEDENT root = newNode ( pre [ preIndex ] ) NEW_LINE preIndex += 1 NEW_LINE if ( l == h ) : NEW_LINE INDENT return root , preIndex NEW_LINE DEDENT i = 0 NEW_LINE for i in range ( l , h + 1 ) : NEW_LINE INDENT if ( pre [ preIndex ] == preM [ i ] ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i <= h ) : NEW_LINE INDENT root . left , preIndex = constructBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) NEW_LINE root . right , preIndex = constructBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) NEW_LINE DEDENT return root , preIndex NEW_LINE DEDENT def constructBinaryTree ( root , pre , preMirror , size ) : NEW_LINE INDENT preIndex = 0 NEW_LINE preMIndex = 0 NEW_LINE root , x = constructBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) NEW_LINE prInorder ( root ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT preOrder = [ 1 , 2 , 4 , 5 , 3 , 6 , 7 ] NEW_LINE preOrderMirror = [ 1 , 3 , 7 , 6 , 2 , 5 , 4 ] NEW_LINE size = 7 NEW_LINE root = newNode ( 0 ) NEW_LINE constructBinaryTree ( root , preOrder , preOrderMirror , size ) NEW_LINE DEDENT
def checkIfStartsWithCapital ( string ) : NEW_LINE INDENT if ( string [ 0 ] >= ' A ' and string [ 0 ] <= ' Z ' ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT def check ( string ) : NEW_LINE INDENT if ( checkIfStartsWithCapital ( string ) ) : NEW_LINE INDENT print ( " Accepted " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ Accepted " ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksforGeeks " ; NEW_LINE check ( string ) ; NEW_LINE string = " geeksforgeeks " ; NEW_LINE check ( string ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def checkPolygonWithMidpoints ( arr , N , midpoints ) : NEW_LINE INDENT for j in range ( midpoints ) : NEW_LINE INDENT val = 1 NEW_LINE for k in range ( j , N , midpoints ) : NEW_LINE INDENT val &= arr [ k ] NEW_LINE DEDENT if ( val and N // midpoints > 2 ) : NEW_LINE INDENT print ( " Polygon ▁ possible ▁ with ▁ side ▁ length " , ( N // midpoints ) ) NEW_LINE return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isPolygonPossible ( arr , N ) : NEW_LINE INDENT limit = sqrt ( N ) NEW_LINE for i in range ( 1 , int ( limit ) + 1 ) : NEW_LINE INDENT if ( N % i == 0 ) : NEW_LINE INDENT if ( checkPolygonWithMidpoints ( arr , N , i ) or checkPolygonWithMidpoints ( arr , N , ( N // i ) ) ) : NEW_LINE INDENT return NEW_LINE DEDENT DEDENT DEDENT print ( " Not ▁ possiblen " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 ] NEW_LINE N = len ( arr ) NEW_LINE isPolygonPossible ( arr , N ) NEW_LINE DEDENT
def isToOne ( n ) : NEW_LINE INDENT return ( n > 0 ) NEW_LINE DEDENT n = 5 NEW_LINE if isToOne ( n ) == True : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def distinctSubstring ( P , N ) : NEW_LINE INDENT S = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT freq = [ False ] * 26 NEW_LINE s = " " NEW_LINE for j in range ( i , N ) : NEW_LINE INDENT pos = ord ( P [ j ] ) - ord ( ' a ' ) NEW_LINE if ( freq [ pos ] == True ) : NEW_LINE INDENT break NEW_LINE DEDENT freq [ pos ] = True NEW_LINE s += P [ j ] NEW_LINE S [ s ] = 1 NEW_LINE DEDENT DEDENT return len ( S ) NEW_LINE DEDENT S = " abba " NEW_LINE N = len ( S ) NEW_LINE print ( distinctSubstring ( S , N ) ) NEW_LINE
def minimumX ( n , k ) : NEW_LINE INDENT ans = 10 ** 18 NEW_LINE for i in range ( k - 1 , 0 , - 1 ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT ans = min ( ans , i + ( n / i ) * k ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT n , k = 4 , 6 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE n , k = 5 , 5 NEW_LINE print ( minimumX ( n , k ) ) NEW_LINE
def findMinDifference ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE diff1 = arr [ n - 1 ] - arr [ 1 ] NEW_LINE diff2 = arr [ n - 2 ] - arr [ 0 ] NEW_LINE return min ( diff1 , diff2 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinDifference ( arr , n ) ) NEW_LINE DEDENT
a , b , c = 5 , 7 , 10 NEW_LINE if ( a <= b and a <= c ) : NEW_LINE INDENT print ( a , " is ▁ the ▁ smallest " ) NEW_LINE DEDENT elif ( b <= a and b <= c ) : NEW_LINE INDENT print ( b , " is ▁ the ▁ smallest " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( c , " is ▁ the ▁ smallest " ) NEW_LINE DEDENT
isPrime = [ 1 ] * 100005 NEW_LINE def sieveOfEratostheneses ( ) : NEW_LINE INDENT isPrime [ 1 ] = False NEW_LINE i = 2 NEW_LINE while i * i < 100005 : NEW_LINE INDENT if ( isPrime [ i ] ) : NEW_LINE INDENT j = 2 * i NEW_LINE while j < 100005 : NEW_LINE INDENT isPrime [ j ] = False NEW_LINE j += i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return NEW_LINE DEDENT def findPrime ( n ) : NEW_LINE INDENT num = n + 1 NEW_LINE while ( num ) : NEW_LINE INDENT if isPrime [ num ] : NEW_LINE INDENT return num NEW_LINE DEDENT num += 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT def minNumber ( arr ) : NEW_LINE INDENT sieveOfEratostheneses ( ) NEW_LINE s = 0 NEW_LINE for i in range ( 0 , len ( arr ) ) : NEW_LINE INDENT s += arr [ i ] NEW_LINE DEDENT if isPrime [ s ] == True : NEW_LINE INDENT return 0 NEW_LINE DEDENT num = findPrime ( s ) NEW_LINE return num - s NEW_LINE DEDENT arr = [ 2 , 4 , 6 , 8 , 12 ] NEW_LINE print ( minNumber ( arr ) ) NEW_LINE
import math NEW_LINE def isPower ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for x in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = ( int ) ( math . pow ( x , y ) ) NEW_LINE while ( p <= n and p > 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT y = y + 1 NEW_LINE p = math . pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT for i in range ( 2 , 100 ) : NEW_LINE INDENT if ( isPower ( i ) ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def minMovesToSort ( arr , n ) : NEW_LINE INDENT moves = 0 NEW_LINE mn = arr [ n - 1 ] NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ i ] > mn ) : NEW_LINE INDENT moves += arr [ i ] - mn NEW_LINE DEDENT mn = arr [ i ] NEW_LINE DEDENT return moves NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 5 , 2 , 8 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minMovesToSort ( arr , n ) ) NEW_LINE DEDENT
INT_MIN = - 2 ** 31 NEW_LINE INT_MAX = 2 ** 31 NEW_LINE class newNode ( ) : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def NumberOfBST ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return 0 , INT_MIN , INT_MAX , True NEW_LINE DEDENT if ( root . left == None and root . right == None ) : NEW_LINE INDENT return 1 , root . data , root . data , True NEW_LINE DEDENT L = NumberOfBST ( root . left ) NEW_LINE R = NumberOfBST ( root . right ) NEW_LINE bst = [ 0 ] * 4 NEW_LINE bst [ 2 ] = min ( root . data , ( min ( L [ 2 ] , R [ 2 ] ) ) ) NEW_LINE bst [ 1 ] = max ( root . data , ( max ( L [ 1 ] , R [ 1 ] ) ) ) NEW_LINE if ( L [ 3 ] and R [ 3 ] and root . data > L [ 1 ] and root . data < R [ 2 ] ) : NEW_LINE INDENT bst [ 3 ] = True NEW_LINE bst [ 0 ] = 1 + L [ 0 ] + R [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT bst [ 3 ] = False NEW_LINE bst [ 0 ] = L [ 0 ] + R [ 0 ] NEW_LINE DEDENT return bst NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 5 ) NEW_LINE root . left = newNode ( 9 ) NEW_LINE root . right = newNode ( 3 ) NEW_LINE root . left . left = newNode ( 6 ) NEW_LINE root . right . right = newNode ( 4 ) NEW_LINE root . left . left . left = newNode ( 8 ) NEW_LINE root . left . left . right = newNode ( 7 ) NEW_LINE print ( NumberOfBST ( root ) [ 0 ] ) NEW_LINE DEDENT
def calculateSum ( n ) : NEW_LINE INDENT return ( ( 2 * ( n * ( n + 1 ) / 2 ) ** 2 ) + ( ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ) ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Sum ▁ = " , calculateSum ( n ) ) NEW_LINE
from math import sqrt NEW_LINE def isNonHypotenuse ( n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( ( i - 1 ) % 4 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n // i NEW_LINE DEDENT DEDENT DEDENT if ( n > 2 and ( n - 1 ) % 4 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def test ( n ) : NEW_LINE INDENT print ( " Testing ▁ for " , n , " : " , end = " ▁ " ) NEW_LINE if ( isNonHypotenuse ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE test ( n ) NEW_LINE n = 10 NEW_LINE test ( n ) NEW_LINE DEDENT
def printSquares ( n ) : NEW_LINE INDENT square = 0 NEW_LINE odd = 1 NEW_LINE for x in range ( 0 , n ) : NEW_LINE INDENT print ( square , end = " ▁ " ) NEW_LINE square = square + odd NEW_LINE odd = odd + 2 NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printSquares ( n ) NEW_LINE
def revAlternateK ( s , k , Len ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( s ) ) : NEW_LINE INDENT if ( i + k > Len ) : NEW_LINE INDENT break NEW_LINE DEDENT ss = s [ i : i + k ] NEW_LINE s = s [ : i ] + ss [ : : - 1 ] + s [ i + k : ] NEW_LINE i += 2 * k NEW_LINE DEDENT return s ; NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE Len = len ( s ) NEW_LINE k = 3 NEW_LINE print ( revAlternateK ( s , k , Len ) ) NEW_LINE
def countRotationsDivBy8 ( n ) : NEW_LINE INDENT l = len ( n ) NEW_LINE count = 0 NEW_LINE if ( l == 1 ) : NEW_LINE INDENT oneDigit = int ( n [ 0 ] ) NEW_LINE if ( oneDigit % 8 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( l == 2 ) : NEW_LINE INDENT first = int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) NEW_LINE second = int ( n [ 1 ] ) * 10 + int ( n [ 0 ] ) NEW_LINE if ( first % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( second % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT threeDigit = 0 NEW_LINE for i in range ( 0 , ( l - 2 ) ) : NEW_LINE INDENT threeDigit = ( int ( n [ i ] ) * 100 + int ( n [ i + 1 ] ) * 10 + int ( n [ i + 2 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT threeDigit = ( int ( n [ l - 1 ] ) * 100 + int ( n [ 0 ] ) * 10 + int ( n [ 1 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT threeDigit = ( int ( n [ l - 2 ] ) * 100 + int ( n [ l - 1 ] ) * 10 + int ( n [ 0 ] ) ) NEW_LINE if ( threeDigit % 8 == 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = "43262488612" NEW_LINE print ( " Rotations : " , countRotationsDivBy8 ( n ) ) NEW_LINE DEDENT
def printValue ( digit ) : NEW_LINE INDENT if digit == '0' : NEW_LINE INDENT print ( " Zero ▁ " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '1' : NEW_LINE INDENT print ( " One ▁ " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '2' : NEW_LINE INDENT print ( " Two ▁ " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '3' : NEW_LINE INDENT print ( " Three " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '4' : NEW_LINE INDENT print ( " Four ▁ " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '5' : NEW_LINE INDENT print ( " Five ▁ " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '6' : NEW_LINE INDENT print ( " Six ▁ " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '7' : NEW_LINE INDENT print ( " Seven " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '8' : NEW_LINE INDENT print ( " Eight " , end = " ▁ " ) NEW_LINE DEDENT elif digit == '9' : NEW_LINE INDENT print ( " Nine ▁ " , end = " ▁ " ) NEW_LINE DEDENT DEDENT def printWord ( N ) : NEW_LINE INDENT i = 0 NEW_LINE length = len ( N ) NEW_LINE while i < length : NEW_LINE INDENT printValue ( N [ i ] ) NEW_LINE i += 1 NEW_LINE DEDENT DEDENT N = "123" NEW_LINE printWord ( N ) NEW_LINE
def findSplTripletsSum ( a , b , c , p , q , r ) : NEW_LINE INDENT summ = 0 NEW_LINE for i in range ( p ) : NEW_LINE INDENT for j in range ( q ) : NEW_LINE INDENT for k in range ( r ) : NEW_LINE INDENT if ( a [ i ] <= b [ j ] and c [ k ] <= b [ j ] ) : NEW_LINE INDENT summ += ( a [ i ] + b [ j ] ) * ( b [ j ] + c [ k ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return summ NEW_LINE DEDENT A = [ 1 , 4 , 5 ] NEW_LINE B = [ 2 , 3 ] NEW_LINE C = [ 2 , 1 , 3 ] NEW_LINE p = len ( A ) NEW_LINE q = len ( B ) NEW_LINE r = len ( C ) NEW_LINE print ( " Sum ▁ of ▁ values ▁ of ▁ all ▁ special ▁ triplets ▁ = ▁ " , findSplTripletsSum ( A , B , C , p , q , r ) ) NEW_LINE
def nthDigit ( a , n , b ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT a = a // b NEW_LINE DEDENT return a % b NEW_LINE DEDENT a = 100 NEW_LINE n = 3 NEW_LINE b = 4 NEW_LINE print ( nthDigit ( a , n , b ) ) NEW_LINE
def sum ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; NEW_LINE DEDENT DEDENT n = 2 ; NEW_LINE print ( sum ( n ) ) ; NEW_LINE
import sys NEW_LINE TEN = 10 NEW_LINE def minNum ( str , len1 ) : NEW_LINE INDENT res = sys . maxsize NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT if ( str [ i ] == '4' or str [ i ] == '8' ) : NEW_LINE INDENT res = min ( res , ord ( str [ i ] ) - ord ( '0' ) ) NEW_LINE DEDENT DEDENT for i in range ( len1 - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , len1 , 1 ) : NEW_LINE INDENT num = ( ord ( str [ i ] ) - ord ( '0' ) ) * TEN +   \ NEW_LINE INDENT ( ord ( str [ j ] ) - ord ( '0' ) ) NEW_LINE DEDENT if ( num % 4 == 0 ) : NEW_LINE INDENT res = min ( res , num ) NEW_LINE DEDENT DEDENT DEDENT if ( res == sys . maxsize ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return res NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "17" NEW_LINE len1 = len ( str ) NEW_LINE print ( minNum ( str , len1 ) ) NEW_LINE DEDENT
from math import * NEW_LINE def isPower ( a ) : NEW_LINE INDENT if a == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 2 , int ( sqrt ( a ) ) + 1 ) : NEW_LINE INDENT val = log ( a ) / log ( i ) NEW_LINE if ( round ( ( val - int ( val ) ) , 8 ) < 0.00000001 ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 16 NEW_LINE if isPower ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def countNonDecreasing ( n ) : NEW_LINE INDENT N = 10 NEW_LINE count = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT count = int ( count * ( N + i - 1 ) ) NEW_LINE count = int ( count / i ) NEW_LINE DEDENT return count NEW_LINE DEDENT n = 3 ; NEW_LINE print ( countNonDecreasing ( n ) ) NEW_LINE
def search ( arr , start , end , value ) : NEW_LINE INDENT for i in range ( start , end + 1 ) : NEW_LINE INDENT if arr [ i ] == value : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def getHeight ( inOrder , levelOrder , start , end , height , n ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return 0 NEW_LINE DEDENT getIndex = search ( inOrder , start , end , levelOrder [ 0 ] ) NEW_LINE if getIndex == - 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT leftCount = getIndex - start NEW_LINE rightCount = end - getIndex NEW_LINE newLeftLevel = [ None for _ in range ( leftCount ) ] NEW_LINE newRightLevel = [ None for _ in range ( rightCount ) ] NEW_LINE lheight , rheight , k = 0 , 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( start , getIndex ) : NEW_LINE INDENT if levelOrder [ i ] == inOrder [ j ] : NEW_LINE INDENT newLeftLevel [ k ] = levelOrder [ i ] NEW_LINE k += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT k = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( getIndex + 1 , end + 1 ) : NEW_LINE INDENT if levelOrder [ i ] == inOrder [ j ] : NEW_LINE INDENT newRightLevel [ k ] = levelOrder [ i ] NEW_LINE k += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if leftCount > 0 : NEW_LINE INDENT lheight = getHeight ( inOrder , newLeftLevel , start , getIndex - 1 , height , leftCount ) NEW_LINE DEDENT if rightCount > 0 : NEW_LINE INDENT rheight = getHeight ( inOrder , newRightLevel , getIndex + 1 , end , height , rightCount ) NEW_LINE DEDENT height = max ( lheight + 1 , rheight + 1 ) NEW_LINE return height NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT inOrder = [ 4 , 8 , 10 , 12 , 14 , 20 , 22 ] NEW_LINE levelOrder = [ 20 , 8 , 22 , 4 , 12 , 10 , 14 ] NEW_LINE n , h = len ( inOrder ) , 0 NEW_LINE print ( getHeight ( inOrder , levelOrder , 0 , n - 1 , h , n ) ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def treeToString ( root : Node , string : list ) : NEW_LINE INDENT if root is None : NEW_LINE INDENT return NEW_LINE DEDENT string . append ( str ( root . data ) ) NEW_LINE if not root . left and not root . right : NEW_LINE INDENT return NEW_LINE DEDENT string . append ( ' ( ' ) NEW_LINE treeToString ( root . left , string ) NEW_LINE string . append ( ' ) ' ) NEW_LINE if root . right : NEW_LINE INDENT string . append ( ' ( ' ) NEW_LINE treeToString ( root . right , string ) NEW_LINE string . append ( ' ) ' ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT root = Node ( 1 ) NEW_LINE root . left = Node ( 2 ) NEW_LINE root . right = Node ( 3 ) NEW_LINE root . left . left = Node ( 4 ) NEW_LINE root . left . right = Node ( 5 ) NEW_LINE root . right . right = Node ( 6 ) NEW_LINE string = [ ] NEW_LINE treeToString ( root , string ) NEW_LINE print ( ' ' . join ( string ) ) NEW_LINE DEDENT
def triangular_series ( n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( i * ( i + 1 ) // 2 , end = ' ▁ ' ) NEW_LINE DEDENT DEDENT n = 5 NEW_LINE triangular_series ( n ) NEW_LINE
def lds ( arr , n ) : NEW_LINE INDENT lds = [ 0 ] * n NEW_LINE max = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT lds [ i ] = 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if ( arr [ i ] < arr [ j ] and lds [ i ] < lds [ j ] + 1 ) : NEW_LINE INDENT lds [ i ] = lds [ j ] + 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( max < lds [ i ] ) : NEW_LINE INDENT max = lds [ i ] NEW_LINE DEDENT DEDENT return max NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Length ▁ of ▁ LDS ▁ is " , lds ( arr , n ) ) NEW_LINE DEDENT
n = 3 NEW_LINE def dotProduct ( vect_A , vect_B ) : NEW_LINE INDENT product = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT product = product + vect_A [ i ] * vect_B [ i ] NEW_LINE DEDENT return product NEW_LINE DEDENT def crossProduct ( vect_A , vect_B , cross_P ) : NEW_LINE INDENT cross_P . append ( vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ) NEW_LINE cross_P . append ( vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ) NEW_LINE cross_P . append ( vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT vect_A = [ 3 , - 5 , 4 ] NEW_LINE vect_B = [ 2 , 6 , 5 ] NEW_LINE cross_P = [ ] NEW_LINE print ( " Dot ▁ product : " , end = " ▁ " ) NEW_LINE print ( dotProduct ( vect_A , vect_B ) ) NEW_LINE print ( " Cross ▁ product : " , end = " ▁ " ) NEW_LINE crossProduct ( vect_A , vect_B , cross_P ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT print ( cross_P [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def partitions ( n ) : NEW_LINE INDENT p = [ 0 ] * ( n + 1 ) NEW_LINE p [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT k = 1 NEW_LINE while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) : NEW_LINE INDENT p [ i ] += ( ( 1 if k % 2 else - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) // 2 ] ) NEW_LINE if ( k > 0 ) : NEW_LINE INDENT k *= - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = 1 - k NEW_LINE DEDENT DEDENT DEDENT return p [ n ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 20 NEW_LINE print ( partitions ( N ) ) NEW_LINE DEDENT
def isSquarePossible ( arr , n , l ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] >= l : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT if cnt >= l : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def maxArea ( arr , n ) : NEW_LINE INDENT l , r = 0 , n NEW_LINE len = 0 NEW_LINE while l <= r : NEW_LINE INDENT m = l + ( ( r - l ) // 2 ) NEW_LINE if isSquarePossible ( arr , n , m ) : NEW_LINE INDENT len = m NEW_LINE l = m + 1 NEW_LINE DEDENT else : NEW_LINE INDENT r = m - 1 NEW_LINE DEDENT DEDENT return ( len * len ) NEW_LINE DEDENT arr = [ 1 , 3 , 4 , 5 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxArea ( arr , n ) ) NEW_LINE
def findEvenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( A [ i ] | A [ j ] ) % 2 == 0 : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 5 , 6 , 2 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( findEvenPair ( A , N ) ) NEW_LINE DEDENT
def pairORSum ( arr , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( ( i + 1 ) , n ) : NEW_LINE INDENT ans = ans + arr [ i ] | arr [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( pairORSum ( arr , n ) ) NEW_LINE
MAX = 26 NEW_LINE def targetstring ( str1 , str2 ) : NEW_LINE INDENT l1 = len ( str1 ) NEW_LINE l2 = len ( str2 ) NEW_LINE if ( l1 != l2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT map = [ 0 ] * MAX NEW_LINE for i in range ( l1 ) : NEW_LINE INDENT map [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( l2 ) : NEW_LINE INDENT map [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE if ( map [ ord ( str2 [ i ] ) - ord ( ' a ' ) ] < 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeksforgeeks " NEW_LINE str2 = " geegeeksksfor " NEW_LINE if ( targetstring ( str1 , str2 ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
import sys NEW_LINE def maxLength ( s , n ) : NEW_LINE INDENT ans = - ( sys . maxsize + 1 ) ; NEW_LINE A , L , R = [ ] , [ ] , [ ] ; NEW_LINE freq = [ 0 ] * ( n + 5 ) ; NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT count = 0 ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( ord ( s [ j ] ) - ord ( ' a ' ) == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT freq [ j ] = count ; NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT L . append ( ( 2 * freq [ j - 1 ] ) - j ) ; NEW_LINE R . append ( ( 2 * freq [ j ] ) - j ) ; NEW_LINE DEDENT max_len = - ( sys . maxsize + 1 ) ; NEW_LINE min_val = sys . maxsize ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT min_val = min ( min_val , L [ j ] ) ; NEW_LINE A . append ( min_val ) ; NEW_LINE l = 0 ; r = j ; NEW_LINE while ( l <= r ) : NEW_LINE INDENT mid = ( l + r ) >> 1 ; NEW_LINE if ( A [ mid ] <= R [ j ] ) : NEW_LINE INDENT max_len = max ( max_len , j - mid + 1 ) ; NEW_LINE r = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT l = mid + 1 ; NEW_LINE DEDENT DEDENT DEDENT ans = max ( ans , max_len ) ; NEW_LINE A . clear ( ) ; NEW_LINE R . clear ( ) ; NEW_LINE L . clear ( ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " ababbbacbcbcca " ; NEW_LINE n = len ( s ) ; NEW_LINE print ( maxLength ( s , n ) ) ; NEW_LINE DEDENT
def isPrime ( p ) : NEW_LINE INDENT checkNumber = 2 ** p - 1 NEW_LINE nextval = 4 % checkNumber NEW_LINE for i in range ( 1 , p - 1 ) : NEW_LINE INDENT nextval = ( nextval * nextval - 2 ) % checkNumber NEW_LINE DEDENT if ( nextval == 0 ) : return True NEW_LINE else : return False NEW_LINE DEDENT p = 7 NEW_LINE checkNumber = 2 ** p - 1 NEW_LINE if isPrime ( p ) : NEW_LINE INDENT print ( checkNumber , ' is ▁ Prime . ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( checkNumber , ' is ▁ not ▁ Prime ' ) NEW_LINE DEDENT
def minOps ( arr , n , k ) : NEW_LINE INDENT max1 = max ( arr ) NEW_LINE res = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( ( max1 - arr [ i ] ) % k != 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT res += ( max1 - arr [ i ] ) / k NEW_LINE DEDENT DEDENT return int ( res ) NEW_LINE DEDENT arr = [ 21 , 33 , 9 , 45 , 63 ] NEW_LINE n = len ( arr ) NEW_LINE k = 6 NEW_LINE print ( minOps ( arr , n , k ) ) NEW_LINE
def minChanges ( str , n ) : NEW_LINE INDENT count , zeros , ones = 0 , 0 , 0 NEW_LINE if ( ord ( str [ 0 ] ) != ord ( '1' ) ) : NEW_LINE INDENT count += 1 NEW_LINE ones += 1 NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( ord ( str [ i ] ) == ord ( '0' ) ) : NEW_LINE INDENT zeros += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT if ( zeros > ones ) : NEW_LINE INDENT zeros -= 1 NEW_LINE ones += 1 NEW_LINE count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "0000" NEW_LINE n = len ( str ) NEW_LINE print ( minChanges ( str , n ) ) NEW_LINE DEDENT
MAX = 1000001 NEW_LINE MAX_sqrt = MAX ** ( 0.5 ) NEW_LINE primeUpto = [ 0 ] * ( MAX ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT isPrime = [ 1 ] * ( MAX ) NEW_LINE isPrime [ 0 ] , isPrime [ 1 ] = 0 , 0 NEW_LINE for i in range ( 2 , int ( MAX_sqrt ) ) : NEW_LINE INDENT if isPrime [ i ] == 1 : NEW_LINE INDENT for j in range ( i * 2 , MAX , i ) : NEW_LINE INDENT isPrime [ j ] = 0 NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , MAX ) : NEW_LINE INDENT primeUpto [ i ] = primeUpto [ i - 1 ] NEW_LINE if isPrime [ i ] == 1 : NEW_LINE INDENT primeUpto [ i ] += 1 NEW_LINE DEDENT DEDENT DEDENT def countOfNumbers ( N , K ) : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE low , high , ans = 1 , N , 0 NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) >> 1 NEW_LINE if mid - primeUpto [ mid ] >= K : NEW_LINE INDENT ans = mid NEW_LINE high = mid - 1 NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return ( N - ans + 1 ) if ans else 0 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 10 , 3 NEW_LINE print ( countOfNumbers ( N , K ) ) NEW_LINE DEDENT
def isRectangle ( a , b , c , d ) : NEW_LINE INDENT if a == b == c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == b and c == d : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == d and c == b : NEW_LINE INDENT return True NEW_LINE DEDENT elif a == c and d == b : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a , b , c , d = 1 , 2 , 3 , 4 NEW_LINE print ( " Yes " if isRectangle ( a , b , c , d ) else " No " ) NEW_LINE
def countSubArrays ( arr , x , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE start = - 1 ; end = - 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < x ) : NEW_LINE INDENT if ( start == - 1 ) : NEW_LINE INDENT start = i ; NEW_LINE end = i ; NEW_LINE DEDENT else : NEW_LINE INDENT end = i ; NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( start != - 1 and end != - 1 ) : NEW_LINE INDENT length = end - start + 1 ; NEW_LINE count = count + ( ( length * ( length + 1 ) ) / 2 ) ; NEW_LINE DEDENT start = - 1 ; NEW_LINE end = - 1 ; NEW_LINE DEDENT DEDENT if ( start != - 1 and end != - 1 ) : NEW_LINE INDENT length = end - start + 1 ; NEW_LINE count = count + ( ( length * ( length + 1 ) ) / 2 ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT arr = [ 1 , 5 , 7 , 8 , 2 , 3 , 9 ] ; NEW_LINE x = 6 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countSubArrays ( arr , x , n ) ) ; NEW_LINE
def circumferenceparallelogram ( a , b ) : NEW_LINE INDENT return ( ( 2 * a ) + ( 2 * b ) ) NEW_LINE DEDENT a = 10 NEW_LINE b = 8 NEW_LINE print ( " Circumference ▁ of ▁ a ▁ given ▁ Parallelogram ▁ is ▁ : " , round ( circumferenceparallelogram ( a , b ) , 4 ) ) NEW_LINE
def singleNumber ( nums ) : NEW_LINE INDENT return ( 3 * sum ( set ( nums ) ) - sum ( nums ) ) / 2 NEW_LINE DEDENT a = [ 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 ] NEW_LINE print ( " The ▁ element ▁ with ▁ single ▁ occurrence ▁ is ▁ " , int ( singleNumber ( a ) ) ) NEW_LINE
def nthTerm ( N ) : NEW_LINE INDENT return ( N * ( ( N // 2 ) + ( ( N % 2 ) * 2 ) + N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 5 NEW_LINE print ( " Nth ▁ term ▁ for ▁ N ▁ = ▁ " , N , " ▁ : ▁ " , nthTerm ( N ) ) NEW_LINE DEDENT
def isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) : NEW_LINE INDENT for i in range ( lowQuant , upQuant + 1 ) : NEW_LINE INDENT ans = i * r NEW_LINE if ( lowCost <= ans and ans <= upCost ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT lowCost = 14 ; upCost = 30 NEW_LINE lowQuant = 5 ; upQuant = 12 ; r = 9 NEW_LINE if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
import sys NEW_LINE def MatrixChainOrder ( p , i , j ) : NEW_LINE INDENT if i == j : NEW_LINE INDENT return 0 NEW_LINE DEDENT _min = sys . maxsize NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT count = ( MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ) NEW_LINE if count < _min : NEW_LINE INDENT _min = count ; NEW_LINE DEDENT DEDENT return _min ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " , MatrixChainOrder ( arr , 1 , n - 1 ) ) ; NEW_LINE
def countDigit ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT return 1 + countDigit ( n // 10 ) NEW_LINE DEDENT n = 345289467 NEW_LINE print ( " Number ▁ of ▁ digits ▁ : ▁ % ▁ d " % ( countDigit ( n ) ) ) NEW_LINE
import math as mt NEW_LINE def printPrevSmaller ( arr , n ) : NEW_LINE INDENT S = list ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT while ( len ( S ) > 0 and S [ - 1 ] >= arr [ i ] ) : NEW_LINE INDENT S . pop ( ) NEW_LINE DEDENT if ( len ( S ) == 0 ) : NEW_LINE INDENT print ( " _ , ▁ " , end = " " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( S [ - 1 ] , end = " , ▁ " ) NEW_LINE DEDENT S . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 0 , 2 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE printPrevSmaller ( arr , n ) NEW_LINE
def wastedWater ( V , M , N ) : NEW_LINE INDENT amt_per_min = M - N NEW_LINE time_to_fill = V / amt_per_min NEW_LINE wasted_amt = N * time_to_fill NEW_LINE return wasted_amt NEW_LINE DEDENT V = 700 NEW_LINE M = 10 NEW_LINE N = 3 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE V = 1000 NEW_LINE M = 100 NEW_LINE N = 50 NEW_LINE print ( wastedWater ( V , M , N ) ) NEW_LINE
def getSecondMostFreq ( str ) : NEW_LINE INDENT NO_OF_CHARS = 256 NEW_LINE count = [ 0 ] * NO_OF_CHARS NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT count [ ord ( str [ i ] ) ] += 1 NEW_LINE DEDENT first , second = 0 , 0 NEW_LINE for i in range ( NO_OF_CHARS ) : NEW_LINE INDENT if count [ i ] > count [ first ] : NEW_LINE INDENT second = first NEW_LINE first = i NEW_LINE DEDENT elif ( count [ i ] > count [ second ] and count [ i ] != count [ first ] ) : NEW_LINE INDENT second = i NEW_LINE DEDENT DEDENT return chr ( second ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE res = getSecondMostFreq ( str ) NEW_LINE if res != ' \0' : NEW_LINE INDENT print ( " Second ▁ most ▁ frequent ▁ char ▁ is " , res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No ▁ second ▁ most ▁ frequent ▁ character " ) NEW_LINE DEDENT DEDENT
def exponential ( n , x ) : NEW_LINE INDENT sum = 1.0 NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT sum = 1 + x * sum / i NEW_LINE DEDENT print ( " e ^ x ▁ = " , sum ) NEW_LINE DEDENT n = 10 NEW_LINE x = 1.0 NEW_LINE exponential ( n , x ) NEW_LINE
def solve ( A , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE parent = [ None ] * ( n + 1 ) NEW_LINE vis = [ None ] * ( n + 1 ) NEW_LINE for i in range ( 0 , n + 1 ) : NEW_LINE INDENT parent [ i ] = - 1 NEW_LINE vis [ i ] = 0 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT j = i NEW_LINE if ( parent [ j ] == - 1 ) : NEW_LINE INDENT while ( parent [ j ] == - 1 ) : NEW_LINE INDENT parent [ j ] = i NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT if ( parent [ j ] == i ) : NEW_LINE INDENT while ( vis [ j ] == 0 ) : NEW_LINE INDENT vis [ j ] = 1 NEW_LINE cnt = cnt + 1 NEW_LINE j = ( j + A [ j ] + 1 ) % n NEW_LINE DEDENT DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT A = [ 0 , 0 , 0 , 2 ] NEW_LINE n = len ( A ) NEW_LINE print ( solve ( A , n ) ) NEW_LINE
from bisect import bisect as upper_bound NEW_LINE def getCount ( v , n ) : NEW_LINE INDENT v = sorted ( v ) NEW_LINE cnt = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT tmp = n - 1 - upper_bound ( v , v [ i ] - 1 ) NEW_LINE if ( tmp == v [ i ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT n = 4 NEW_LINE v = [ ] NEW_LINE v . append ( 1 ) NEW_LINE v . append ( 2 ) NEW_LINE v . append ( 3 ) NEW_LINE v . append ( 4 ) NEW_LINE print ( getCount ( v , n ) ) NEW_LINE
def lexNext ( s , n ) : NEW_LINE INDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if s [ i ] != ' z ' : NEW_LINE INDENT k = ord ( s [ i ] ) NEW_LINE s [ i ] = chr ( k + 1 ) NEW_LINE return ' ' . join ( s ) NEW_LINE DEDENT s [ i ] = ' a ' NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = " abcdeg " NEW_LINE T = " abcfgh " NEW_LINE n = len ( S ) NEW_LINE S = list ( S ) NEW_LINE res = lexNext ( S , n ) NEW_LINE if res != T : NEW_LINE INDENT print ( res ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT DEDENT
def bridge_length ( trainLength , Speed , Time ) : NEW_LINE INDENT return ( ( Time * Speed ) - trainLength ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT trainLength = 120 NEW_LINE Speed = 30 NEW_LINE Time = 18 NEW_LINE print ( " Length ▁ of ▁ bridge ▁ = ▁ " , bridge_length ( trainLength , Speed , Time ) , " meters " ) NEW_LINE DEDENT
MAX = 100006 ; NEW_LINE count = [ 0 ] * MAX ; NEW_LINE def sieve ( ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i <= MAX ) : NEW_LINE INDENT if ( count [ i ] == 0 ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT count [ j ] += 1 ; NEW_LINE DEDENT count [ i ] = 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def query ( l , r ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( l , r + 1 ) : NEW_LINE INDENT sum += count [ i ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT sieve ( ) ; NEW_LINE print ( query ( 6 , 10 ) , query ( 1 , 5 ) ) ; NEW_LINE
def canBecomeEmpty ( string , sub_str ) : NEW_LINE INDENT while len ( string ) > 0 : NEW_LINE INDENT idx = string . find ( sub_str ) NEW_LINE if idx == - 1 : NEW_LINE INDENT break NEW_LINE DEDENT string = string . replace ( sub_str , " " , 1 ) NEW_LINE DEDENT return ( len ( string ) == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GEEGEEKSKS " NEW_LINE sub_str = " GEEKS " NEW_LINE if canBecomeEmpty ( string , sub_str ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printOrder ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE i = 0 NEW_LINE while ( i < n / 2 ) : NEW_LINE INDENT print arr [ i ] , NEW_LINE i = i + 1 NEW_LINE DEDENT j = n - 1 NEW_LINE while j >= n / 2 : NEW_LINE INDENT print arr [ j ] , NEW_LINE j = j - 1 NEW_LINE DEDENT DEDENT arr = [ 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE printOrder ( arr , n ) NEW_LINE
def CountSwap ( s , n ) : NEW_LINE INDENT s = list ( s ) NEW_LINE count = 0 NEW_LINE ans = True NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT left = i NEW_LINE right = n - left - 1 NEW_LINE while left < right : NEW_LINE INDENT if s [ left ] == s [ right ] : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT right -= 1 NEW_LINE DEDENT DEDENT if left == right : NEW_LINE INDENT ans = False NEW_LINE break NEW_LINE DEDENT else : NEW_LINE INDENT for j in range ( right , n - left - 1 ) : NEW_LINE INDENT ( s [ j ] , s [ j + 1 ] ) = ( s [ j + 1 ] , s [ j ] ) NEW_LINE count += 1 NEW_LINE DEDENT DEDENT DEDENT if ans : NEW_LINE INDENT print ( count ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' - 1' ) NEW_LINE DEDENT DEDENT s = ' geeksfgeeks ' NEW_LINE n = len ( s ) NEW_LINE CountSwap ( s , n ) NEW_LINE
def divisible ( N , digit ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT ans = ( ans * 10 + ( ord ( N [ i ] ) - ord ( '0' ) ) ) ; NEW_LINE ans %= digit ; NEW_LINE DEDENT return ( ans == 0 ) ; NEW_LINE DEDENT def allDigits ( N ) : NEW_LINE INDENT divide = [ False ] * 10 ; NEW_LINE divide [ 1 ] = True ; NEW_LINE for digit in range ( 2 , 10 ) : NEW_LINE INDENT if ( divisible ( N , digit ) ) : NEW_LINE INDENT divide [ digit ] = True ; NEW_LINE DEDENT DEDENT result = 0 ; NEW_LINE for i in range ( len ( N ) ) : NEW_LINE INDENT if ( divide [ ( ord ( N [ i ] ) - ord ( '0' ) ) ] == True ) : NEW_LINE INDENT result += 1 ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT N = "122324" ; NEW_LINE print ( allDigits ( N ) ) ; NEW_LINE
import bisect NEW_LINE def getPairs ( A , B , n ) : NEW_LINE INDENT D = [ 0 ] * ( n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT D [ i ] = A [ i ] - B [ i ] NEW_LINE DEDENT D . sort ( ) NEW_LINE total = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( D [ i ] > 0 ) : NEW_LINE INDENT total += n - i - 1 NEW_LINE DEDENT else : NEW_LINE INDENT k = bisect . bisect_right ( D , - D [ i ] , 0 , len ( D ) ) NEW_LINE total += n - k NEW_LINE DEDENT DEDENT return total NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE A = [ ] NEW_LINE B = [ ] NEW_LINE A . append ( 4 ) ; NEW_LINE A . append ( 8 ) ; NEW_LINE A . append ( 2 ) ; NEW_LINE A . append ( 6 ) ; NEW_LINE A . append ( 2 ) ; NEW_LINE B . append ( 4 ) ; NEW_LINE B . append ( 5 ) ; NEW_LINE B . append ( 4 ) ; NEW_LINE B . append ( 1 ) ; NEW_LINE B . append ( 3 ) ; NEW_LINE print ( getPairs ( A , B , n ) ) NEW_LINE DEDENT
def f ( i , m , s , memoize ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( memoize [ i ] [ m ] != - 1 ) : NEW_LINE INDENT return memoize [ i ] [ m ] NEW_LINE DEDENT x = ord ( s [ i ] ) - ord ( '0' ) NEW_LINE ans = ( ( ( x + m ) % 3 == 0 and x % 2 == 0 ) + f ( i + 1 , ( m + x ) % 3 , s , memoize ) ) NEW_LINE memoize [ i ] [ m ] = ans NEW_LINE return memoize [ i ] [ m ] NEW_LINE DEDENT def countDivBy6 ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE memoize = [ [ - 1 ] * 3 for i in range ( n + 1 ) ] NEW_LINE ans = 0 NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT else : NEW_LINE INDENT ans += f ( i , 0 , s , memoize ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = "4806" NEW_LINE print ( countDivBy6 ( s ) ) NEW_LINE DEDENT
def getMedian ( ar1 , ar2 , n ) : NEW_LINE INDENT i = 0 NEW_LINE j = 0 NEW_LINE m1 = - 1 NEW_LINE m2 = - 1 NEW_LINE count = 0 NEW_LINE while count < n + 1 : NEW_LINE INDENT count += 1 NEW_LINE if i == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ 0 ] NEW_LINE break NEW_LINE DEDENT elif j == n : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ 0 ] NEW_LINE break NEW_LINE DEDENT if ar1 [ i ] < ar2 [ j ] : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar1 [ i ] NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m1 = m2 NEW_LINE m2 = ar2 [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return ( m1 + m2 ) / 2 NEW_LINE DEDENT ar1 = [ 1 , 12 , 15 , 26 , 38 ] NEW_LINE ar2 = [ 2 , 13 , 17 , 30 , 45 ] NEW_LINE n1 = len ( ar1 ) NEW_LINE n2 = len ( ar2 ) NEW_LINE if n1 == n2 : NEW_LINE INDENT print ( " Median ▁ is ▁ " , getMedian ( ar1 , ar2 , n1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Doesn ' t ▁ work ▁ for ▁ arrays ▁ of ▁ unequal ▁ size " ) NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT class Trie : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . root = Node ( 0 ) NEW_LINE DEDENT def insert ( self , pre_xor ) : NEW_LINE INDENT self . temp = self . root NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT val = pre_xor & ( 1 << i ) NEW_LINE if val : NEW_LINE INDENT if not self . temp . right : NEW_LINE INDENT self . temp . right = Node ( 0 ) NEW_LINE DEDENT self . temp = self . temp . right NEW_LINE DEDENT if not val : NEW_LINE INDENT if not self . temp . left : NEW_LINE INDENT self . temp . left = Node ( 0 ) NEW_LINE DEDENT self . temp = self . temp . left NEW_LINE DEDENT DEDENT self . temp . data = pre_xor NEW_LINE DEDENT def query ( self , xor ) : NEW_LINE INDENT self . temp = self . root NEW_LINE for i in range ( 31 , - 1 , - 1 ) : NEW_LINE INDENT val = xor & ( 1 << i ) NEW_LINE if val : NEW_LINE INDENT if self . temp . left : NEW_LINE INDENT self . temp = self . temp . left NEW_LINE DEDENT elif self . temp . right : NEW_LINE INDENT self . temp = self . temp . right NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if self . temp . right : NEW_LINE INDENT self . temp = self . temp . right NEW_LINE DEDENT elif self . temp . left : NEW_LINE INDENT self . temp = self . temp . left NEW_LINE DEDENT DEDENT DEDENT return xor ^ self . temp . data NEW_LINE DEDENT def maxSubArrayXOR ( self , n , Arr ) : NEW_LINE INDENT self . insert ( 0 ) NEW_LINE result = - float ( ' inf ' ) NEW_LINE pre_xor = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT pre_xor = pre_xor ^ Arr [ i ] NEW_LINE self . insert ( pre_xor ) NEW_LINE result = max ( result , self . query ( pre_xor ) ) NEW_LINE DEDENT return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Arr = [ 8 , 1 , 2 , 12 ] NEW_LINE n = len ( Arr ) NEW_LINE trie = Trie ( ) NEW_LINE print ( trie . maxSubArrayXOR ( n , Arr ) ) NEW_LINE DEDENT
def minCost ( n , arr , cost ) : NEW_LINE INDENT Sum , totalCost = 0 , 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT totalCost += cost * Sum NEW_LINE arr [ n - 1 ] += Sum NEW_LINE totalCost += ( 2 * cost * arr [ n - 1 ] ) NEW_LINE return totalCost NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE cost = 1 NEW_LINE print ( minCost ( n , arr , cost ) ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head , data ) : NEW_LINE INDENT if not head : NEW_LINE INDENT return Node ( data ) NEW_LINE DEDENT new_node = Node ( data ) NEW_LINE new_node . next = head NEW_LINE head = new_node NEW_LINE return head NEW_LINE DEDENT def productOfNodes ( head ) : NEW_LINE INDENT ptr = head NEW_LINE product = 1 NEW_LINE while ( ptr ) : NEW_LINE INDENT product *= ptr . data NEW_LINE ptr = ptr . next NEW_LINE DEDENT return product NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 8 ) NEW_LINE head = push ( head , 4 ) NEW_LINE head = push ( head , 1 ) NEW_LINE print ( " Product ▁ = ▁ { } " . format ( productOfNodes ( head ) ) ) NEW_LINE DEDENT
def maxLength ( s , n ) : NEW_LINE INDENT dp = [ [ 0 for i in range ( n ) ] for i in range ( n ) ] NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' and s [ i + 1 ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ i + 1 ] = 2 NEW_LINE DEDENT DEDENT for l in range ( 2 , n ) : NEW_LINE INDENT i = - 1 NEW_LINE for j in range ( l , n ) : NEW_LINE INDENT i += 1 NEW_LINE if ( s [ i ] == ' ( ' and s [ j ] == ' ) ' ) : NEW_LINE INDENT dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] NEW_LINE DEDENT for k in range ( i , j ) : NEW_LINE INDENT dp [ i ] [ j ] = max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) NEW_LINE DEDENT DEDENT DEDENT return dp [ 0 ] [ n - 1 ] NEW_LINE DEDENT s = " ( ) ( ( ( ( ( ( ) " NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE
def processQueries ( Q , m , n ) : NEW_LINE INDENT a = [ 0 ] * ( m + 1 ) ; pos = [ 0 ] * ( m + 1 ) ; NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT a [ i - 1 ] = i ; NEW_LINE pos [ i ] = i - 1 ; NEW_LINE DEDENT ans = [ ] ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT q = Q [ i ] ; NEW_LINE p = pos [ q ] ; NEW_LINE ans . append ( p ) ; NEW_LINE for i in range ( p , 0 , - 1 ) : NEW_LINE INDENT a [ i ] , a [ i - 1 ] = a [ i - 1 ] , a [ i ] ; NEW_LINE pos [ a [ i ] ] = i ; NEW_LINE DEDENT pos [ a [ 0 ] ] = 0 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT Q = [ 3 , 1 , 2 , 1 ] ; NEW_LINE n = len ( Q ) ; NEW_LINE m = 5 ; NEW_LINE ans = [ ] ; NEW_LINE ans = processQueries ( Q , m , n ) ; NEW_LINE for i in range ( len ( ans ) ) : NEW_LINE INDENT print ( ans [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def countSubarrays ( a , n , x ) : NEW_LINE INDENT count = 0 NEW_LINE number = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE count = 0 NEW_LINE DEDENT DEDENT if ( count ) : NEW_LINE INDENT number += ( count ) * ( count + 1 ) / 2 NEW_LINE DEDENT return int ( number ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 ] NEW_LINE n = len ( a ) NEW_LINE k = 5 NEW_LINE print ( countSubarrays ( a , n , k ) ) NEW_LINE DEDENT
def findNthOccur ( string , ch , N ) : NEW_LINE INDENT occur = 0 ; NEW_LINE for i in range ( len ( string ) ) : NEW_LINE INDENT if ( string [ i ] == ch ) : NEW_LINE INDENT occur += 1 ; NEW_LINE DEDENT if ( occur == N ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeks " ; NEW_LINE ch = ' e ' ; NEW_LINE N = 2 ; NEW_LINE print ( findNthOccur ( string , ch , N ) ) ; NEW_LINE DEDENT
def isCommonBase ( base , s1 , s2 ) : NEW_LINE INDENT for j in range ( len ( s1 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT for j in range ( len ( s2 ) ) : NEW_LINE INDENT if ( base [ j % len ( base ) ] != s2 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def countCommonBases ( s1 , s2 ) : NEW_LINE INDENT n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE count = 0 NEW_LINE for i in range ( 1 , min ( n1 , n2 ) + 1 ) : NEW_LINE INDENT base = s1 [ 0 : i ] NEW_LINE if ( isCommonBase ( base , s1 , s2 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s1 = " pqrspqrs " NEW_LINE s2 = " pqrspqrspqrspqrs " NEW_LINE print ( countCommonBases ( s1 , s2 ) ) NEW_LINE DEDENT
def pow ( x , y ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT if ( y == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT temp = pow ( x , y // 2 ) NEW_LINE temp *= temp NEW_LINE if ( y & 1 ) : NEW_LINE INDENT temp *= x NEW_LINE DEDENT return temp NEW_LINE DEDENT def noOfPermutations ( a , n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT a . sort ( ) NEW_LINE if ( a [ n - 1 ] == a [ n - 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x = 0 NEW_LINE for i in range ( n - 2 ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 1 ] ) : NEW_LINE INDENT if ( a [ i ] == a [ i + 2 ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT x += 1 NEW_LINE i += 1 NEW_LINE DEDENT DEDENT return pow ( 2 , n - 2 * x - 1 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 2 , 2 , 3 , 4 ] NEW_LINE n = len ( a ) NEW_LINE num = noOfPermutations ( a , n ) NEW_LINE print ( num ) NEW_LINE DEDENT
def toggleBitsFromLToR ( n , l , r ) : NEW_LINE INDENT if ( r < l ) : NEW_LINE INDENT return n NEW_LINE DEDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE return ( n ^ num ) NEW_LINE DEDENT def smallNumWithNSetAndMUnsetBits ( n , m ) : NEW_LINE INDENT num = ( 1 << ( n + m ) ) - 1 NEW_LINE return toggleBitsFromLToR ( num , n , n + m - 1 ) ; NEW_LINE DEDENT n = 2 NEW_LINE m = 2 NEW_LINE ans = smallNumWithNSetAndMUnsetBits ( n , m ) NEW_LINE print ( ans ) NEW_LINE
from math import log10 NEW_LINE def generateNumbers ( m ) : NEW_LINE INDENT numbers = [ ] NEW_LINE for y in range ( 1 , 10 ) : NEW_LINE INDENT k_max = ( ( 10 ** ( m - 2 ) * ( 10 * y + 1 ) ) // ( 10 ** ( m - 1 ) + y ) ) NEW_LINE for k in range ( 1 , k_max + 1 ) : NEW_LINE INDENT x = ( ( y * ( 10 ** ( m - 1 ) - k ) ) // ( 10 * k - 1 ) ) NEW_LINE if ( ( y * ( 10 ** ( m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) : NEW_LINE INDENT numbers . append ( 10 * x + y ) NEW_LINE DEDENT DEDENT DEDENT for n in sorted ( numbers ) : NEW_LINE INDENT print ( n ) NEW_LINE DEDENT DEDENT m = 3 NEW_LINE generateNumbers ( m ) NEW_LINE
def arrange ( arr , n , x ) : NEW_LINE INDENT for i in range ( 1 , n ) : NEW_LINE INDENT diff = abs ( arr [ i ] - x ) NEW_LINE j = i - 1 NEW_LINE if ( abs ( arr [ j ] - x ) > diff ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE while ( abs ( arr [ j ] - x ) > diff and j >= 0 ) : NEW_LINE INDENT arr [ j + 1 ] = arr [ j ] NEW_LINE j -= 1 NEW_LINE DEDENT arr [ j + 1 ] = temp NEW_LINE DEDENT DEDENT DEDENT def print_1 ( arr , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 5 , 3 , 9 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE x = 7 NEW_LINE arrange ( arr , n , x ) NEW_LINE print_1 ( arr , n ) NEW_LINE DEDENT
def check ( s , m ) : NEW_LINE INDENT l = len ( s ) ; NEW_LINE c1 = 0 ; NEW_LINE c2 = 0 ; NEW_LINE for i in range ( 0 , l - 1 ) : NEW_LINE INDENT if ( s [ i ] == '0' ) : NEW_LINE INDENT c2 = 0 ; NEW_LINE c1 = c1 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT c1 = 0 ; NEW_LINE c2 = c2 + 1 ; NEW_LINE DEDENT if ( c1 == m or c2 == m ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT s = "001001" ; NEW_LINE m = 2 ; NEW_LINE if ( check ( s , m ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def maxOperations ( X , Y ) : NEW_LINE INDENT if ( X > Y ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT diff = Y - X ; NEW_LINE if ( diff == 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT if ( diff % 2 == 0 ) : NEW_LINE INDENT return ( diff // 2 ) ; NEW_LINE DEDENT return ( 1 + ( ( diff - 3 ) // 2 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT X = 5 ; Y = 16 ; NEW_LINE print ( maxOperations ( X , Y ) ) ; NEW_LINE DEDENT
def largestNum ( num ) : NEW_LINE INDENT num_to_str = list ( str ( num ) ) NEW_LINE temp = num_to_str [ : ] NEW_LINE for i in range ( len ( num_to_str ) ) : NEW_LINE INDENT for j in range ( i + 1 , len ( num_to_str ) ) : NEW_LINE INDENT // Swapping current pair NEW_LINE num_to_str [ i ] , num_to_str [ j ] = num_to_str [ j ] , num_to_str [ i ] NEW_LINE if num_to_str > temp : NEW_LINE INDENT temp = num_to_str [ : ] NEW_LINE DEDENT num_to_str [ i ] , num_to_str [ j ] = num_to_str [ j ] , num_to_str [ i ] NEW_LINE DEDENT DEDENT return int ( " " . join ( temp ) ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = int ( 432 ) NEW_LINE print ( largestNum ( A ) ) NEW_LINE A = int ( 2736 ) NEW_LINE print ( largestNum ( A ) ) NEW_LINE A = int ( 4596 ) NEW_LINE print ( largestNum ( A ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def checkPandigital ( b , n ) : NEW_LINE INDENT if ( len ( n ) < b ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT hash = [ 0 ] * b ; NEW_LINE for i in range ( len ( n ) ) : NEW_LINE INDENT if ( n [ i ] >= '0' and n [ i ] <= '9' ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( '0' ) ] = 1 ; NEW_LINE DEDENT elif ( ord ( n [ i ] ) - ord ( ' A ' ) <= b - 11 ) : NEW_LINE INDENT hash [ ord ( n [ i ] ) - ord ( ' A ' ) + 10 ] = 1 ; NEW_LINE DEDENT DEDENT for i in range ( b ) : NEW_LINE INDENT if ( hash [ i ] == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT b = 13 ; NEW_LINE n = "1298450376ABC " ; NEW_LINE if ( checkPandigital ( b , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
from math import pow NEW_LINE def __builtin_popcount ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while n > 0 : NEW_LINE INDENT if n % 2 == 1 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n // 2 NEW_LINE DEDENT return count NEW_LINE DEDENT def count_values ( n ) : NEW_LINE INDENT set_bits = __builtin_popcount ( n ) NEW_LINE print ( int ( pow ( 2 , set_bits ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 27 NEW_LINE count_values ( n ) NEW_LINE DEDENT
def oneDigit ( num ) : NEW_LINE INDENT return ( num >= 0 and num < 10 ) ; NEW_LINE DEDENT def isPalUtil ( num , dupNum ) : NEW_LINE INDENT if ( oneDigit ( num ) ) : NEW_LINE INDENT return ( num == ( dupNum ) % 10 ) ; NEW_LINE DEDENT if ( not isPalUtil ( int ( num / 10 ) , dupNum ) ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT dupNum = int ( dupNum / 10 ) ; NEW_LINE return ( num % 10 == ( dupNum ) % 10 ) ; NEW_LINE DEDENT def isPal ( num ) : NEW_LINE INDENT if ( num < 0 ) : NEW_LINE INDENT num = - num ; NEW_LINE DEDENT dupNum = num ; NEW_LINE return isPalUtil ( num , dupNum ) ; NEW_LINE DEDENT def printPalPrimesLessThanN ( n ) : NEW_LINE INDENT prime = [ True ] * ( n + 1 ) ; NEW_LINE p = 2 ; NEW_LINE while ( p * p <= n ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , n + 1 , p ) : NEW_LINE INDENT prime [ i ] = False ; NEW_LINE DEDENT DEDENT p += 1 ; NEW_LINE DEDENT for p in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ p ] and isPal ( p ) ) : NEW_LINE INDENT print ( p , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT n = 100 ; NEW_LINE print ( " Palindromic ▁ primes ▁ smaller " , " than ▁ or ▁ equal ▁ to " , n , " are ▁ : " ) ; NEW_LINE printPalPrimesLessThanN ( n ) ; NEW_LINE
import numpy as np NEW_LINE n = 6 ; m = 6 ; NEW_LINE def maxSum ( arr ) : NEW_LINE INDENT dp = np . zeros ( ( n + 1 , 3 ) ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT m1 = 0 ; m2 = 0 ; m3 = 0 ; NEW_LINE for j in range ( m ) : NEW_LINE INDENT if ( ( j // ( m // 3 ) ) == 0 ) : NEW_LINE INDENT m1 = max ( m1 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 1 ) : NEW_LINE INDENT m2 = max ( m2 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT elif ( ( j // ( m // 3 ) ) == 2 ) : NEW_LINE INDENT m3 = max ( m3 , arr [ i ] [ j ] ) ; NEW_LINE DEDENT DEDENT dp [ i + 1 ] [ 0 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; NEW_LINE dp [ i + 1 ] [ 1 ] = max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; NEW_LINE dp [ i + 1 ] [ 2 ] = max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; NEW_LINE DEDENT print ( max ( max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 6 , 4 , 5 , 1 , 3 , 2 ] , [ 1 , 3 , 5 , 2 , 4 , 6 ] ] ; NEW_LINE maxSum ( arr ) ; NEW_LINE DEDENT
from collections import defaultdict NEW_LINE import sys NEW_LINE def smallestKFreq ( arr , n , k ) : NEW_LINE INDENT mp = defaultdict ( lambda : 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT res = sys . maxsize NEW_LINE res1 = sys . maxsize NEW_LINE for key , values in mp . items ( ) : NEW_LINE INDENT if values == k : NEW_LINE INDENT res = min ( res , key ) NEW_LINE DEDENT DEDENT return res if res != res1 else - 1 NEW_LINE DEDENT arr = [ 2 , 2 , 1 , 3 , 1 ] NEW_LINE k = 2 NEW_LINE n = len ( arr ) NEW_LINE print ( smallestKFreq ( arr , n , k ) ) NEW_LINE
import math NEW_LINE def divSum ( n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 2 , ( int ) ( math . sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( i == ( n / i ) ) : NEW_LINE INDENT result = result + i NEW_LINE DEDENT else : NEW_LINE INDENT result = result + ( i + n // i ) NEW_LINE DEDENT DEDENT DEDENT return ( result + n + 1 ) NEW_LINE DEDENT n = 30 NEW_LINE print ( divSum ( n ) ) NEW_LINE
def NthCharacter ( n ) : NEW_LINE INDENT s = " " NEW_LINE c = 1 NEW_LINE while ( True ) : NEW_LINE INDENT if ( c < 10 ) : NEW_LINE INDENT s += chr ( 48 + c ) NEW_LINE DEDENT else : NEW_LINE INDENT s1 = " " NEW_LINE dup = c NEW_LINE while ( dup > 0 ) : NEW_LINE INDENT s1 += chr ( ( dup % 10 ) + 48 ) NEW_LINE dup //= 10 NEW_LINE DEDENT s1 = " " . join ( reversed ( s1 ) ) NEW_LINE s += s1 NEW_LINE DEDENT c += 1 NEW_LINE if ( len ( s ) >= n ) : NEW_LINE INDENT return s [ n - 1 ] NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 11 NEW_LINE print ( NthCharacter ( n ) ) NEW_LINE DEDENT
def MaxTotalRectangleArea ( a , n ) : NEW_LINE INDENT a . sort ( reverse = True ) NEW_LINE sum = 0 NEW_LINE flag = False NEW_LINE len = 0 NEW_LINE i = 0 NEW_LINE while ( i < n - 1 ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT if ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == False ) : NEW_LINE INDENT flag = True NEW_LINE len = a [ i + 1 ] NEW_LINE i = i + 1 NEW_LINE DEDENT elif ( ( a [ i ] == a [ i + 1 ] or a [ i ] - a [ i + 1 ] == 1 ) and flag == True ) : NEW_LINE INDENT sum = sum + a [ i + 1 ] * len NEW_LINE flag = False NEW_LINE i = i + 1 NEW_LINE DEDENT DEDENT return sum NEW_LINE DEDENT a = [ 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 ] NEW_LINE n = len ( a ) NEW_LINE print ( MaxTotalRectangleArea ( a , n ) ) NEW_LINE
def smallestIndexsum ( arr , n ) : NEW_LINE INDENT i = n - 1 ; NEW_LINE while ( i >= 0 and arr [ i ] % 2 == 1 ) : NEW_LINE INDENT i -= 1 ; NEW_LINE DEDENT sum = 0 ; NEW_LINE for j in range ( 0 , i + 1 ) : NEW_LINE INDENT sum += arr [ j ] ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 2 , 3 , 5 , 6 , 3 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( smallestIndexsum ( arr , n ) ) ; NEW_LINE DEDENT
def bitwiseAndOdd ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( 3 , n + 1 , 2 ) : NEW_LINE INDENT result = ( result & i ) ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 10 ; NEW_LINE print ( bitwiseAndOdd ( n ) ) ; NEW_LINE DEDENT
def sn ( n , an ) : NEW_LINE INDENT return ( n * ( 1 + an ) ) / 2 ; NEW_LINE DEDENT def trace ( n , m ) : NEW_LINE INDENT an = 1 + ( n - 1 ) * ( m + 1 ) ; NEW_LINE rowmajorSum = sn ( n , an ) ; NEW_LINE an = 1 + ( n - 1 ) * ( n + 1 ) ; NEW_LINE colmajorSum = sn ( n , an ) ; NEW_LINE return int ( rowmajorSum + colmajorSum ) ; NEW_LINE DEDENT N = 3 ; NEW_LINE M = 3 ; NEW_LINE print ( trace ( N , M ) ) ; NEW_LINE
def allBitsSetInTheGivenRange ( n , l , r ) : NEW_LINE INDENT num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) NEW_LINE new_num = n & num NEW_LINE if ( new_num == 0 ) : NEW_LINE INDENT return " Yes " NEW_LINE DEDENT return " No " NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 17 NEW_LINE l = 2 NEW_LINE r = 4 NEW_LINE print ( allBitsSetInTheGivenRange ( n , l , r ) ) NEW_LINE DEDENT
def findEqualPoint ( arr , n ) : NEW_LINE INDENT distArr = [ 0 ] * n NEW_LINE i = 0 NEW_LINE di = 0 NEW_LINE while ( i < n ) : NEW_LINE INDENT distArr [ di ] = i NEW_LINE di += 1 NEW_LINE i += 1 NEW_LINE while ( i < n and arr [ i ] == arr [ i - 1 ] ) : NEW_LINE INDENT i += 1 NEW_LINE DEDENT DEDENT return distArr [ di >> 1 ] if ( di & 1 ) else - 1 NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 4 , 5 , 6 , 6 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE index = findEqualPoint ( arr , n ) NEW_LINE if ( index != - 1 ) : NEW_LINE INDENT print ( " Equal ▁ Point ▁ = ▁ " , arr [ index ] ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Equal ▁ Point ▁ does ▁ " + " not ▁ exists " ) NEW_LINE DEDENT
M = 3 ; N = 3 ; NEW_LINE def reverseArray ( arr ) : NEW_LINE INDENT for i in range ( M ) : NEW_LINE INDENT start = 0 ; NEW_LINE end = N - 1 ; NEW_LINE while ( start < end ) : NEW_LINE INDENT arr [ i ] [ start ] , arr [ i ] [ end ] = arr [ i ] [ end ] , arr [ i ] [ start ] ; NEW_LINE start += 1 ; NEW_LINE end -= 1 ; NEW_LINE DEDENT DEDENT for i in range ( M ) : NEW_LINE INDENT for j in range ( N ) : NEW_LINE INDENT print ( arr [ i ] [ j ] , end = ' ▁ ' ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ [ 1 , 2 , 3 ] , [ 4 , 5 , 6 ] , [ 7 , 8 , 9 ] ] ; NEW_LINE reverseArray ( arr ) ; NEW_LINE DEDENT
def printAllSubsetsRec ( arr , n , v , sum ) : NEW_LINE INDENT if ( sum == 0 ) : NEW_LINE INDENT for value in v : NEW_LINE INDENT print ( value , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE return NEW_LINE DEDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT printAllSubsetsRec ( arr , n - 1 , v , sum ) NEW_LINE v1 = [ ] + v NEW_LINE v1 . append ( arr [ n - 1 ] ) NEW_LINE printAllSubsetsRec ( arr , n - 1 , v1 , sum - arr [ n - 1 ] ) NEW_LINE DEDENT def printAllSubsets ( arr , n , sum ) : NEW_LINE INDENT v = [ ] NEW_LINE printAllSubsetsRec ( arr , n , v , sum ) NEW_LINE DEDENT arr = [ 2 , 5 , 8 , 4 , 6 , 11 ] NEW_LINE sum = 13 NEW_LINE n = len ( arr ) NEW_LINE printAllSubsets ( arr , n , sum ) NEW_LINE
bin = [ "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" ] ; NEW_LINE def maxFreq ( s ) : NEW_LINE INDENT binary = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT binary += bin [ ord ( s [ i ] ) - ord ( '0' ) ] ; NEW_LINE DEDENT binary = binary [ 0 : len ( binary ) - 1 ] ; NEW_LINE count = 1 ; prev = - 1 ; j = 0 ; NEW_LINE for i in range ( len ( binary ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( binary [ i ] == '1' ) : NEW_LINE INDENT count = max ( count , j - prev ) ; NEW_LINE prev = j ; NEW_LINE DEDENT j += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT octal = "13" ; NEW_LINE print ( maxFreq ( octal ) ) ; NEW_LINE DEDENT
from queue import PriorityQueue NEW_LINE MAX_CHAR = 26 NEW_LINE def minStringValue ( str , k ) : NEW_LINE INDENT l = len ( str ) NEW_LINE if ( k >= l ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT frequency = [ 0 ] * MAX_CHAR NEW_LINE for i in range ( 0 , l ) : NEW_LINE INDENT frequency [ ord ( str [ i ] ) - 97 ] += 1 NEW_LINE DEDENT q = PriorityQueue ( ) NEW_LINE for i in range ( 0 , MAX_CHAR ) : NEW_LINE INDENT q . put ( - frequency [ i ] ) NEW_LINE DEDENT while ( k > 0 ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp + 1 NEW_LINE q . put ( temp , temp ) NEW_LINE k = k - 1 NEW_LINE DEDENT result = 0 ; NEW_LINE while not q . empty ( ) : NEW_LINE INDENT temp = q . get ( ) NEW_LINE temp = temp * ( - 1 ) NEW_LINE result += temp * temp NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " abbccc " NEW_LINE k = 2 NEW_LINE print ( minStringValue ( str , k ) ) NEW_LINE str = " aaab " NEW_LINE k = 2 NEW_LINE print ( minStringValue ( str , k ) ) NEW_LINE DEDENT
def isHeap ( arr , i , n ) : NEW_LINE INDENT if i > int ( ( n - 2 ) / 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( arr [ i ] >= arr [ 2 * i + 1 ] and arr [ i ] >= arr [ 2 * i + 2 ] and isHeap ( arr , 2 * i + 1 , n ) and isHeap ( arr , 2 * i + 2 , n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 ] NEW_LINE n = len ( arr ) - 1 NEW_LINE if isHeap ( arr , 0 , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def fibonacci ( n ) : NEW_LINE INDENT a = 0 NEW_LINE b = 1 NEW_LINE if ( n <= 1 ) : NEW_LINE INDENT return n NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return c NEW_LINE DEDENT def isMultipleOf10 ( n ) : NEW_LINE INDENT f = fibonacci ( 30 ) NEW_LINE return ( f % 10 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 30 NEW_LINE if ( isMultipleOf10 ( n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 0 , n ) : NEW_LINE INDENT for i in range ( 0 , line + 1 ) : NEW_LINE INDENT print ( binomialCoeff ( line , i ) , " ▁ " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k NEW_LINE DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT res = res * ( n - i ) NEW_LINE res = res // ( i + 1 ) NEW_LINE DEDENT return res NEW_LINE DEDENT n = 7 NEW_LINE printPascal ( n ) NEW_LINE
def findSum ( n ) : NEW_LINE INDENT n -= 1 NEW_LINE sum = 0 NEW_LINE sum += ( n * ( n + 1 ) ) / 2 NEW_LINE sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 NEW_LINE return int ( sum ) NEW_LINE DEDENT n = 3 NEW_LINE print ( findSum ( n ) ) NEW_LINE
NO_OF_CHARS = 256 NEW_LINE def canFormPalindrome ( st ) : NEW_LINE INDENT count = [ 0 ] * ( NO_OF_CHARS ) NEW_LINE for i in range ( 0 , len ( st ) ) : NEW_LINE INDENT count [ ord ( st [ i ] ) ] = count [ ord ( st [ i ] ) ] + 1 NEW_LINE DEDENT odd = 0 NEW_LINE for i in range ( 0 , NO_OF_CHARS ) : NEW_LINE INDENT if ( count [ i ] & 1 ) : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT if ( odd > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if ( canFormPalindrome ( " geeksforgeeks " ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT if ( canFormPalindrome ( " geeksogeeks " ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def nthTerm ( N ) : NEW_LINE INDENT nth = 0 ; first_term = 12 ; NEW_LINE nth = ( first_term * ( pow ( 2 , N - 1 ) ) ) +   \ NEW_LINE INDENT 11 * ( ( pow ( 2 , N - 1 ) ) - 1 ) ; NEW_LINE DEDENT return nth ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 5 ; NEW_LINE print ( nthTerm ( N ) ) ; NEW_LINE DEDENT
def Arrive ( a , b , n ) : NEW_LINE INDENT if ( n >= abs ( a ) + abs ( b ) and ( n - ( abs ( a ) + abs ( b ) ) ) % 2 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT a = 5 NEW_LINE b = 5 NEW_LINE n = 11 NEW_LINE if ( Arrive ( a , b , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def A ( m , n , s = " % ▁ s " ) : NEW_LINE INDENT print ( s % ( " A ( % ▁ d , ▁ % ▁ d ) " % ( m , n ) ) ) NEW_LINE if m == 0 : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT if n == 0 : NEW_LINE INDENT return A ( m - 1 , 1 , s ) NEW_LINE DEDENT n2 = A ( m , n - 1 , s % ( " A ( % ▁ d , ▁ % % ▁ s ) " % ( m - 1 ) ) ) NEW_LINE return A ( m - 1 , n2 , s ) NEW_LINE DEDENT print ( A ( 1 , 2 ) ) NEW_LINE
def findCost ( str , arr , n ) : NEW_LINE INDENT costofC , costofO = 0 , 0 NEW_LINE costofD , costofE = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ' c ' ) : NEW_LINE INDENT costofC += arr [ i ] NEW_LINE DEDENT elif ( str [ i ] == ' o ' ) : NEW_LINE INDENT costofO = min ( costofC , costofO + arr [ i ] ) NEW_LINE DEDENT elif ( str [ i ] == ' d ' ) : NEW_LINE INDENT costofD = min ( costofO , costofD + arr [ i ] ) NEW_LINE DEDENT elif ( str [ i ] == ' e ' ) : NEW_LINE INDENT costofE = min ( costofD , costofE + arr [ i ] ) NEW_LINE DEDENT DEDENT return costofE NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = " geekcodergeeks " NEW_LINE arr = [ 1 , 2 , 1 , 3 , 4 , 2 , 6 , 4 , 6 , 2 , 3 , 3 , 3 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findCost ( str , arr , n ) ) NEW_LINE DEDENT
from sys import maxint NEW_LINE def maxSubArraySum ( a , size ) : NEW_LINE INDENT max_so_far = - maxint - 1 NEW_LINE max_ending_here = 0 NEW_LINE for i in range ( 0 , size ) : NEW_LINE INDENT max_ending_here = max_ending_here + a [ i ] NEW_LINE if ( max_so_far < max_ending_here ) : NEW_LINE INDENT max_so_far = max_ending_here NEW_LINE DEDENT if max_ending_here < 0 : NEW_LINE INDENT max_ending_here = 0 NEW_LINE DEDENT DEDENT return max_so_far NEW_LINE DEDENT a = [ - 13 , - 3 , - 25 , - 20 , - 3 , - 16 , - 23 , - 12 , - 5 , - 22 , - 15 , - 4 , - 7 ] NEW_LINE print " Maximum ▁ contiguous ▁ sum ▁ is " , maxSubArraySum ( a , len ( a ) ) NEW_LINE
def factorial ( a , b ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 1 , a + b + 1 ) : NEW_LINE INDENT res = res * i NEW_LINE DEDENT for i in range ( 1 , a + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT for i in range ( 1 , b + 1 ) : NEW_LINE INDENT res = res // i NEW_LINE DEDENT return res NEW_LINE DEDENT def Ksmallest ( x , y , k ) : NEW_LINE INDENT if x == 0 and y == 0 : NEW_LINE INDENT return NEW_LINE DEDENT elif x == 0 : NEW_LINE INDENT y -= 1 NEW_LINE print ( " V " , end = " " ) NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT elif y == 0 : NEW_LINE INDENT x -= 1 NEW_LINE print ( " H " , end = " " ) NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT else : NEW_LINE INDENT if factorial ( x - 1 , y ) > k : NEW_LINE INDENT print ( " H " , end = " " ) NEW_LINE Ksmallest ( x - 1 , y , k ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " V " , end = " " ) NEW_LINE Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x , y , k = 2 , 2 , 2 NEW_LINE Ksmallest ( x , y , k ) NEW_LINE DEDENT
def MaxIncreasingSub ( arr , n , k ) : NEW_LINE INDENT dp = [ - 1 ] * n NEW_LINE ans = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT dp [ i ] = [ - 1 ] * ( k + 1 ) NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ 1 ] = arr [ i ] NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT for j in range ( i ) : NEW_LINE INDENT if arr [ j ] < arr [ i ] : NEW_LINE INDENT for l in range ( 1 , k ) : NEW_LINE INDENT if dp [ j ] [ l ] != - 1 : NEW_LINE INDENT dp [ i ] [ l + 1 ] = max ( dp [ i ] [ l + 1 ] , dp [ j ] [ l ] + arr [ i ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ans < dp [ i ] [ k ] : NEW_LINE INDENT ans = dp [ i ] [ k ] NEW_LINE DEDENT DEDENT return ( 0 if ans == - 1 else ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 8 , 3 NEW_LINE arr = [ 8 , 5 , 9 , 10 , 5 , 6 , 21 , 8 ] NEW_LINE ans = MaxIncreasingSub ( arr , n , k ) NEW_LINE print ( ans ) NEW_LINE DEDENT
def max_xor ( arr , n ) : NEW_LINE INDENT maxXor = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT maxXor = max ( maxXor , \ arr [ i ] ^ arr [ j ] ) ; NEW_LINE DEDENT DEDENT return maxXor ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 25 , 10 , 2 , 8 , 5 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( max_xor ( arr , n ) ) ; NEW_LINE DEDENT
def countAnomalies ( arr , n , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE i , Sum = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT Sum += arr [ i ] NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( abs ( arr [ i ] - ( Sum - arr [ i ] ) ) > k ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE k = 1 NEW_LINE print ( countAnomalies ( arr , n , k ) ) NEW_LINE
def cntWays ( string , n ) : NEW_LINE INDENT x = n + 1 ; NEW_LINE ways = x * x * ( x * x - 1 ) // 12 ; NEW_LINE return ways ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " ab " ; NEW_LINE n = len ( string ) ; NEW_LINE print ( cntWays ( string , n ) ) ; NEW_LINE DEDENT
def divisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += int ( n / i ) * i NEW_LINE DEDENT return int ( sum ) NEW_LINE DEDENT n = 4 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( divisorSum ( n ) ) NEW_LINE
def printString ( Str1 , n ) : NEW_LINE INDENT ones = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '1' ) : NEW_LINE INDENT ones += 1 NEW_LINE DEDENT DEDENT used = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( Str1 [ i ] == '2' and used == False ) : NEW_LINE INDENT used = 1 NEW_LINE for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT DEDENT if ( Str1 [ i ] != '1' ) : NEW_LINE INDENT print ( Str1 [ i ] , end = " " ) NEW_LINE DEDENT DEDENT if ( used == False ) : NEW_LINE INDENT for j in range ( ones ) : NEW_LINE INDENT print ( "1" , end = " " ) NEW_LINE DEDENT DEDENT DEDENT Str1 = "100210" NEW_LINE n = len ( Str1 ) NEW_LINE printString ( Str1 , n ) NEW_LINE
import math NEW_LINE def bitAtGivenPosSetOrUnset ( n , k ) : NEW_LINE INDENT new_num = n >> ( k - 1 ) NEW_LINE return ( new_num & 1 ) NEW_LINE DEDENT n = 10 NEW_LINE k = 2 NEW_LINE if ( bitAtGivenPosSetOrUnset ( n , k ) ) : NEW_LINE INDENT print ( " Set " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Unset " ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def commonWords ( S ) : NEW_LINE INDENT has = defaultdict ( lambda : False ) NEW_LINE ans = [ ] NEW_LINE m = len ( S ) NEW_LINE i = 0 NEW_LINE while i < len ( S [ 0 ] ) : NEW_LINE INDENT string = " " NEW_LINE while i < len ( S [ 0 ] ) and S [ 0 ] [ i ] != ' ▁ ' : NEW_LINE INDENT string += S [ 0 ] [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE if string != " " : NEW_LINE INDENT ans . append ( [ string , True ] ) NEW_LINE DEDENT DEDENT for j in range ( 1 , m ) : NEW_LINE INDENT has . clear ( ) NEW_LINE i = 0 NEW_LINE while i < len ( S [ j ] ) : NEW_LINE INDENT string = " " NEW_LINE while i < len ( S [ j ] ) and S [ j ] [ i ] != ' ▁ ' : NEW_LINE INDENT string += S [ j ] [ i ] NEW_LINE i += 1 NEW_LINE DEDENT i += 1 NEW_LINE if string != " " : NEW_LINE INDENT has [ string ] = True NEW_LINE DEDENT DEDENT for k in range ( 0 , len ( ans ) ) : NEW_LINE INDENT if ( ans [ k ] [ 1 ] != False and has [ ans [ k ] [ 0 ] ] == False ) : NEW_LINE INDENT ans [ k ] [ 1 ] = False NEW_LINE DEDENT elif ( ans [ k ] [ 1 ] != False and has [ ans [ k ] [ 0 ] ] == True ) : NEW_LINE INDENT has [ ans [ k ] [ 0 ] ] = False NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for k in range ( 0 , len ( ans ) ) : NEW_LINE INDENT if ans [ k ] [ 1 ] == True : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT S = [ ] NEW_LINE S . append ( " there ▁ is ▁ a ▁ cow " ) NEW_LINE S . append ( " cow ▁ is ▁ our ▁ mother " ) NEW_LINE S . append ( " cow ▁ gives ▁ us ▁ milk ▁ and ▁ milk ▁ is ▁ sweet " ) NEW_LINE S . append ( " there ▁ is ▁ a ▁ boy ▁ who ▁ loves ▁ cow " ) NEW_LINE print ( commonWords ( S ) ) NEW_LINE DEDENT
def circlearea ( a ) : NEW_LINE INDENT if a < 0 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( 3.14 * 3 * pow ( a , 2 ) ) / 4 NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 NEW_LINE print ( circlearea ( a ) ) NEW_LINE DEDENT
def checkTypeOfTriangle ( a , b , c ) : NEW_LINE INDENT sqa = pow ( a , 2 ) NEW_LINE sqb = pow ( b , 2 ) NEW_LINE sqc = pow ( c , 2 ) NEW_LINE if ( sqa == sqa + sqb or sqb == sqa + sqc or sqc == sqa + sqb ) : NEW_LINE INDENT print ( " Right - angled ▁ Triangle " ) NEW_LINE DEDENT elif ( sqa > sqc + sqb or sqb > sqa + sqc or sqc > sqa + sqb ) : NEW_LINE INDENT print ( " Obtuse - angled ▁ Triangle " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Acute - angled ▁ Triangle " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 2 NEW_LINE b = 2 NEW_LINE c = 2 NEW_LINE checkTypeOfTriangle ( a , b , c ) NEW_LINE DEDENT
def cubeSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT sum += ( 2 * i + 1 ) * ( 2 * i + 1 ) * ( 2 * i + 1 ) NEW_LINE DEDENT return sum NEW_LINE DEDENT print ( cubeSum ( 2 ) ) NEW_LINE
def multiply ( F , M ) : NEW_LINE INDENT x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] NEW_LINE w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] NEW_LINE F [ 0 ] [ 0 ] = x NEW_LINE F [ 0 ] [ 1 ] = y NEW_LINE F [ 1 ] [ 0 ] = z NEW_LINE F [ 1 ] [ 1 ] = w NEW_LINE DEDENT def power ( F , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return NEW_LINE DEDENT M = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE power ( F , n // 2 ) NEW_LINE multiply ( F , F ) NEW_LINE if ( n % 2 != 0 ) : NEW_LINE INDENT multiply ( F , M ) NEW_LINE DEDENT DEDENT def countWays ( n ) : NEW_LINE INDENT F = [ [ 1 , 1 ] , [ 1 , 0 ] ] NEW_LINE if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT power ( F , n ) NEW_LINE return F [ 0 ] [ 0 ] NEW_LINE DEDENT n = 5 NEW_LINE print ( countWays ( n ) ) NEW_LINE
def answer ( n ) : NEW_LINE INDENT dp = [ 0 ] * 10 NEW_LINE prev = [ 0 ] * 10 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 10 NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT dp [ j ] = 1 NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT prev [ j ] = dp [ j ] NEW_LINE DEDENT for j in range ( 0 , 10 ) : NEW_LINE INDENT if ( j == 0 ) : NEW_LINE INDENT dp [ j ] = prev [ j + 1 ] NEW_LINE DEDENT elif ( j == 9 ) : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] NEW_LINE DEDENT DEDENT DEDENT sum = 0 NEW_LINE for j in range ( 1 , 10 ) : NEW_LINE INDENT sum = sum + dp [ j ] NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 2 NEW_LINE print ( answer ( n ) ) NEW_LINE
PHI = 1.6180339 NEW_LINE f = [ 0 , 1 , 1 , 2 , 3 , 5 ] NEW_LINE def fib ( n ) : NEW_LINE INDENT if n < 6 : NEW_LINE INDENT return f [ n ] NEW_LINE DEDENT t = 5 NEW_LINE fn = 5 NEW_LINE while t < n : NEW_LINE INDENT fn = round ( fn * PHI ) NEW_LINE t += 1 NEW_LINE DEDENT return fn NEW_LINE DEDENT n = 9 NEW_LINE print ( n , " th ▁ Fibonacci ▁ Number ▁ = " , fib ( n ) ) NEW_LINE
def printHutStar ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT for j in range ( 0 , 2 * i + 1 ) : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( 3 ) : NEW_LINE INDENT for j in range ( 3 ) : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT for j in range ( 2 * n - 7 ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT for j in range ( 3 ) : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT n = 7 NEW_LINE printHutStar ( n ) NEW_LINE
import math NEW_LINE def Modulo ( a , b ) : NEW_LINE INDENT mod = 0 NEW_LINE for i in range ( 0 , len ( b ) ) : NEW_LINE INDENT mod = ( mod * 10 + ( int ) ( b [ i ] ) ) % a NEW_LINE DEDENT return mod NEW_LINE DEDENT def LastDigit ( a , b ) : NEW_LINE INDENT len_a = len ( a ) NEW_LINE len_b = len ( b ) NEW_LINE if ( len_a == 1 and len_b == 1 and b [ 0 ] == '0' and a [ 0 ] == '0' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( len_b == 1 and b [ 0 ] == '0' ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( len_a == 1 and a [ 0 ] == '0' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( ( Modulo ( 4 , b ) == 0 ) ) : NEW_LINE INDENT exp = 4 NEW_LINE DEDENT else : NEW_LINE INDENT exp = Modulo ( 4 , b ) NEW_LINE DEDENT res = math . pow ( ( int ) ( a [ len_a - 1 ] ) , exp ) NEW_LINE return res % 10 NEW_LINE DEDENT a = [ '1' , '1' , '7' ] NEW_LINE b = [ '3' ] NEW_LINE print ( LastDigit ( a , b ) ) NEW_LINE
import random NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 ; NEW_LINE x = x % p ; NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p ; NEW_LINE DEDENT y = y >> 1 ; NEW_LINE x = ( x * x ) % p ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT def miillerTest ( d , n ) : NEW_LINE INDENT a = 2 + random . randint ( 1 , n - 4 ) ; NEW_LINE x = power ( a , d , n ) ; NEW_LINE if ( x == 1 or x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT while ( d != n - 1 ) : NEW_LINE INDENT x = ( x * x ) % n ; NEW_LINE d *= 2 ; NEW_LINE if ( x == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( x == n - 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT return False ; NEW_LINE DEDENT def isPrime ( n , k ) : NEW_LINE INDENT if ( n <= 1 or n == 4 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT d = n - 1 ; NEW_LINE while ( d % 2 == 0 ) : NEW_LINE INDENT d //= 2 ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT if ( miillerTest ( d , n ) == False ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT k = 4 ; NEW_LINE print ( " All ▁ primes ▁ smaller ▁ than ▁ 100 : ▁ " ) ; NEW_LINE for n in range ( 1 , 100 ) : NEW_LINE INDENT if ( isPrime ( n , k ) ) : NEW_LINE INDENT print ( n , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT
def remainderWith7 ( num ) : NEW_LINE INDENT series = [ 1 , 3 , 2 , - 1 , - 3 , - 2 ] ; NEW_LINE series_index = 0 ; NEW_LINE result = 0 ; NEW_LINE for i in range ( ( len ( num ) - 1 ) , - 1 , - 1 ) : NEW_LINE INDENT digit = ord ( num [ i ] ) - 48 ; NEW_LINE result += digit * series [ series_index ] ; NEW_LINE series_index = ( series_index + 1 ) % 6 ; NEW_LINE result %= 7 ; NEW_LINE DEDENT if ( result < 0 ) : NEW_LINE INDENT result = ( result + 7 ) % 7 ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT str = "12345" ; NEW_LINE print ( " Remainder ▁ with ▁ 7 ▁ is " , remainderWith7 ( str ) ) ; NEW_LINE
def nthTerm ( n ) : NEW_LINE INDENT return ( n * n ) + ( n * n * n ) NEW_LINE DEDENT n = 4 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE
from math import sqrt NEW_LINE def findTriplets ( x ) : NEW_LINE INDENT fact = [ ] ; NEW_LINE factors = set ( ) ; NEW_LINE for i in range ( 2 , int ( sqrt ( x ) ) ) : NEW_LINE INDENT if ( x % i == 0 ) : NEW_LINE INDENT fact . append ( i ) ; NEW_LINE if ( x / i != i ) : NEW_LINE INDENT fact . append ( x // i ) ; NEW_LINE DEDENT factors . add ( i ) ; NEW_LINE factors . add ( x // i ) ; NEW_LINE DEDENT DEDENT found = False ; NEW_LINE k = len ( fact ) ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT a = fact [ i ] ; NEW_LINE for j in range ( k ) : NEW_LINE INDENT b = fact [ j ] ; NEW_LINE if ( ( a != b ) and ( x % ( a * b ) == 0 ) and ( x / ( a * b ) != a ) and ( x / ( a * b ) != b ) and ( x / ( a * b ) != 1 ) ) : NEW_LINE INDENT print ( a , b , x // ( a * b ) ) ; NEW_LINE found = True ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( found ) : NEW_LINE INDENT break ; NEW_LINE DEDENT DEDENT if ( not found ) : NEW_LINE INDENT print ( " - 1" ) ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 105 ; NEW_LINE findTriplets ( x ) ; NEW_LINE DEDENT
def unique_combination ( l , sum , K , local , A ) : NEW_LINE INDENT if ( sum == K ) : NEW_LINE INDENT print ( " { " , end = " " ) NEW_LINE for i in range ( len ( local ) ) : NEW_LINE INDENT if ( i != 0 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT print ( local [ i ] , end = " " ) NEW_LINE if ( i != len ( local ) - 1 ) : NEW_LINE INDENT print ( " , ▁ " , end = " " ) NEW_LINE DEDENT DEDENT print ( " } " ) NEW_LINE return NEW_LINE DEDENT for i in range ( l , len ( A ) , 1 ) : NEW_LINE INDENT if ( sum + A [ i ] > K ) : NEW_LINE INDENT continue NEW_LINE DEDENT if ( i == 1 and A [ i ] == A [ i - 1 ] and i > l ) : NEW_LINE INDENT continue NEW_LINE DEDENT local . append ( A [ i ] ) NEW_LINE unique_combination ( i + 1 , sum + A [ i ] , K , local , A ) NEW_LINE local . remove ( local [ len ( local ) - 1 ] ) NEW_LINE DEDENT DEDENT def Combination ( A , K ) : NEW_LINE INDENT A . sort ( reverse = False ) NEW_LINE local = [ ] NEW_LINE unique_combination ( 0 , 0 , K , local , A ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = [ 10 , 1 , 2 , 7 , 6 , 1 , 5 ] NEW_LINE K = 8 NEW_LINE Combination ( A , K ) NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT mn = + 2147483647 NEW_LINE mx = - 2147483648 NEW_LINE for i in range ( n ) : NEW_LINE INDENT mn = min ( mn , a [ i ] ) NEW_LINE mx = max ( mx , a [ i ] ) NEW_LINE DEDENT c1 = 0 NEW_LINE c2 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == mn ) : NEW_LINE INDENT c1 += 1 NEW_LINE DEDENT if ( a [ i ] == mx ) : NEW_LINE INDENT c2 += 1 NEW_LINE DEDENT DEDENT if ( mn == mx ) : NEW_LINE INDENT return n * ( n - 1 ) // 2 NEW_LINE DEDENT else : NEW_LINE INDENT return c1 * c2 NEW_LINE DEDENT DEDENT a = [ 3 , 2 , 1 , 1 , 3 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n ) ) NEW_LINE
def lps ( str ) : NEW_LINE INDENT n = len ( str ) NEW_LINE L = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT L [ i ] [ i ] = 1 NEW_LINE DEDENT for cl in range ( 2 , n + 1 ) : NEW_LINE INDENT for i in range ( n - cl + 1 ) : NEW_LINE INDENT j = i + cl - 1 NEW_LINE if str [ i ] == str [ j ] and cl == 2 : NEW_LINE INDENT L [ i ] [ j ] = 2 NEW_LINE DEDENT elif str [ i ] == str [ j ] : NEW_LINE INDENT L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; NEW_LINE DEDENT DEDENT DEDENT return L [ 0 ] [ n - 1 ] NEW_LINE DEDENT seq = " GEEKS ▁ FOR ▁ GEEKS " NEW_LINE n = len ( seq ) NEW_LINE print ( " The ▁ length ▁ of ▁ the ▁ LPS ▁ is ▁ " + str ( lps ( seq ) ) ) NEW_LINE
def lenDoubleString ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE first_half = s [ 0 : l // 2 ] NEW_LINE second_half = " " NEW_LINE if l % 2 == 0 : NEW_LINE INDENT second_half = s [ l // 2 : ] NEW_LINE DEDENT else : NEW_LINE INDENT second_half = s [ l // 2 + 1 : ] NEW_LINE DEDENT second_half = second_half [ : : - 1 ] NEW_LINE print ( first_half + second_half ) NEW_LINE if l % 2 == 0 : NEW_LINE INDENT print ( l ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( l - 1 ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = " abba " NEW_LINE lenDoubleString ( n ) NEW_LINE n = " abcdedcba " NEW_LINE lenDoubleString ( n ) NEW_LINE DEDENT
def factorial ( n ) : NEW_LINE INDENT fact = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return fact NEW_LINE DEDENT def ncr ( n , r ) : NEW_LINE INDENT return ( factorial ( n ) // ( factorial ( r ) * factorial ( n - r ) ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 3 NEW_LINE n = 4 NEW_LINE k = 5 NEW_LINE totalTriangles = ( ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ) NEW_LINE print ( totalTriangles ) NEW_LINE DEDENT
def isEven ( n ) : NEW_LINE INDENT if ( n ^ 1 == n + 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 100 ; NEW_LINE print ( " Even " ) if isEven ( n ) else print ( " Odd " ) ; NEW_LINE DEDENT
def printArr ( arr , n ) : NEW_LINE INDENT for i in arr : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT def generateArr ( A , n ) : NEW_LINE INDENT B = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for j in range ( i ) : NEW_LINE INDENT if ( A [ j ] % A [ i ] == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT B [ i ] = cnt NEW_LINE DEDENT printArr ( B , n ) NEW_LINE DEDENT A = [ 3 , 5 , 1 ] NEW_LINE n = len ( A ) NEW_LINE generateArr ( A , n ) NEW_LINE
def minXOR ( arr , n ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE min_xor = 999999 NEW_LINE val = 0 NEW_LINE for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n - 1 ) : NEW_LINE INDENT val = arr [ i ] ^ arr [ j ] NEW_LINE min_xor = min ( min_xor , val ) NEW_LINE DEDENT DEDENT return min_xor NEW_LINE DEDENT arr = [ 9 , 5 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minXOR ( arr , n ) ) NEW_LINE
def isPowerOfTwo ( x ) : NEW_LINE INDENT return ( x and ( not ( x & ( x - 1 ) ) ) ) NEW_LINE DEDENT if ( isPowerOfTwo ( 31 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT if ( isPowerOfTwo ( 64 ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def areAllBitsSet ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT while ( n > 0 ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT return " No " NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return " Yes " NEW_LINE DEDENT n = 7 NEW_LINE print ( areAllBitsSet ( n ) ) NEW_LINE
def findevenPair ( A , N ) : NEW_LINE INDENT evenPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) : NEW_LINE INDENT evenPair += 1 NEW_LINE DEDENT DEDENT DEDENT return evenPair NEW_LINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( findevenPair ( a , n ) ) NEW_LINE
def countTriplets ( n , points ) : NEW_LINE INDENT pts = [ ] NEW_LINE ct = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT pts . append ( points [ i ] ) ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT x = points [ i ] [ 0 ] + points [ j ] [ 0 ] ; NEW_LINE y = points [ i ] [ 1 ] + points [ j ] [ 1 ] ; NEW_LINE if ( x % 2 == 0 and y % 2 == 0 ) : NEW_LINE INDENT if [ x // 2 , y // 2 ] in pts : NEW_LINE INDENT ct += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return ct NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT points = [ [ 1 , 1 ] , [ 2 , 2 ] , [ 3 , 3 ] ] NEW_LINE n = len ( points ) NEW_LINE print ( countTriplets ( n , points ) ) NEW_LINE DEDENT
def printTwoOdd ( arr , size ) : NEW_LINE INDENT xor2 = arr [ 0 ] NEW_LINE set_bit_no = 0 NEW_LINE n = size - 2 NEW_LINE x , y = 0 , 0 NEW_LINE for i in range ( 1 , size ) : NEW_LINE INDENT xor2 = xor2 ^ arr [ i ] NEW_LINE DEDENT set_bit_no = xor2 & ~ ( xor2 - 1 ) NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( arr [ i ] & set_bit_no ) : NEW_LINE INDENT x = x ^ arr [ i ] NEW_LINE DEDENT else : NEW_LINE INDENT y = y ^ arr [ i ] NEW_LINE DEDENT DEDENT print ( " The ▁ two ▁ ODD ▁ elements ▁ are " , x , " & " , y ) NEW_LINE DEDENT arr = [ 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 ] NEW_LINE arr_size = len ( arr ) NEW_LINE printTwoOdd ( arr , arr_size ) NEW_LINE
import math NEW_LINE def trianglearea ( a ) : NEW_LINE INDENT if ( a < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT area = ( 3 * math . sqrt ( 3 ) * math . pow ( a , 2 ) ) / 4 ; NEW_LINE return area ; NEW_LINE DEDENT a = 6 ; NEW_LINE print ( trianglearea ( a ) ) NEW_LINE
def calculate ( a ) : NEW_LINE INDENT a . sort ( ) NEW_LINE count = 1 NEW_LINE answer = 0 NEW_LINE for i in range ( 1 , len ( a ) ) : NEW_LINE INDENT if a [ i ] == a [ i - 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE count = 1 NEW_LINE DEDENT DEDENT answer = answer + count * ( count - 1 ) // 2 NEW_LINE return answer NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 2 , 1 , 2 , 4 ] NEW_LINE print ( calculate ( a ) ) NEW_LINE DEDENT
import math NEW_LINE def countPrimeFactors ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = n / 2 ; NEW_LINE count += 1 ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i <= math . sqrt ( n ) ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = n / i ; NEW_LINE count += 1 ; NEW_LINE DEDENT i = i + 2 ; NEW_LINE DEDENT if ( n > 2 ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT return ( count ) ; NEW_LINE DEDENT def printKAlmostPrimes ( k , n ) : NEW_LINE INDENT i = 1 ; NEW_LINE num = 2 NEW_LINE while ( i <= n ) : NEW_LINE INDENT if ( countPrimeFactors ( num ) == k ) : NEW_LINE INDENT print ( num , end = " " ) ; NEW_LINE print ( " ▁ " , end = " " ) ; NEW_LINE i += 1 ; NEW_LINE DEDENT num += 1 ; NEW_LINE DEDENT return ; NEW_LINE DEDENT n = 10 ; NEW_LINE k = 2 ; NEW_LINE print ( " First ▁ n ▁ k - almost ▁ prime ▁ numbers : " ) ; NEW_LINE printKAlmostPrimes ( k , n ) ; NEW_LINE
import numpy as np NEW_LINE LAS = np . zeros ( ( 1000 , 2 ) ) NEW_LINE for i in range ( 1000 ) : NEW_LINE INDENT for j in range ( 2 ) : NEW_LINE INDENT LAS [ i ] [ j ] = False NEW_LINE DEDENT DEDENT def solve ( arr , n , i , pos ) : NEW_LINE INDENT if ( i == n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( LAS [ i ] [ pos ] ) : NEW_LINE INDENT return LAS [ i ] [ pos ] ; NEW_LINE DEDENT inc = 0 ; exc = 0 ; NEW_LINE if ( arr [ i ] > 0 and pos == True ) : NEW_LINE INDENT pos = False ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT elif ( arr [ i ] < 0 and pos == False ) : NEW_LINE INDENT pos = True ; NEW_LINE inc = 1 + solve ( arr , n , i + 1 , pos ) ; NEW_LINE DEDENT exc = solve ( arr , n , i + 1 , pos ) ; NEW_LINE LAS [ i ] [ pos ] = max ( inc , exc ) ; NEW_LINE return LAS [ i ] [ pos ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , 2 , 3 , 4 , 5 , - 6 , 8 , - 99 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( max ( solve ( arr , n , 0 , 0 ) , solve ( arr , n , 0 , 1 ) ) ) ; NEW_LINE DEDENT
def expressDigit ( arr , n ) : NEW_LINE INDENT min = 9 NEW_LINE index = 0 NEW_LINE temp = 0 NEW_LINE temp = arr [ 0 ] NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE index = i NEW_LINE DEDENT DEDENT if ( temp < min ) : NEW_LINE INDENT print ( 1 , end = " " ) NEW_LINE for i in range ( 1 , temp + 1 ) : NEW_LINE INDENT print ( 0 , end = " " ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( min ) : NEW_LINE INDENT print ( index , end = " " ) NEW_LINE DEDENT print ( index ) NEW_LINE DEDENT DEDENT arr = [ 2 , 2 , 1 , 2 , 1 , 1 , 3 , 1 , 1 , 1 ] NEW_LINE N = 10 NEW_LINE expressDigit ( arr , N ) NEW_LINE
def maxProduct ( arr , n ) : NEW_LINE INDENT if n < 3 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT arr . sort ( ) NEW_LINE return max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 10 , - 3 , 5 , 6 , - 20 ] NEW_LINE n = len ( arr ) NEW_LINE _max = maxProduct ( arr , n ) NEW_LINE if _max == - 1 : NEW_LINE INDENT print ( " No ▁ Triplet ▁ Exists " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Maximum ▁ product ▁ is " , _max ) NEW_LINE DEDENT DEDENT
R = 4 NEW_LINE C = 4 NEW_LINE def getTotalCoverageOfMatrix ( mat ) : NEW_LINE INDENT res = 0 NEW_LINE for i in range ( R ) : NEW_LINE INDENT isOne = False NEW_LINE for j in range ( C ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT isOne = False NEW_LINE for j in range ( C - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT for j in range ( C ) : NEW_LINE INDENT isOne = False NEW_LINE for i in range ( R ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT isOne = False NEW_LINE for i in range ( R - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT isOne = True NEW_LINE DEDENT elif ( isOne ) : NEW_LINE INDENT res += 1 NEW_LINE DEDENT DEDENT DEDENT return res NEW_LINE DEDENT mat = [ [ 0 , 0 , 0 , 0 ] , [ 1 , 0 , 0 , 1 ] , [ 0 , 1 , 1 , 0 ] , [ 0 , 1 , 0 , 0 ] ] NEW_LINE print ( getTotalCoverageOfMatrix ( mat ) ) NEW_LINE
import math as mt NEW_LINE def isPalindrome ( str1 , i , j ) : NEW_LINE INDENT while ( i < j ) : NEW_LINE INDENT if ( str1 [ i ] != str1 [ j ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT i += 1 NEW_LINE j -= 1 NEW_LINE DEDENT return True NEW_LINE DEDENT def countPrimePalindrome ( str1 , Len ) : NEW_LINE INDENT prime = [ True for i in range ( Len + 1 ) ] NEW_LINE prime [ 0 ] , prime [ 1 ] = False , False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( Len + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( 2 * p , Len + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for j in range ( 2 , Len + 1 ) : NEW_LINE INDENT if ( prime [ j ] ) : NEW_LINE INDENT for i in range ( Len + 1 - j ) : NEW_LINE INDENT if ( isPalindrome ( str1 , i , i + j - 1 ) ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT return count NEW_LINE DEDENT s = " geeksforgeeks " NEW_LINE Len = len ( s ) NEW_LINE print ( countPrimePalindrome ( s , Len ) ) NEW_LINE
import math as mt NEW_LINE MAX = 100001 NEW_LINE isPrime = [ 0 for i in range ( MAX ) ] NEW_LINE def sieve ( ) : NEW_LINE INDENT for p in range ( 2 , mt . ceil ( mt . sqrt ( MAX ) ) ) : NEW_LINE INDENT if ( isPrime [ p ] == 0 ) : NEW_LINE INDENT for i in range ( 2 * p , MAX , p ) : NEW_LINE INDENT isPrime [ i ] = 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT def findSubset ( a , n ) : NEW_LINE INDENT cnt1 = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] == 1 ) : NEW_LINE INDENT cnt1 += 1 NEW_LINE DEDENT DEDENT if ( cnt1 > 0 ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT if ( ( a [ i ] != 1 ) and ( isPrime [ a [ i ] + 1 ] == 0 ) ) : NEW_LINE INDENT print ( cnt1 + 1 ) NEW_LINE for j in range ( cnt1 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT print ( a [ i ] ) NEW_LINE return 0 NEW_LINE DEDENT DEDENT DEDENT if ( cnt1 >= 2 ) : NEW_LINE INDENT print ( cnt1 ) NEW_LINE for i in range ( cnt1 ) : NEW_LINE INDENT print ( "1" , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) : NEW_LINE INDENT print ( 2 ) NEW_LINE print ( a [ i ] , " ▁ " , a [ j ] ) NEW_LINE DEDENT DEDENT DEDENT print ( - 1 ) NEW_LINE DEDENT sieve ( ) NEW_LINE A = [ 2 , 1 , 1 ] NEW_LINE n = len ( A ) NEW_LINE findSubset ( A , n ) NEW_LINE
import sys NEW_LINE def minMoves ( n ) : NEW_LINE INDENT s = str ( n ) ; NEW_LINE ans = sys . maxsize ; NEW_LINE len1 = len ( s ) ; NEW_LINE for i in range ( len1 ) : NEW_LINE INDENT for j in range ( len1 ) : NEW_LINE INDENT if ( i == j ) : NEW_LINE INDENT continue ; NEW_LINE DEDENT t = s ; NEW_LINE cur = 0 ; NEW_LINE list1 = list ( t ) ; NEW_LINE for k in range ( i , len1 - 1 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE list1 = list ( t ) ; NEW_LINE for k in range ( j - ( j > i ) , len1 - 2 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE pos = - 1 ; NEW_LINE for k in range ( len1 ) : NEW_LINE INDENT if ( t [ k ] != '0' ) : NEW_LINE INDENT pos = k ; NEW_LINE break ; NEW_LINE DEDENT DEDENT for k in range ( pos , 0 , - 1 ) : NEW_LINE INDENT e = list1 [ k ] ; NEW_LINE list1 [ k ] = list1 [ k + 1 ] ; NEW_LINE list1 [ k + 1 ] = e ; NEW_LINE cur += 1 ; NEW_LINE DEDENT t = ' ' . join ( list1 ) ; NEW_LINE nn = int ( t ) ; NEW_LINE if ( nn % 25 == 0 ) : NEW_LINE INDENT ans = min ( ans , cur ) ; NEW_LINE DEDENT DEDENT DEDENT if ( ans == sys . maxsize ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT n = 509201 ; NEW_LINE print ( minMoves ( n ) ) ; NEW_LINE
import math NEW_LINE def findSum ( n ) : NEW_LINE INDENT return math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( findSum ( n ) ) NEW_LINE DEDENT
def merge ( arr , temp , left , mid , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE i = left NEW_LINE j = mid NEW_LINE k = left NEW_LINE while ( ( i <= mid - 1 ) and ( j <= right ) ) : NEW_LINE INDENT if ( arr [ i ] <= arr [ j ] ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE inv_count = inv_count + ( mid - i ) NEW_LINE DEDENT DEDENT while ( i <= mid - 1 ) : NEW_LINE INDENT temp [ k ] = arr [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT while ( j <= right ) : NEW_LINE INDENT temp [ k ] = arr [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( left , right + 1 , 1 ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def _mergeSort ( arr , temp , left , right ) : NEW_LINE INDENT inv_count = 0 NEW_LINE if ( right > left ) : NEW_LINE INDENT mid = int ( ( right + left ) / 2 ) NEW_LINE inv_count = _mergeSort ( arr , temp , left , mid ) NEW_LINE inv_count += _mergeSort ( arr , temp , mid + 1 , right ) NEW_LINE inv_count += merge ( arr , temp , left , mid + 1 , right ) NEW_LINE DEDENT return inv_count NEW_LINE DEDENT def countSwaps ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE return _mergeSort ( arr , temp , 0 , n - 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 20 , 6 , 4 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Number ▁ of ▁ swaps ▁ is " , countSwaps ( arr , n ) ) NEW_LINE DEDENT
def solve ( i , x , dp ) : NEW_LINE INDENT if ( i < 0 ) : NEW_LINE INDENT return x == 3 NEW_LINE DEDENT if ( dp [ i ] [ x ] != - 1 ) : NEW_LINE INDENT return dp [ i ] [ x ] NEW_LINE DEDENT dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) NEW_LINE dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) NEW_LINE return dp [ i ] [ x ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 ; NEW_LINE dp = [ [ 0 for i in range ( n ) ] for j in range ( 4 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 4 ) : NEW_LINE INDENT dp [ i ] [ j ] = - 1 NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT dp [ i ] [ 3 ] = ( 1 << ( i + 1 ) ) NEW_LINE DEDENT print ( solve ( n - 1 , 0 , dp ) ) NEW_LINE DEDENT
def minCost ( cost , n ) : NEW_LINE INDENT totalCost = 0 NEW_LINE boardingBus = 0 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( cost [ boardingBus ] > cost [ i ] ) : NEW_LINE INDENT totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) NEW_LINE boardingBus = i NEW_LINE DEDENT DEDENT totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) NEW_LINE return totalCost NEW_LINE DEDENT cost = [ 4 , 7 , 8 , 3 , 4 ] NEW_LINE n = len ( cost ) NEW_LINE print ( minCost ( cost , n ) ) NEW_LINE
def countSquares ( m , n ) : NEW_LINE INDENT if ( n < m ) : NEW_LINE INDENT temp = m NEW_LINE m = n NEW_LINE n = temp NEW_LINE DEDENT return n * ( n + 1 ) * ( 3 * m - n + 1 ) // 6 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 4 NEW_LINE n = 3 NEW_LINE print ( " Count ▁ of ▁ squares ▁ is " , countSquares ( m , n ) ) NEW_LINE DEDENT
import math as mt NEW_LINE N = 100005 NEW_LINE MAX = 1000002 NEW_LINE lpd = [ 0 for i in range ( MAX ) ] NEW_LINE def preCompute ( ) : NEW_LINE INDENT lpd [ 0 ] , lpd [ 1 ] = 1 , 1 NEW_LINE for i in range ( 2 , mt . ceil ( mt . sqrt ( MAX ) ) ) : NEW_LINE INDENT for j in range ( 2 * i , MAX , i ) : NEW_LINE INDENT if ( lpd [ j ] == 0 ) : NEW_LINE INDENT lpd [ j ] = i NEW_LINE DEDENT DEDENT DEDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT if ( lpd [ i ] == 0 ) : NEW_LINE INDENT lpd [ i ] = i NEW_LINE DEDENT DEDENT DEDENT def maxLengthSubsequence ( arr , n ) : NEW_LINE INDENT dp = [ 1 for i in range ( N + 1 ) ] NEW_LINE pos = dict ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT while ( arr [ i ] > 1 ) : NEW_LINE INDENT p = lpd [ arr [ i ] ] NEW_LINE if ( p in pos . keys ( ) ) : NEW_LINE INDENT dp [ i ] = max ( dp [ i ] , 1 + dp [ pos [ p ] ] ) NEW_LINE DEDENT pos [ p ] = i NEW_LINE while ( arr [ i ] % p == 0 ) : NEW_LINE INDENT arr [ i ] //= p NEW_LINE DEDENT DEDENT DEDENT ans = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans = max ( ans , dp [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT arr = [ 13 , 2 , 8 , 6 , 3 , 1 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE preCompute ( ) NEW_LINE print ( maxLengthSubsequence ( arr , n ) ) NEW_LINE
def partition ( arr , low , high ) : NEW_LINE INDENT pivot = arr [ high ] NEW_LINE i = ( low - 1 ) NEW_LINE for j in range ( low , high ) : NEW_LINE INDENT if ( arr [ j ] <= pivot ) : NEW_LINE INDENT i += 1 NEW_LINE arr [ i ] , arr [ j ] = arr [ j ] , arr [ i ] NEW_LINE DEDENT DEDENT arr [ i + 1 ] , arr [ high ] = arr [ high ] , arr [ i + 1 ] NEW_LINE return ( i + 1 ) NEW_LINE DEDENT def quickSort ( arr , low , high ) : NEW_LINE INDENT if ( low < high ) : NEW_LINE INDENT pi = partition ( arr , low , high ) NEW_LINE quickSort ( arr , low , pi - 1 ) NEW_LINE quickSort ( arr , pi + 1 , high ) NEW_LINE DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT arr = [ 10 , 7 , 8 , 9 , 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE quickSort ( arr , 0 , n - 1 ) NEW_LINE print ( " Sorted ▁ array : " ) NEW_LINE printArray ( arr , n ) NEW_LINE
def gcdExtended ( a , b ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT return b , 0 , 1 NEW_LINE DEDENT gcd , x1 , y1 = gcdExtended ( b % a , a ) NEW_LINE x = y1 - ( b // a ) * x1 NEW_LINE y = x1 NEW_LINE return gcd , x , y NEW_LINE DEDENT a , b = 35 , 15 NEW_LINE g , x , y = gcdExtended ( a , b ) NEW_LINE print ( " gcd ( " , a , " , " , b , " ) ▁ = ▁ " , g ) NEW_LINE
def floorSqrt ( x ) : NEW_LINE INDENT if ( x == 0 or x == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT start = 1 NEW_LINE end = x NEW_LINE while ( start <= end ) : NEW_LINE INDENT mid = ( start + end ) // 2 NEW_LINE if ( mid * mid == x ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid * mid < x ) : NEW_LINE INDENT start = mid + 1 NEW_LINE ans = mid NEW_LINE DEDENT else : NEW_LINE INDENT end = mid - 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT x = 11 NEW_LINE print ( floorSqrt ( x ) ) NEW_LINE
def shortestDistance ( S , X ) : NEW_LINE INDENT prev = float ( ' - inf ' ) NEW_LINE ans = [ ] NEW_LINE for i , j in enumerate ( S ) : NEW_LINE INDENT if j == X : NEW_LINE INDENT prev = i NEW_LINE DEDENT ans . append ( i - prev ) NEW_LINE DEDENT prev = float ( ' inf ' ) NEW_LINE for i in range ( len ( S ) - 1 , - 1 , - 1 ) : NEW_LINE INDENT if S [ i ] == X : NEW_LINE INDENT prev = i NEW_LINE DEDENT ans [ i ] = min ( ans [ i ] , prev - i ) NEW_LINE DEDENT return ans NEW_LINE DEDENT S = " geeksforgeeks " NEW_LINE X = " g " NEW_LINE print ( shortestDistance ( S , X ) ) NEW_LINE
from math import log2 NEW_LINE MAX = 100001 NEW_LINE dp = [ 0 ] * MAX NEW_LINE def probability ( k , n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( k , n + 1 ) : NEW_LINE INDENT res = dp [ n ] - dp [ i ] - dp [ n - i ] - n NEW_LINE ans = ans + pow ( 2.0 , res ) NEW_LINE DEDENT return ans NEW_LINE DEDENT def precompute ( ) : NEW_LINE INDENT for i in range ( 2 , MAX ) : NEW_LINE INDENT dp [ i ] = log2 ( i ) + dp [ i - 1 ] NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT precompute ( ) NEW_LINE print ( probability ( 2 , 3 ) ) NEW_LINE print ( probability ( 3 , 6 ) ) NEW_LINE print ( probability ( 500 , 1000 ) ) NEW_LINE DEDENT
import math NEW_LINE def maximumXOR ( n , l , r ) : NEW_LINE INDENT x = 0 NEW_LINE for i in range ( int ( math . log2 ( r ) ) , - 1 , - 1 ) : NEW_LINE INDENT if ( n & ( 1 << i ) ) : NEW_LINE INDENT if ( x > r ) or ( x + ( 1 << i ) - 1 < l ) : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT if ( x ^ ( 1 << i ) ) <= r : NEW_LINE INDENT x ^= ( 1 << i ) NEW_LINE DEDENT DEDENT DEDENT return n ^ x NEW_LINE DEDENT n = 7 NEW_LINE l = 2 NEW_LINE r = 23 NEW_LINE print ( " The ▁ output ▁ is " , maximumXOR ( n , l , r ) ) NEW_LINE
import math NEW_LINE def edgeDisjoint ( n ) : NEW_LINE INDENT result = 0 NEW_LINE result = math . floor ( n / 2 ) NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( int ( edgeDisjoint ( n ) ) ) NEW_LINE DEDENT
from math import * NEW_LINE def Probability ( sum , times ) : NEW_LINE INDENT favorable , total , probability = 0.0 , 36.0 , 0 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT for j in range ( 7 ) : NEW_LINE INDENT if ( ( i + j ) == sum ) : NEW_LINE INDENT favorable += 1 NEW_LINE DEDENT DEDENT DEDENT gcd1 = gcd ( int ( favorable ) , int ( total ) ) NEW_LINE favorable = favorable / gcd1 NEW_LINE total = total / gcd1 NEW_LINE probability = pow ( total , times ) NEW_LINE return int ( probability ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT sum , times = 7 , 7 NEW_LINE print ( "1" , " / " , Probability ( sum , times ) ) NEW_LINE DEDENT
def NumberOfSolutions ( a , b , c , d ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( a , b + 1 ) : NEW_LINE INDENT if d >= max ( c , i + 1 ) : NEW_LINE INDENT ans += d - max ( c , i + 1 ) + 1 NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a , b , c , d = 2 , 3 , 3 , 4 NEW_LINE print ( NumberOfSolutions ( a , b , c , d ) ) NEW_LINE DEDENT
def reverse ( string , length , l , r ) : NEW_LINE INDENT if ( l < 0 or r >= length or l > r ) : NEW_LINE INDENT return string ; NEW_LINE DEDENT string = list ( string ) NEW_LINE while ( l < r ) : NEW_LINE INDENT c = string [ l ] ; NEW_LINE string [ l ] = string [ r ] ; NEW_LINE string [ r ] = c ; NEW_LINE l += 1 ; NEW_LINE r -= 1 ; NEW_LINE DEDENT return " " . join ( string ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " geeksforgeeks " ; NEW_LINE length = len ( string ) ; NEW_LINE l = 5 ; r = 7 ; NEW_LINE print ( reverse ( string , length , l , r ) ) ; NEW_LINE DEDENT
import math NEW_LINE MAX = 1000000 ; NEW_LINE primes = [ ] ; NEW_LINE def sieveSundaram ( ) : NEW_LINE INDENT marked = [ False ] * ( int ( MAX / 2 ) + 1 ) ; NEW_LINE for i in range ( 1 , int ( ( math . sqrt ( MAX ) - 1 ) / 2 ) + 1 ) : NEW_LINE INDENT for j in range ( ( ( i * ( i + 1 ) ) << 1 ) , ( int ( MAX / 2 ) + 1 ) , ( 2 * i + 1 ) ) : NEW_LINE INDENT marked [ j ] = True ; NEW_LINE DEDENT DEDENT primes . append ( 2 ) ; NEW_LINE for i in range ( 1 , int ( MAX / 2 ) ) : NEW_LINE INDENT if ( marked [ i ] == False ) : NEW_LINE INDENT primes . append ( 2 * i + 1 ) ; NEW_LINE DEDENT DEDENT DEDENT def calculatePrimorial ( n ) : NEW_LINE INDENT result = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT result = result * primes [ i ] ; NEW_LINE DEDENT return result ; NEW_LINE DEDENT n = 5 ; NEW_LINE sieveSundaram ( ) ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Primorial ( P # ) ▁ of " , i , " is " , calculatePrimorial ( i ) ) ; NEW_LINE DEDENT
def countOccurrances ( n , d ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == d ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return count NEW_LINE DEDENT d = 2 NEW_LINE n = 214215421 NEW_LINE print ( countOccurrances ( n , d ) ) NEW_LINE
import math as mt NEW_LINE def SieveOfEratosthenes ( prime , p_size ) : NEW_LINE INDENT prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE for p in range ( 2 , mt . ceil ( mt . sqrt ( p_size + 1 ) ) ) : NEW_LINE INDENT if ( prime [ p ] ) : NEW_LINE INDENT for i in range ( p * 2 , p_size + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT DEDENT def SumOfElements ( arr , n ) : NEW_LINE INDENT prime = [ True for i in range ( n + 1 ) ] NEW_LINE SieveOfEratosthenes ( prime , n + 1 ) NEW_LINE i , j = 0 , 0 NEW_LINE m = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in m . keys ( ) : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for i in m : NEW_LINE INDENT if ( prime [ m [ i ] ] ) : NEW_LINE INDENT Sum += ( i ) NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 5 , 4 , 6 , 5 , 4 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( SumOfElements ( arr , n ) ) NEW_LINE
def sortArrays ( arr ) : NEW_LINE INDENT length = len ( arr ) NEW_LINE j = 0 NEW_LINE while j < length - 1 : NEW_LINE INDENT if ( arr [ j ] > arr [ j + 1 ] ) : NEW_LINE INDENT temp = arr [ j ] NEW_LINE arr [ j ] = arr [ j + 1 ] NEW_LINE arr [ j + 1 ] = temp NEW_LINE j = - 1 NEW_LINE DEDENT j += 1 NEW_LINE DEDENT return arr NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 99 , 9 , 8 , 7 , 6 , 0 , 5 , 4 , 3 ] NEW_LINE print ( " Original ▁ array : ▁ " , arr ) NEW_LINE arr = sortArrays ( arr ) NEW_LINE print ( " Sorted ▁ array : ▁ " , arr ) NEW_LINE DEDENT
def check ( i , val ) : NEW_LINE INDENT if i - val < 0 : NEW_LINE INDENT return False NEW_LINE DEDENT return True NEW_LINE DEDENT def MinimumPrimes ( n ) : NEW_LINE INDENT dp = [ 10 ** 9 ] * ( n + 1 ) NEW_LINE dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if check ( i , 2 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 2 ] ) NEW_LINE DEDENT if check ( i , 3 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 3 ] ) NEW_LINE DEDENT if check ( i , 5 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 5 ] ) NEW_LINE DEDENT if check ( i , 7 ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i ] , 1 + dp [ i - 7 ] ) NEW_LINE DEDENT DEDENT if dp [ n ] == 10 ** 9 : NEW_LINE INDENT return - 1 NEW_LINE DEDENT else : NEW_LINE INDENT return dp [ n ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 12 NEW_LINE minimal = MinimumPrimes ( n ) NEW_LINE if minimal != - 1 : NEW_LINE INDENT print ( " Minimum ▁ number ▁ of ▁ single ▁ digit ▁ primes ▁ required ▁ : ▁ " , minimal ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ possible " ) NEW_LINE DEDENT DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( 0 , n + 1 , 1 ) : NEW_LINE INDENT for j in range ( 0 , min ( i , k ) + 1 , 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE k = 3 NEW_LINE print ( " Total ▁ number ▁ of ▁ different ▁ ways ▁ are " , binomialCoeff ( n - 1 , k - 1 ) ) NEW_LINE DEDENT
mod = 1000000007 NEW_LINE def findSum ( n ) : NEW_LINE INDENT return ( ( n % mod ) * ( n % mod ) ) % mod NEW_LINE DEDENT n = 229137999 NEW_LINE print ( findSum ( n ) ) NEW_LINE
import math NEW_LINE def Print ( n , k ) : NEW_LINE INDENT rem = 1 NEW_LINE for i in range ( 0 , k ) : NEW_LINE INDENT print ( math . floor ( ( ( 10 * rem ) / n ) ) , end = " " ) NEW_LINE rem = ( 10 * rem ) % n NEW_LINE DEDENT DEDENT n = 7 NEW_LINE k = 3 NEW_LINE Print ( n , k ) ; NEW_LINE print ( " ▁ " ) NEW_LINE n = 21 NEW_LINE k = 4 NEW_LINE Print ( n , k ) ; NEW_LINE
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT matrix = [ [ 0 for i in range ( 5 ) ] for j in range ( 5 ) ] NEW_LINE DEDENT row_index , column_index , x , size = 0 , 0 , 0 , 5 ; NEW_LINE for row_index in range ( size ) : NEW_LINE INDENT for column_index in range ( size ) : NEW_LINE INDENT x += 1 ; NEW_LINE matrix [ row_index ] [ column_index ] = x ; NEW_LINE DEDENT DEDENT print ( " The ▁ matrix ▁ is " ) ; NEW_LINE for row_index in range ( size ) : NEW_LINE INDENT for column_index in range ( size ) : NEW_LINE INDENT print ( matrix [ row_index ] [ column_index ] , end = " \t " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT print ( " \n Elements ▁ below ▁ Secondary ▁ diagonal ▁ are : " ) ; NEW_LINE for row_index in range ( size ) : NEW_LINE INDENT for column_index in range ( size ) : NEW_LINE INDENT if ( ( row_index + column_index ) > size - 1 ) : NEW_LINE INDENT print ( matrix [ row_index ] [ column_index ] , end = " , ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT
def findProduct ( arr , n ) : NEW_LINE INDENT prod = 1 NEW_LINE s = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] not in s . keys ( ) ) : NEW_LINE INDENT prod *= arr [ i ] NEW_LINE s [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT return prod NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findProduct ( arr , n ) ) NEW_LINE
def findNumber ( n ) : NEW_LINE INDENT i = n - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT count = [ 0 for i in range ( 10 ) ] NEW_LINE x = i NEW_LINE count1 = 0 NEW_LINE count2 = 0 NEW_LINE while ( x ) : NEW_LINE INDENT count [ x % 10 ] += 1 NEW_LINE x = int ( x / 10 ) NEW_LINE count1 += 1 NEW_LINE DEDENT for j in range ( 0 , 10 , 1 ) : NEW_LINE INDENT if ( count [ j ] == 1 ) : NEW_LINE INDENT count2 += 1 NEW_LINE DEDENT DEDENT if ( count1 == count2 ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 8490 NEW_LINE print ( findNumber ( n ) ) NEW_LINE DEDENT
modd = 1000000007 NEW_LINE def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def ways ( n , m ) : NEW_LINE INDENT return power ( m - 1 , n - 1 , modd ) * m % modd NEW_LINE DEDENT n , m = 5 , 5 NEW_LINE print ( ways ( n , m ) ) NEW_LINE
def q1 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q2 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q2 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q3 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q4 ( s , i ) : NEW_LINE INDENT if ( i == s . length ( ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q4 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT def q0 ( s , i ) : NEW_LINE INDENT if ( i == len ( s ) ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE return ; NEW_LINE DEDENT if ( s [ i ] == ' a ' ) : NEW_LINE INDENT q1 ( s , i + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT q3 ( s , i + 1 ) ; NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s = " abbaabb " ; NEW_LINE q0 ( s , 0 ) ; NEW_LINE DEDENT
from math import sqrt NEW_LINE def heightCalculate ( H , n , m ) : NEW_LINE INDENT N = n * 1.0 NEW_LINE M = m * 1.0 NEW_LINE h = H * sqrt ( N / ( N + M ) ) NEW_LINE return h NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT H = 10 NEW_LINE n = 3 NEW_LINE m = 4 NEW_LINE print ( " { 0 : . 6 } " . format ( heightCalculate ( H , n , m ) ) ) ; NEW_LINE DEDENT
def CountWays ( n , flag ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT sum = 0 NEW_LINE if flag == False and n > 1 : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) + CountWays ( n - 2 , True ) NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + CountWays ( n - 1 , False ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( CountWays ( n , False ) ) NEW_LINE DEDENT
import math NEW_LINE def printVector ( v ) : NEW_LINE INDENT print ( len ( v ) ) NEW_LINE for i in range ( 0 , len ( v ) ) : NEW_LINE INDENT print ( v [ i ] , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT def findTwoGroup ( n ) : NEW_LINE INDENT sum = n * ( n + 1 ) / 2 NEW_LINE group1Sum = sum / 2 NEW_LINE group1 = [ ] NEW_LINE group2 = [ ] NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if ( group1Sum - i >= 0 ) : NEW_LINE INDENT group1 . append ( i ) NEW_LINE group1Sum -= i NEW_LINE DEDENT else : NEW_LINE INDENT group2 . append ( i ) NEW_LINE DEDENT DEDENT printVector ( group1 ) NEW_LINE printVector ( group2 ) NEW_LINE DEDENT n = 5 NEW_LINE findTwoGroup ( n ) NEW_LINE
from math import gcd NEW_LINE def printNumbers ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE for i in range ( n ) : NEW_LINE INDENT num = a [ i ] NEW_LINE g = gcd ( num , x ) NEW_LINE while ( g != 1 ) : NEW_LINE INDENT num //= g NEW_LINE g = gcd ( num , x ) NEW_LINE DEDENT if ( num == 1 ) : NEW_LINE INDENT flag = True ; NEW_LINE print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT if ( not flag ) : NEW_LINE INDENT print ( " There ▁ are ▁ no ▁ such ▁ numbers " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x = 60 NEW_LINE a = [ 2 , 5 , 10 , 7 , 17 ] NEW_LINE n = len ( a ) NEW_LINE printNumbers ( a , n , x ) NEW_LINE DEDENT
def maxNumber ( string , n ) : NEW_LINE INDENT freq = [ 0 , 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( string [ i ] == ' z ' ) : NEW_LINE INDENT freq [ 0 ] += 1 ; NEW_LINE DEDENT elif ( string [ i ] == ' n ' ) : NEW_LINE INDENT freq [ 1 ] += 1 ; NEW_LINE DEDENT DEDENT num = " " ; NEW_LINE for i in range ( freq [ 1 ] ) : NEW_LINE INDENT num += '1' ; NEW_LINE DEDENT for i in range ( freq [ 0 ] ) : NEW_LINE INDENT num += '0' ; NEW_LINE DEDENT return num ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " roenenzooe " ; NEW_LINE n = len ( string ) ; NEW_LINE print ( maxNumber ( string , n ) ) ; NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def isEmirp ( n ) : NEW_LINE INDENT n = int ( n ) NEW_LINE if isPrime ( n ) == False : NEW_LINE INDENT return False NEW_LINE DEDENT rev = 0 NEW_LINE while n != 0 : NEW_LINE INDENT d = n % 10 NEW_LINE rev = rev * 10 + d NEW_LINE n = int ( n / 10 ) NEW_LINE DEDENT return isPrime ( rev ) NEW_LINE DEDENT n = 13 NEW_LINE if isEmirp ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def substrDeletion ( string , length ) : NEW_LINE INDENT count0 = 0 ; NEW_LINE count1 = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( string [ i ] == '0' ) : NEW_LINE INDENT count0 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT count1 += 1 ; NEW_LINE DEDENT DEDENT return min ( count0 , count1 ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = "010" ; NEW_LINE length = len ( string ) ; NEW_LINE print ( substrDeletion ( string , length ) ) ; NEW_LINE DEDENT
def IsPossible ( s ) : NEW_LINE INDENT n = len ( s ) ; NEW_LINE count = set ( ) ; NEW_LINE map = dict . fromkeys ( s , 0 ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT count . add ( s [ i ] ) ; NEW_LINE map [ s [ i ] ] += 1 ; NEW_LINE DEDENT if ( len ( count ) == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( len ( count ) > 2 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT j = 0 NEW_LINE it = list ( count ) [ j ] ; NEW_LINE x = 0 ; y = 0 ; NEW_LINE x = map [ it ] ; NEW_LINE j += 1 NEW_LINE it = list ( count ) [ j ] ; NEW_LINE y = map [ it ] ; NEW_LINE if ( abs ( x - y ) <= 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aaaddad " ; NEW_LINE if ( IsPossible ( s ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT DEDENT
def radius ( n , d ) : NEW_LINE INDENT print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " , d / ( ( n - 1 ) * ( 2 ** ( 1 / 2 ) ) ) ) ; NEW_LINE DEDENT d = 42 ; n = 4 ; NEW_LINE radius ( n , d ) ; NEW_LINE
import math NEW_LINE def modularEquation ( a , b ) : NEW_LINE INDENT if ( a < b ) : NEW_LINE INDENT print ( " No ▁ solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT print ( " Infinite ▁ Solution ▁ possible ▁ " ) NEW_LINE return NEW_LINE DEDENT count = 0 NEW_LINE n = a - b NEW_LINE y = ( int ) ( math . sqrt ( a - b ) ) NEW_LINE for i in range ( 1 , y + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT if ( i > b ) : NEW_LINE INDENT count = count + 1 NEW_LINE DEDENT DEDENT DEDENT if ( y * y == n and y > b ) : NEW_LINE INDENT count = count - 1 NEW_LINE DEDENT print ( count ) NEW_LINE DEDENT a = 21 NEW_LINE b = 5 NEW_LINE modularEquation ( a , b ) NEW_LINE
def reverseNum ( x ) : NEW_LINE INDENT s = str ( x ) NEW_LINE s = s [ : : - 1 ] NEW_LINE return int ( s ) NEW_LINE DEDENT def isMysteryNumber ( n ) : NEW_LINE INDENT for i in range ( 1 , n // 2 + 1 ) : NEW_LINE INDENT j = reverseNum ( i ) NEW_LINE if i + j == n : NEW_LINE INDENT print ( i , j ) NEW_LINE return True NEW_LINE DEDENT DEDENT print ( " Not ▁ a ▁ Mystery ▁ Number " ) NEW_LINE return False NEW_LINE DEDENT n = 121 NEW_LINE isMysteryNumber ( n ) NEW_LINE
import numpy as np NEW_LINE def solve ( dp , wt , K , M , used ) : NEW_LINE INDENT if ( wt < 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( wt == 0 ) : NEW_LINE INDENT if ( used ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if ( dp [ wt ] [ used ] != - 1 ) : NEW_LINE INDENT return dp [ wt ] [ used ] NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( 1 , K + 1 ) : NEW_LINE INDENT if ( i >= M ) : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used | 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += solve ( dp , wt - i , K , M , used ) NEW_LINE DEDENT DEDENT dp [ wt ] [ used ] = ans NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT W = 3 NEW_LINE K = 3 NEW_LINE M = 2 NEW_LINE dp = np . ones ( ( W + 1 , 2 ) ) ; NEW_LINE dp = - 1 * dp NEW_LINE print ( solve ( dp , W , K , M , 0 ) ) NEW_LINE DEDENT
import math NEW_LINE def printDivisors ( n ) : NEW_LINE INDENT list = [ ] NEW_LINE for i in range ( 1 , int ( math . sqrt ( n ) + 1 ) ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT if ( n / i == i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE list . append ( int ( n / i ) ) NEW_LINE DEDENT DEDENT DEDENT for i in list [ : : - 1 ] : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT print ( " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ " ) NEW_LINE printDivisors ( 100 ) NEW_LINE
def isSubSequence ( str1 , str2 ) : NEW_LINE INDENT m = len ( str1 ) ; NEW_LINE n = len ( str2 ) ; NEW_LINE j = 0 ; NEW_LINE i = 0 ; NEW_LINE while ( i < n and j < m ) : NEW_LINE INDENT if ( str1 [ j ] == str2 [ i ] ) : NEW_LINE INDENT j += 1 ; NEW_LINE DEDENT i += 1 ; NEW_LINE DEDENT return ( j == m ) ; NEW_LINE DEDENT def findLongestString ( dict1 , str1 ) : NEW_LINE INDENT result = " " ; NEW_LINE length = 0 ; NEW_LINE for word in dict1 : NEW_LINE INDENT if ( length < len ( word ) and isSubSequence ( word , str1 ) ) : NEW_LINE INDENT result = word ; NEW_LINE length = len ( word ) ; NEW_LINE DEDENT DEDENT return result ; NEW_LINE DEDENT dict1 = [ " ale " , " apple " , " monkey " , " plea " ] ; NEW_LINE str1 = " abpcplea " ; NEW_LINE print ( findLongestString ( dict1 , str1 ) ) ; NEW_LINE
def lenoflongestnonpalindrome ( s ) : NEW_LINE INDENT max1 , length = 1 , 0 NEW_LINE for i in range ( 0 , len ( s ) - 1 ) : NEW_LINE INDENT if s [ i ] == s [ i + 1 ] : NEW_LINE INDENT length = 0 NEW_LINE DEDENT elif s [ i + 1 ] == s [ i - 1 ] and i > 0 : NEW_LINE INDENT length = 1 NEW_LINE DEDENT else : NEW_LINE INDENT length += 1 NEW_LINE DEDENT max1 = max ( max1 , length + 1 ) NEW_LINE DEDENT if max1 == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return max1 NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " synapse " NEW_LINE print ( lenoflongestnonpalindrome ( s ) ) NEW_LINE DEDENT
MAX_CHAR = 26 ; NEW_LINE def countFreq ( str1 , freq , len1 ) : NEW_LINE INDENT for i in range ( len1 ) : NEW_LINE INDENT freq [ ord ( str1 [ i ] ) - ord ( ' a ' ) ] += 1 ; NEW_LINE DEDENT DEDENT def canMakePalindrome ( freq , len1 ) : NEW_LINE INDENT count_odd = 0 ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT count_odd += 1 ; NEW_LINE DEDENT DEDENT if ( len1 % 2 == 0 ) : NEW_LINE INDENT if ( count_odd > 0 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT else : NEW_LINE INDENT return True ; NEW_LINE DEDENT DEDENT if ( count_odd != 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT return True ; NEW_LINE DEDENT def findOddAndRemoveItsFreq ( freq ) : NEW_LINE INDENT odd_str = " " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT if ( freq [ i ] % 2 != 0 ) : NEW_LINE INDENT freq [ i ] -= 1 ; NEW_LINE odd_str += chr ( i + ord ( ' a ' ) ) ; NEW_LINE return odd_str ; NEW_LINE DEDENT DEDENT return odd_str ; NEW_LINE DEDENT def findPalindromicString ( str1 ) : NEW_LINE INDENT len1 = len ( str1 ) ; NEW_LINE freq = [ 0 ] * MAX_CHAR ; NEW_LINE countFreq ( str1 , freq , len1 ) ; NEW_LINE if ( canMakePalindrome ( freq , len1 ) == False ) : NEW_LINE INDENT return " No ▁ Palindromic ▁ String " ; NEW_LINE DEDENT odd_str = findOddAndRemoveItsFreq ( freq ) ; NEW_LINE front_str = " " ; NEW_LINE rear_str = " ▁ " ; NEW_LINE for i in range ( MAX_CHAR ) : NEW_LINE INDENT temp = " " ; NEW_LINE if ( freq [ i ] != 0 ) : NEW_LINE INDENT ch = chr ( i + ord ( ' a ' ) ) ; NEW_LINE for j in range ( 1 , int ( freq [ i ] / 2 ) + 1 ) : NEW_LINE INDENT temp += ch ; NEW_LINE DEDENT front_str += temp ; NEW_LINE rear_str = temp + rear_str ; NEW_LINE DEDENT DEDENT return ( front_str + odd_str + rear_str ) ; NEW_LINE DEDENT str1 = " malayalam " ; NEW_LINE print ( findPalindromicString ( str1 ) ) ; NEW_LINE
def twistedTOH ( n , first , middle , last ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move ▁ disk " , n , " from ▁ rod " , first , " to " , middle , " and ▁ then ▁ to " , last ) NEW_LINE return NEW_LINE DEDENT twistedTOH ( n - 1 , first , middle , last ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , first , " to " , middle ) NEW_LINE twistedTOH ( n - 1 , last , middle , first ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , middle , " to " , last ) NEW_LINE twistedTOH ( n - 1 , first , middle , last ) NEW_LINE DEDENT n = 2 NEW_LINE twistedTOH ( n , ' A ' , ' B ' , ' C ' ) NEW_LINE
def countSetBits ( n ) : NEW_LINE INDENT bitCount = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT bitCount += countSetBitsUtil ( i ) NEW_LINE DEDENT return bitCount NEW_LINE DEDENT def countSetBitsUtil ( x ) : NEW_LINE INDENT if ( x <= 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return ( 0 if int ( x % 2 ) == 0 else 1 ) + countSetBitsUtil ( int ( x / 2 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE print ( " Total ▁ set ▁ bit ▁ count ▁ is " , countSetBits ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def bit ( x ) : NEW_LINE INDENT ans = 0 NEW_LINE while ( x ) : NEW_LINE INDENT x /= 2 NEW_LINE ans = ans + 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT def check ( d , x ) : NEW_LINE INDENT if ( bit ( x / d ) <= bit ( d ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False ; NEW_LINE DEDENT def bs ( n ) : NEW_LINE INDENT l = 1 NEW_LINE r = int ( math . sqrt ( n ) ) NEW_LINE while ( l < r ) : NEW_LINE INDENT m = int ( ( l + r ) / 2 ) NEW_LINE if ( check ( m , n ) ) : NEW_LINE INDENT r = m NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT if ( check ( l , n ) == False ) : NEW_LINE INDENT return math . floor ( l + 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT return math . floor ( l ) NEW_LINE DEDENT DEDENT def countDivisor ( n ) : NEW_LINE INDENT return n - bs ( n ) + 1 NEW_LINE DEDENT n = 5 NEW_LINE print ( countDivisor ( n ) ) NEW_LINE
INT_MIN = - 2147483648 NEW_LINE def isPresent ( B , m , x ) : NEW_LINE INDENT for i in range ( 0 , m ) : NEW_LINE INDENT if B [ i ] == x : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def findMaxSubarraySumUtil ( A , B , n , m ) : NEW_LINE INDENT max_so_far = INT_MIN NEW_LINE curr_max = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isPresent ( B , m , A [ i ] ) == True : NEW_LINE INDENT curr_max = 0 NEW_LINE continue NEW_LINE DEDENT curr_max = max ( A [ i ] , curr_max + A [ i ] ) NEW_LINE max_so_far = max ( max_so_far , curr_max ) NEW_LINE DEDENT return max_so_far NEW_LINE DEDENT def findMaxSubarraySum ( A , B , n , m ) : NEW_LINE INDENT maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) NEW_LINE if maxSubarraySum == INT_MIN : NEW_LINE INDENT print ( ' Maximum ▁ Subarray ▁ Sum ▁ cant ▁ be ▁ found ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ' , maxSubarraySum ) NEW_LINE DEDENT DEDENT A = [ 3 , 4 , 5 , - 4 , 6 ] NEW_LINE B = [ 1 , 8 , 5 ] NEW_LINE n = len ( A ) NEW_LINE m = len ( B ) NEW_LINE findMaxSubarraySum ( A , B , n , m ) NEW_LINE
def findArea ( a , b ) : NEW_LINE INDENT Area = 3.142 * a * b ; NEW_LINE print ( " Area : " , round ( Area , 2 ) ) ; NEW_LINE DEDENT a = 5 ; NEW_LINE b = 4 ; NEW_LINE findArea ( a , b ) ; NEW_LINE
from math import ceil , sqrt NEW_LINE def perfectSquares ( l , r ) : NEW_LINE INDENT number = ceil ( sqrt ( l ) ) ; NEW_LINE n2 = number * number ; NEW_LINE number = ( number * 2 ) + 1 ; NEW_LINE while ( ( n2 >= l and n2 <= r ) ) : NEW_LINE INDENT print ( n2 , end = " ▁ " ) ; NEW_LINE n2 = n2 + number ; NEW_LINE number += 2 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT l = 2 ; r = 24 ; NEW_LINE perfectSquares ( l , r ) ; NEW_LINE DEDENT
def printPermutation ( n , k ) : NEW_LINE INDENT mx = n NEW_LINE for i in range ( 1 , k + 1 ) : NEW_LINE INDENT print ( mx , end = " ▁ " ) NEW_LINE mx -= 1 NEW_LINE DEDENT for i in range ( 1 , mx + 1 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N , K = 5 , 3 NEW_LINE if K >= N - 1 : NEW_LINE INDENT print ( " Not ▁ Possible " ) NEW_LINE DEDENT else : NEW_LINE INDENT printPermutation ( N , K ) NEW_LINE DEDENT DEDENT
def countSetBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return 1 + countSetBits ( n & ( n - 1 ) ) NEW_LINE DEDENT DEDENT n = 9 NEW_LINE print ( countSetBits ( n ) ) NEW_LINE
def manipulateString ( str ) : NEW_LINE INDENT for i in range ( len ( str ) ) : NEW_LINE INDENT asc = ord ( str [ i ] ) NEW_LINE rem = asc - ( 26 - ( ord ( str [ i ] ) - ord ( ' a ' ) ) ) NEW_LINE m = rem % 26 NEW_LINE str [ i ] = chr ( m + ord ( ' a ' ) ) NEW_LINE DEDENT print ( ' ' . join ( str ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " geeksforgeeks " NEW_LINE str = list ( str ) NEW_LINE manipulateString ( str ) NEW_LINE DEDENT
def arraySortedOrNot ( arr , n ) : NEW_LINE INDENT if ( n == 0 or n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i - 1 ] > arr [ i ] ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT arr = [ 20 , 23 , 23 , 45 , 78 , 88 ] NEW_LINE n = len ( arr ) NEW_LINE if ( arraySortedOrNot ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def cumm ( x , y , cummx , cummy , cummx2 , cummy2 , n ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT cummx [ i ] = cummx [ i - 1 ] + x [ i ] NEW_LINE cummy [ i ] = cummy [ i - 1 ] + y [ i ] NEW_LINE cummx2 [ i ] = cummx2 [ i - 1 ] + x [ i ] * x [ i ] NEW_LINE cummy2 [ i ] = cummy2 [ i - 1 ] + y [ i ] * y [ i ] NEW_LINE DEDENT DEDENT def calHammeredDistance ( n , x , y ) : NEW_LINE INDENT cummx = [ 0 ] * ( n + 1 ) NEW_LINE cummy = [ 0 ] * ( n + 1 ) NEW_LINE cummx2 = [ 0 ] * ( n + 1 ) NEW_LINE cummy2 = [ 0 ] * ( n + 1 ) NEW_LINE cumm ( x , y , cummx , cummy , cummx2 , cummy2 , n ) NEW_LINE hdx , hdy = 0 , 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT hdx += ( ( i - 1 ) * x [ i ] * x [ i ] + cummx2 [ i - 1 ] - 2 * x [ i ] * cummx [ i - 1 ] ) NEW_LINE hdy += ( ( i - 1 ) * y [ i ] * y [ i ] + cummy2 [ i - 1 ] - 2 * y [ i ] * cummy [ i - 1 ] ) NEW_LINE DEDENT total = hdx + hdy NEW_LINE return total NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE x = [ 0 , 0 , 1 , 0 ] NEW_LINE y = [ 1 , 0 , 0 , 0 ] NEW_LINE print ( calHammeredDistance ( n , x , y ) ) NEW_LINE DEDENT
N = 3 NEW_LINE def solve ( v ) : NEW_LINE INDENT res = [ ] NEW_LINE all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] NEW_LINE res . append ( all3 - v [ 1 ] * 2 ) NEW_LINE res . append ( all3 - v [ 2 ] * 2 ) NEW_LINE res . append ( all3 - v [ 0 ] * 2 ) NEW_LINE return res NEW_LINE DEDENT def findVertex ( xmid , ymid ) : NEW_LINE INDENT V1 = solve ( xmid ) NEW_LINE V2 = solve ( ymid ) NEW_LINE for i in range ( 0 , 3 ) : NEW_LINE INDENT print ( V1 [ i ] , end = " ▁ " ) NEW_LINE print ( V2 [ i ] ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT xmid = [ 5 , 4 , 5 ] NEW_LINE ymid = [ 3 , 4 , 5 ] NEW_LINE findVertex ( xmid , ymid ) NEW_LINE DEDENT
def countSubstring ( S , L , n ) : NEW_LINE INDENT freq = [ 0 for i in range ( 26 ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ( ord ( L [ i ] ) - ord ( ' a ' ) ) ] = 1 NEW_LINE DEDENT count , ans = 0 , 0 NEW_LINE for x in S : NEW_LINE INDENT if ( freq [ ord ( x ) - ord ( ' a ' ) ] ) : NEW_LINE INDENT ans += ( count * count + count ) // 2 NEW_LINE count = 0 NEW_LINE DEDENT else : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT ans += ( count * count + count ) // 2 NEW_LINE return ans NEW_LINE DEDENT S = " abcpxyz " NEW_LINE L = [ ' a ' , ' p ' , ' q ' ] NEW_LINE n = len ( L ) NEW_LINE print ( countSubstring ( S , L , n ) ) NEW_LINE
def solve ( low , high , T ) : NEW_LINE INDENT while low <= high : NEW_LINE INDENT mid = int ( ( low + high ) / 2 ) NEW_LINE if ( mid * ( mid + 1 ) ) == T : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( mid > 0 and ( mid * ( mid + 1 ) ) > T and ( mid * ( mid - 1 ) ) <= T ) : NEW_LINE INDENT return mid - 1 NEW_LINE DEDENT if ( mid * ( mid + 1 ) ) > T : NEW_LINE INDENT high = mid - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT T = 15 NEW_LINE ans = solve ( 1 , T , 2 * T ) NEW_LINE if ans != - 1 : NEW_LINE INDENT ans -= 1 NEW_LINE DEDENT print ( " Number ▁ of ▁ stair ▁ steps ▁ = ▁ " , ans ) NEW_LINE
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if ( k > n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT sum = arr [ 0 ] NEW_LINE for i in range ( 1 , k ) : NEW_LINE INDENT sum += arr [ i ] NEW_LINE DEDENT max_sum = sum NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT sum = sum + arr [ i ] - arr [ i - k ] NEW_LINE if ( sum > max_sum ) : NEW_LINE INDENT max_sum = sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length " , k , " begins ▁ at ▁ index " , findMaxAverage ( arr , n , k ) ) NEW_LINE
def circlearea ( a , b ) : NEW_LINE INDENT if ( a < 0 or b < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT A = ( ( 3.14 * pow ( a , 2 ) * pow ( b , 2 ) ) / ( 4 * ( pow ( a , 2 ) + pow ( b , 2 ) ) ) ) NEW_LINE return A NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 8 NEW_LINE b = 10 NEW_LINE print ( circlearea ( a , b ) ) NEW_LINE DEDENT
def countDyckPaths ( n ) : NEW_LINE INDENT res = 1 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT res *= ( 2 * n - i ) NEW_LINE res /= ( i + 1 ) NEW_LINE DEDENT return res / ( n + 1 ) NEW_LINE DEDENT n = 4 NEW_LINE print ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " , str ( int ( countDyckPaths ( n ) ) ) ) NEW_LINE
def multiply ( num1 , num2 ) : NEW_LINE INDENT len1 = len ( num1 ) NEW_LINE len2 = len ( num2 ) NEW_LINE if len1 == 0 or len2 == 0 : NEW_LINE INDENT return "0" NEW_LINE DEDENT result = [ 0 ] * ( len1 + len2 ) NEW_LINE i_n1 = 0 NEW_LINE i_n2 = 0 NEW_LINE for i in range ( len1 - 1 , - 1 , - 1 ) : NEW_LINE INDENT carry = 0 NEW_LINE n1 = ord ( num1 [ i ] ) - 48 NEW_LINE i_n2 = 0 NEW_LINE for j in range ( len2 - 1 , - 1 , - 1 ) : NEW_LINE INDENT n2 = ord ( num2 [ j ] ) - 48 NEW_LINE summ = n1 * n2 + result [ i_n1 + i_n2 ] + carry NEW_LINE carry = summ // 10 NEW_LINE result [ i_n1 + i_n2 ] = summ % 10 NEW_LINE i_n2 += 1 NEW_LINE DEDENT if ( carry > 0 ) : NEW_LINE INDENT result [ i_n1 + i_n2 ] += carry NEW_LINE DEDENT i_n1 += 1 NEW_LINE DEDENT i = len ( result ) - 1 NEW_LINE while ( i >= 0 and result [ i ] == 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i == - 1 ) : NEW_LINE INDENT return "0" NEW_LINE DEDENT s = " " NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT s += chr ( result [ i ] + 48 ) NEW_LINE i -= 1 NEW_LINE DEDENT return s NEW_LINE DEDENT str1 = "1235421415454545454545454544" NEW_LINE str2 = "1714546546546545454544548544544545" NEW_LINE if ( ( str1 [ 0 ] == ' - ' or str2 [ 0 ] == ' - ' ) and ( str1 [ 0 ] != ' - ' or str2 [ 0 ] != ' - ' ) ) : NEW_LINE INDENT print ( " - " , end = ' ' ) NEW_LINE DEDENT if ( str1 [ 0 ] == ' - ' and str2 [ 0 ] != ' - ' ) : NEW_LINE INDENT str1 = str1 [ 1 : ] NEW_LINE DEDENT elif ( str1 [ 0 ] != ' - ' and str2 [ 0 ] == ' - ' ) : NEW_LINE INDENT str2 = str2 [ 1 : ] NEW_LINE DEDENT elif ( str1 [ 0 ] == ' - ' and str2 [ 0 ] == ' - ' ) : NEW_LINE INDENT str1 = str1 [ 1 : ] NEW_LINE str2 = str2 [ 1 : ] NEW_LINE DEDENT print ( multiply ( str1 , str2 ) ) NEW_LINE
ans = [ ] NEW_LINE def countSieve ( arr , n ) : NEW_LINE INDENT MAX = max ( arr ) NEW_LINE global ans NEW_LINE ans = [ 0 ] * ( MAX + 1 ) NEW_LINE cnt = [ 0 ] * ( MAX + 1 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT cnt [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( 1 , MAX + 1 ) : NEW_LINE INDENT for j in range ( i , MAX + 1 , i ) : NEW_LINE INDENT ans [ i ] += cnt [ j ] NEW_LINE DEDENT DEDENT DEDENT def countMultiples ( k ) : NEW_LINE INDENT return ( ans [ k ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 9 , 15 , 21 , 20 ] NEW_LINE n = len ( arr ) NEW_LINE countSieve ( arr , n ) NEW_LINE k = 2 NEW_LINE print ( countMultiples ( 2 ) ) NEW_LINE k = 3 NEW_LINE print ( countMultiples ( 3 ) ) NEW_LINE k = 5 NEW_LINE print ( countMultiples ( 5 ) ) NEW_LINE DEDENT
import math NEW_LINE def number_of_teams ( M ) : NEW_LINE INDENT N1 , N2 , sqr = 0 , 0 , 0 NEW_LINE sqr = math . sqrt ( 1 + ( 8 * M ) ) NEW_LINE N1 = ( 1 + sqr ) / 2 NEW_LINE N2 = ( 1 - sqr ) / 2 NEW_LINE if ( N1 > 0 ) : NEW_LINE INDENT return int ( N1 ) NEW_LINE DEDENT return int ( N2 ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT M = 45 NEW_LINE print ( number_of_teams ( M ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def _popcnt32 ( number ) : NEW_LINE INDENT counter = 0 NEW_LINE while ( number > 0 ) : NEW_LINE INDENT if ( number % 2 == 1 ) : NEW_LINE INDENT counter = counter + 1 NEW_LINE DEDENT number = int ( number / 2 ) NEW_LINE DEDENT return counter NEW_LINE DEDENT def maximize ( a ) : NEW_LINE INDENT n = _popcnt32 ( a ) NEW_LINE res = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT res = int ( res | ( 1 << ( 32 - i ) ) ) NEW_LINE DEDENT return abs ( res ) NEW_LINE DEDENT a = 1 NEW_LINE print ( maximize ( a ) ) NEW_LINE
def series ( n ) : NEW_LINE INDENT print ( ( 8 * n ** 2 ) + 1 ) NEW_LINE DEDENT series ( 5 ) NEW_LINE
def sortMultiples ( arr , n , x ) : NEW_LINE INDENT v = [ ] NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT v . append ( arr [ i ] ) NEW_LINE DEDENT DEDENT v . sort ( reverse = False ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( arr [ i ] % x == 0 ) : NEW_LINE INDENT arr [ i ] = v [ j ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 125 , 3 , 15 , 6 , 100 , 5 ] NEW_LINE x = 5 NEW_LINE n = len ( arr ) NEW_LINE sortMultiples ( arr , n , x ) NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
power = [ 0 ] * 31 NEW_LINE pre = [ 0 ] * 31 NEW_LINE def PowerOfTwo ( ) : NEW_LINE INDENT x = 1 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT power [ i ] = x NEW_LINE x *= 2 NEW_LINE DEDENT pre [ 0 ] = 1 NEW_LINE for i in range ( 1 , 31 ) : NEW_LINE INDENT pre [ i ] = pre [ i - 1 ] + power [ i ] NEW_LINE DEDENT DEDENT def Sum ( n ) : NEW_LINE INDENT ans = n * ( n + 1 ) // 2 NEW_LINE for i in range ( 31 ) : NEW_LINE INDENT if ( power [ i ] > n ) : NEW_LINE INDENT ans -= 2 * pre [ i - 1 ] NEW_LINE break NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT PowerOfTwo ( ) NEW_LINE n = 4 NEW_LINE print ( Sum ( n ) ) NEW_LINE DEDENT
def DivisibleBy41 ( first , second , c , n ) : NEW_LINE INDENT digit = [ 0 ] * n NEW_LINE digit [ 0 ] = first NEW_LINE digit [ 1 ] = second NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 NEW_LINE DEDENT ans = digit [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT ans = ( ans * 10 + digit [ i ] ) % 41 NEW_LINE DEDENT if ( ans % 41 == 0 ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT first = 1 NEW_LINE second = 2 NEW_LINE c = 1 NEW_LINE n = 3 NEW_LINE if ( DivisibleBy41 ( first , second , c , n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
from math import sqrt NEW_LINE mod = 1000000007 NEW_LINE def mult ( a , b ) : NEW_LINE INDENT return ( ( a % mod ) * ( b % mod ) ) % mod NEW_LINE DEDENT def calculate_factors ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE ans = 1 NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // 2 NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n % i == 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE n = n // i NEW_LINE DEDENT if ( cnt ) : NEW_LINE INDENT ans = mult ( ans , ( cnt + 1 ) ) NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT ans = mult ( ans , 2 ) NEW_LINE DEDENT return ans % mod NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 19374857 NEW_LINE mod = 17 NEW_LINE print ( calculate_factors ( n ) ) NEW_LINE DEDENT
MAX = 100 NEW_LINE def binomialCoeff ( n , C ) : NEW_LINE INDENT C [ 0 ] = 1 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , n ) , - 1 , - 1 ) : NEW_LINE INDENT C [ j ] = C [ j ] + C [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT def summation ( n ) : NEW_LINE INDENT C = [ 0 ] * MAX NEW_LINE binomialCoeff ( n , C ) NEW_LINE sum = 0 NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT sum += ( i * C [ i ] ) NEW_LINE DEDENT return sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 2 NEW_LINE print ( summation ( n ) ) NEW_LINE DEDENT
def digitWell ( n , m , k ) : NEW_LINE INDENT cnt = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT if ( n % 10 == m ) : NEW_LINE INDENT cnt = cnt + 1 ; NEW_LINE DEDENT n = ( int ) ( n / 10 ) ; NEW_LINE DEDENT return cnt == k ; NEW_LINE DEDENT def findInt ( n , m , k ) : NEW_LINE INDENT i = n + 1 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( digitWell ( i , m , k ) ) : NEW_LINE INDENT return i ; NEW_LINE DEDENT i = i + 1 ; NEW_LINE DEDENT DEDENT n = 111 ; m = 2 ; k = 2 ; NEW_LINE print ( findInt ( n , m , k ) ) ; NEW_LINE
class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = next NEW_LINE DEDENT DEDENT def printList ( node ) : NEW_LINE INDENT while ( node != None ) : NEW_LINE INDENT print ( node . data , end = " ▁ " ) NEW_LINE node = node . next NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT def newNode ( key ) : NEW_LINE INDENT temp = Node ( 0 ) NEW_LINE temp . data = key NEW_LINE temp . next = None NEW_LINE return temp NEW_LINE DEDENT def insertBeg ( head , val ) : NEW_LINE INDENT temp = newNode ( val ) NEW_LINE temp . next = head NEW_LINE head = temp NEW_LINE return head NEW_LINE DEDENT def rearrangeOddEven ( head ) : NEW_LINE INDENT odd = [ ] NEW_LINE even = [ ] NEW_LINE i = 1 NEW_LINE while ( head != None ) : NEW_LINE INDENT if ( head . data % 2 != 0 and i % 2 == 0 ) : NEW_LINE INDENT odd . append ( head ) NEW_LINE DEDENT elif ( head . data % 2 == 0 and i % 2 != 0 ) : NEW_LINE INDENT even . append ( head ) NEW_LINE DEDENT head = head . next NEW_LINE i = i + 1 NEW_LINE DEDENT while ( len ( odd ) != 0 and len ( even ) != 0 ) : NEW_LINE INDENT odd [ - 1 ] . data , even [ - 1 ] . data = even [ - 1 ] . data , odd [ - 1 ] . data NEW_LINE odd . pop ( ) NEW_LINE even . pop ( ) NEW_LINE DEDENT return head NEW_LINE DEDENT head = newNode ( 8 ) NEW_LINE head = insertBeg ( head , 7 ) NEW_LINE head = insertBeg ( head , 6 ) NEW_LINE head = insertBeg ( head , 5 ) NEW_LINE head = insertBeg ( head , 3 ) NEW_LINE head = insertBeg ( head , 2 ) NEW_LINE head = insertBeg ( head , 1 ) NEW_LINE print ( " Linked ▁ List : " ) NEW_LINE printList ( head ) NEW_LINE rearrangeOddEven ( head ) NEW_LINE print ( " Linked ▁ List ▁ after ▁ " , " Rearranging : " ) NEW_LINE printList ( head ) NEW_LINE
def digit_product_Sum ( N ) : NEW_LINE INDENT a = [ 0 ] * ( N + 1 ) ; NEW_LINE product = 1 ; NEW_LINE a [ 0 ] = 1 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT product = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( product == 0 ) : NEW_LINE INDENT product = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT product = a [ i - 1 ] % 10 ; NEW_LINE DEDENT val = int ( a [ i - 1 ] / 10 ) ; NEW_LINE if ( val == 0 ) : NEW_LINE INDENT val = a [ i - 1 ] ; NEW_LINE DEDENT a [ i ] = a [ i - 1 ] + ( val * product ) ; NEW_LINE DEDENT for i in range ( N ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT N = 10 ; NEW_LINE digit_product_Sum ( N ) ; NEW_LINE
def SquareCube ( N ) : NEW_LINE INDENT cnt , i = 0 , 1 NEW_LINE while ( i ** 6 <= N ) : NEW_LINE INDENT cnt += 1 NEW_LINE i += 1 NEW_LINE DEDENT return cnt NEW_LINE DEDENT N = 100000 NEW_LINE print ( SquareCube ( N ) ) NEW_LINE
def createHash ( hash1 , maxElement ) : NEW_LINE INDENT prev , curr = 0 , 1 NEW_LINE hash1 . add ( prev ) NEW_LINE hash1 . add ( curr ) NEW_LINE while ( curr < maxElement ) : NEW_LINE INDENT temp = curr + prev NEW_LINE hash1 . add ( temp ) NEW_LINE prev = curr NEW_LINE curr = temp NEW_LINE DEDENT DEDENT def findFibonacciPair ( n ) : NEW_LINE INDENT hash1 = set ( ) NEW_LINE createHash ( hash1 , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( i in hash1 and ( n - i ) in hash1 ) : NEW_LINE INDENT print ( i , " , ▁ " , ( n - i ) ) NEW_LINE return NEW_LINE DEDENT DEDENT print ( " - 1" ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 90 NEW_LINE findFibonacciPair ( N ) NEW_LINE DEDENT
def Max_Sum ( a , n ) : NEW_LINE INDENT b = [ 0 for i in range ( n ) ] NEW_LINE S = 0 NEW_LINE res = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT b [ i ] = res NEW_LINE res += a [ i ] NEW_LINE S += a [ i ] NEW_LINE res = max ( res , - S ) NEW_LINE DEDENT ans = S NEW_LINE ans = max ( ans , res ) NEW_LINE g = 0 NEW_LINE for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT g -= a [ i ] NEW_LINE ans = max ( ans , g + b [ i ] ) NEW_LINE DEDENT return ans NEW_LINE DEDENT a = [ - 6 , 10 , - 3 , 10 , - 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( " Maximum ▁ sum ▁ is : " , Max_Sum ( a , n ) ) NEW_LINE
def permutatedRows ( mat , m , n , r ) : NEW_LINE INDENT s = set ( ) NEW_LINE for j in range ( n ) : NEW_LINE INDENT s . add ( mat [ r ] [ j ] ) NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if i == r : NEW_LINE INDENT continue NEW_LINE DEDENT for j in range ( n ) : NEW_LINE INDENT if mat [ i ] [ j ] not in s : NEW_LINE INDENT j = j - 2 NEW_LINE break ; NEW_LINE DEDENT DEDENT if j + 1 != n : NEW_LINE INDENT continue NEW_LINE DEDENT print ( i ) NEW_LINE DEDENT DEDENT m = 4 NEW_LINE n = 4 NEW_LINE r = 3 NEW_LINE mat = [ [ 3 , 1 , 4 , 2 ] , [ 1 , 6 , 9 , 3 ] , [ 1 , 2 , 3 , 4 ] , [ 4 , 3 , 2 , 1 ] ] NEW_LINE permutatedRows ( mat , m , n , r ) NEW_LINE
def mergeIntervals ( arr ) : NEW_LINE INDENT arr . sort ( key = lambda x : x [ 0 ] ) NEW_LINE m = [ ] NEW_LINE s = - 10000 NEW_LINE max = - 100000 NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT a = arr [ i ] NEW_LINE if a [ 0 ] > max : NEW_LINE INDENT if i != 0 : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT max = a [ 1 ] NEW_LINE s = a [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT if a [ 1 ] >= max : NEW_LINE INDENT max = a [ 1 ] NEW_LINE DEDENT DEDENT DEDENT if max != - 100000 and [ s , max ] not in m : NEW_LINE INDENT m . append ( [ s , max ] ) NEW_LINE DEDENT print ( " The ▁ Merged ▁ Intervals ▁ are ▁ : " , end = " ▁ " ) NEW_LINE for i in range ( len ( m ) ) : NEW_LINE INDENT print ( m [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ [ 6 , 8 ] , [ 1 , 9 ] , [ 2 , 4 ] , [ 4 , 7 ] ] NEW_LINE mergeIntervals ( arr ) NEW_LINE
MAX = 1000000 NEW_LINE prime = [ True ] * ( MAX + 1 ) NEW_LINE def SieveOfEratosthenes ( ) : NEW_LINE INDENT prime [ 1 ] = False NEW_LINE p = 2 NEW_LINE c = 0 NEW_LINE while ( p * p <= MAX ) : NEW_LINE INDENT c += 1 NEW_LINE if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , MAX + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT p += 1 NEW_LINE DEDENT DEDENT def findDiff ( arr , n ) : NEW_LINE INDENT min = MAX + 2 NEW_LINE max = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] == True ) : NEW_LINE INDENT if ( arr [ i ] > max ) : NEW_LINE INDENT max = arr [ i ] NEW_LINE DEDENT if ( arr [ i ] < min ) : NEW_LINE INDENT min = arr [ i ] NEW_LINE DEDENT DEDENT DEDENT return - 1 if ( max == - 1 ) else ( max - min ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT SieveOfEratosthenes ( ) NEW_LINE n = 4 NEW_LINE arr = [ 1 , 2 , 3 , 5 ] NEW_LINE res = findDiff ( arr , n ) NEW_LINE if ( res == - 1 ) : NEW_LINE INDENT print ( " No ▁ prime ▁ numbers " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Difference ▁ is ▁ " , res ) NEW_LINE DEDENT DEDENT
from math import sqrt NEW_LINE def find_Area ( a ) : NEW_LINE INDENT R = a * ( 2.0 - sqrt ( 2 ) ) ; NEW_LINE area = 3.14 * R * R / 2.0 ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = 4 ; NEW_LINE print ( " Area ▁ of ▁ semicircle ▁ = " , find_Area ( a ) ) ; NEW_LINE DEDENT
from math import log2 NEW_LINE discard_count = 0 NEW_LINE def power ( a , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT p = power ( a , n // 2 ) NEW_LINE p = p * p NEW_LINE if ( n & 1 ) : NEW_LINE INDENT p = p * a NEW_LINE DEDENT return p NEW_LINE DEDENT def solve ( i , n , sum , k , a , prefix ) : NEW_LINE INDENT global discard_count NEW_LINE if ( sum > k ) : NEW_LINE INDENT discard_count += power ( 2 , n - i ) NEW_LINE return ; NEW_LINE DEDENT if ( i == n ) : NEW_LINE INDENT return NEW_LINE DEDENT rem = prefix [ n - 1 ] - prefix [ i ] NEW_LINE if ( sum + a [ i ] + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) NEW_LINE DEDENT if ( sum + rem > k ) : NEW_LINE INDENT solve ( i + 1 , n , sum , k , a , prefix ) NEW_LINE DEDENT DEDENT def countSubsequences ( arr , n , K ) : NEW_LINE INDENT sum = 0.0 NEW_LINE k = log2 ( K ) NEW_LINE prefix = [ 0 ] * n NEW_LINE a = [ 0 ] * n NEW_LINE for i in range ( n ) : NEW_LINE INDENT a [ i ] = log2 ( arr [ i ] ) NEW_LINE sum += a [ i ] NEW_LINE DEDENT prefix [ 0 ] = a [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT prefix [ i ] = prefix [ i - 1 ] + a [ i ] NEW_LINE DEDENT total = power ( 2 , n ) - 1 NEW_LINE if ( sum <= k ) : NEW_LINE INDENT return total NEW_LINE DEDENT solve ( 0 , n , 0.0 , k , a , prefix ) NEW_LINE return total - discard_count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 8 , 7 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE k = 50 ; NEW_LINE print ( countSubsequences ( arr , n , k ) ) NEW_LINE DEDENT
def tribWord ( n ) : NEW_LINE INDENT Sn_1 = "1" NEW_LINE Sn_2 = "12" NEW_LINE Sn_3 = "1213" NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT tmp = Sn_3 NEW_LINE Sn_3 += ( Sn_2 + Sn_1 ) NEW_LINE Sn_1 = Sn_2 NEW_LINE Sn_2 = tmp NEW_LINE DEDENT return Sn_3 NEW_LINE DEDENT n = 6 NEW_LINE print ( tribWord ( n ) ) NEW_LINE
def interchangeFirstLast ( mat , n , m ) : NEW_LINE INDENT rows = n NEW_LINE for i in range ( n ) : NEW_LINE INDENT t = mat [ 0 ] [ i ] NEW_LINE mat [ 0 ] [ i ] = mat [ rows - 1 ] [ i ] NEW_LINE mat [ rows - 1 ] [ i ] = t NEW_LINE DEDENT DEDENT mat = [ [ 8 , 9 , 7 , 6 ] , [ 4 , 7 , 6 , 5 ] , [ 3 , 2 , 1 , 8 ] , [ 9 , 9 , 7 , 7 ] ] NEW_LINE n = 4 NEW_LINE m = 4 NEW_LINE interchangeFirstLast ( mat , n , m ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( m ) : NEW_LINE INDENT print ( mat [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " ) NEW_LINE DEDENT
def minimumValue ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE answer = 0 ; NEW_LINE for i in range ( k ) : NEW_LINE INDENT answer += arr [ i ] * arr [ i ] ; NEW_LINE DEDENT return answer * ( 2 * k - 2 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 21 , 5 , 3 , 8 ] ; NEW_LINE k = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( minimumValue ( arr , n , k ) ) ; NEW_LINE DEDENT
import math NEW_LINE def findRadiusOfcircumcircle ( l , b ) : NEW_LINE INDENT if ( l < 0 or b < 0 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT radius = ( math . sqrt ( pow ( l , 2 ) + pow ( b , 2 ) ) / 2 ) ; NEW_LINE return radius ; NEW_LINE DEDENT l = 4 ; NEW_LINE b = 3 ; NEW_LINE print ( findRadiusOfcircumcircle ( l , b ) ) ; NEW_LINE
def __gcd ( a , b ) : NEW_LINE INDENT if ( a == 0 or b == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( a == b ) : NEW_LINE INDENT return a NEW_LINE DEDENT if ( a > b ) : NEW_LINE INDENT return __gcd ( a - b , b ) NEW_LINE DEDENT return __gcd ( a , b - a ) NEW_LINE DEDENT def findValue ( x , y , z ) : NEW_LINE INDENT g = __gcd ( y , z ) NEW_LINE return ( x * g ) / __gcd ( x , g ) NEW_LINE DEDENT x = 30 NEW_LINE y = 40 NEW_LINE z = 400 NEW_LINE print ( " % d " % findValue ( x , y , z ) ) NEW_LINE
from math import pow , sqrt NEW_LINE def area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT area = 3.14 * pow ( r / ( 2 * sqrt ( 2 ) ) , 2 ) ; NEW_LINE return area ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 5 NEW_LINE print ( " { 0 : . 6 } " . format ( area ( a ) ) ) NEW_LINE DEDENT
def calculate_min_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE min_sum = 0 NEW_LINE for i in range ( 1 , n , 2 ) : NEW_LINE INDENT min_sum += abs ( a [ i ] - a [ i - 1 ] ) NEW_LINE DEDENT return min_sum NEW_LINE DEDENT def calculate_max_sum ( a , n ) : NEW_LINE INDENT a . sort ( ) NEW_LINE max_sum = 0 NEW_LINE for i in range ( n // 2 ) : NEW_LINE INDENT max_sum += abs ( a [ n - 1 - i ] - a [ i ] ) NEW_LINE DEDENT return max_sum NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , - 10 , 20 , - 40 ] NEW_LINE n = len ( a ) NEW_LINE print ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is " , calculate_min_sum ( a , n ) ) NEW_LINE print ( " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is " , calculate_max_sum ( a , n ) ) NEW_LINE DEDENT
def sumOfDigits ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT res += n % 10 NEW_LINE n /= 10 NEW_LINE DEDENT return res ; NEW_LINE DEDENT def findNumber ( n ) : NEW_LINE INDENT i = n - 1 ; NEW_LINE while ( i > 0 ) : NEW_LINE INDENT if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) : NEW_LINE INDENT return i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 824 ; NEW_LINE print ( findNumber ( n ) ) NEW_LINE DEDENT
def getMaxLength ( arr , n ) : NEW_LINE INDENT l = n ; NEW_LINE i = 0 ; maxlen = 0 ; NEW_LINE while ( i < l ) : NEW_LINE INDENT j = i ; NEW_LINE while ( i + 1 < l and ( abs ( arr [ i ] - arr [ i + 1 ] ) == 1 or abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT currLen = i - j + 1 ; NEW_LINE if ( maxlen < currLen ) : NEW_LINE INDENT maxlen = currLen ; NEW_LINE DEDENT if ( j == i ) : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT return maxlen ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 ] ; NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) ; NEW_LINE DEDENT
class newNode : NEW_LINE INDENT def __init__ ( self , key ) : NEW_LINE INDENT self . key = key NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def isSymmetric ( root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( not root . left and not root . right ) : NEW_LINE INDENT return True NEW_LINE DEDENT q = [ ] NEW_LINE q . append ( root ) NEW_LINE q . append ( root ) NEW_LINE leftNode = 0 NEW_LINE rightNode = 0 NEW_LINE while ( not len ( q ) ) : NEW_LINE INDENT leftNode = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE rightNode = q [ 0 ] NEW_LINE q . pop ( 0 ) NEW_LINE if ( leftNode . key != rightNode . key ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( leftNode . left and rightNode . right ) : NEW_LINE INDENT q . append ( leftNode . left ) NEW_LINE q . append ( rightNode . right ) NEW_LINE DEDENT elif ( leftNode . left or rightNode . right ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( leftNode . right and rightNode . left ) : NEW_LINE INDENT q . append ( leftNode . right ) NEW_LINE q . append ( rightNode . left ) NEW_LINE DEDENT elif ( leftNode . right or rightNode . left ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT root = newNode ( 1 ) NEW_LINE root . left = newNode ( 2 ) NEW_LINE root . right = newNode ( 2 ) NEW_LINE root . left . left = newNode ( 3 ) NEW_LINE root . left . right = newNode ( 4 ) NEW_LINE root . right . left = newNode ( 4 ) NEW_LINE root . right . right = newNode ( 3 ) NEW_LINE if ( isSymmetric ( root ) ) : NEW_LINE INDENT print ( " The ▁ given ▁ tree ▁ is ▁ Symmetric " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " The ▁ given ▁ tree ▁ is ▁ not ▁ Symmetric " ) NEW_LINE DEDENT DEDENT
def numberOfSquares ( base ) : NEW_LINE INDENT base = ( base - 2 ) NEW_LINE base = base / 2 NEW_LINE return base * ( base + 1 ) / 2 NEW_LINE DEDENT base = 8 NEW_LINE print ( numberOfSquares ( base ) ) NEW_LINE
def modInverse ( a , prime ) : NEW_LINE INDENT a = a % prime NEW_LINE for x in range ( 1 , prime ) : NEW_LINE INDENT if ( ( a * x ) % prime == 1 ) : NEW_LINE INDENT return x NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT def printModIverses ( n , prime ) : NEW_LINE INDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( modInverse ( i , prime ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE prime = 17 NEW_LINE printModIverses ( n , prime ) NEW_LINE
import math NEW_LINE def arcLength ( diameter , angle ) : NEW_LINE INDENT if angle >= 360 : NEW_LINE INDENT print ( " Angle ▁ cannot ▁ be ▁ formed " ) NEW_LINE return 0 NEW_LINE DEDENT else : NEW_LINE INDENT arc = ( 3.142857142857143 * diameter ) * ( angle / 360.0 ) NEW_LINE return arc NEW_LINE DEDENT DEDENT diameter = 25.0 NEW_LINE angle = 45.0 NEW_LINE arc_len = arcLength ( diameter , angle ) NEW_LINE print ( arc_len ) NEW_LINE
from math import gcd , sqrt NEW_LINE def countBits ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( ( n & 1 ) == 0 ) + countBits ( n >> 1 ) ) NEW_LINE DEDENT DEDENT def maxGcd ( n ) : NEW_LINE INDENT if ( countBits ( n ) == 0 ) : NEW_LINE INDENT for i in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT return int ( n / i ) NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT val = 0 NEW_LINE power = 1 NEW_LINE dupn = n NEW_LINE while ( n ) : NEW_LINE INDENT if ( ( n & 1 ) == 0 ) : NEW_LINE INDENT val += power NEW_LINE DEDENT power = power * 2 NEW_LINE n = n >> 1 NEW_LINE DEDENT return gcd ( val ^ dupn , val & dupn ) NEW_LINE DEDENT return 1 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE print ( maxGcd ( n ) ) NEW_LINE n = 15 NEW_LINE print ( maxGcd ( n ) ) NEW_LINE DEDENT
import math NEW_LINE def findNumberOfDigits ( n , base ) : NEW_LINE INDENT dig = ( math . floor ( math . log ( n ) / math . log ( base ) ) + 1 ) NEW_LINE print ( " The ▁ Number ▁ of ▁ digits ▁ of " . format ( n , base , dig ) ) DEDENT n = 1446 NEW_LINE base = 7 NEW_LINE findNumberOfDigits ( n , base ) NEW_LINE
MAX = 256 ; NEW_LINE def lastNonRepeating ( string , n ) : NEW_LINE INDENT freq = [ 0 ] * MAX ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ ord ( string [ i ] ) ] += 1 ; NEW_LINE DEDENT for i in range ( n - 1 , - 1 , - 1 ) : NEW_LINE INDENT ch = string [ i ] ; NEW_LINE if ( freq [ ord ( ch ) ] == 1 ) : NEW_LINE INDENT return ( " " + ch ) ; NEW_LINE DEDENT DEDENT return " - 1" ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " GeeksForGeeks " ; NEW_LINE n = len ( string ) ; NEW_LINE print ( lastNonRepeating ( string , n ) ) ; NEW_LINE DEDENT
n = 5 NEW_LINE def diagonalsMinMax ( mat ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT principalMin = mat [ 0 ] [ 0 ] NEW_LINE principalMax = mat [ 0 ] [ 0 ] NEW_LINE secondaryMin = mat [ n - 1 ] [ 0 ] NEW_LINE secondaryMax = mat [ n - 1 ] [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mat [ i ] [ i ] < principalMin ) : NEW_LINE INDENT principalMin = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ i ] [ i ] > principalMax ) : NEW_LINE INDENT principalMax = mat [ i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) : NEW_LINE INDENT secondaryMin = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) : NEW_LINE INDENT secondaryMax = mat [ n - 1 - i ] [ i ] NEW_LINE DEDENT DEDENT print ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , principalMin ) NEW_LINE print ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " , principalMax ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " , secondaryMin ) NEW_LINE print ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " , secondaryMax ) NEW_LINE DEDENT matrix = [ [ 1 , 2 , 3 , 4 , - 10 ] , [ 5 , 6 , 7 , 8 , 6 ] , [ 1 , 2 , 11 , 3 , 4 ] , [ 5 , 6 , 70 , 5 , 8 ] , [ 4 , 9 , 7 , 1 , - 5 ] ] NEW_LINE diagonalsMinMax ( matrix ) NEW_LINE
def getNthTerm ( N ) : NEW_LINE INDENT return ( pow ( N , 2 ) + N + 1 ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 11 NEW_LINE print ( getNthTerm ( N ) ) NEW_LINE DEDENT
def findOddPair ( A , N ) : NEW_LINE INDENT oddPair = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT for j in range ( i + 1 , N ) : NEW_LINE INDENT if ( ( A [ i ] | A [ j ] ) % 2 != 0 ) : NEW_LINE INDENT oddPair += 1 NEW_LINE DEDENT DEDENT DEDENT return oddPair NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT A = [ 5 , 6 , 2 , 8 ] NEW_LINE N = len ( A ) NEW_LINE print ( findOddPair ( A , N ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def init ( degree , edges , n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT degree [ i ] = 0 ; NEW_LINE DEDENT for i in range ( len ( edges ) ) : NEW_LINE INDENT degree [ edges [ i ] [ 0 ] ] += 1 ; NEW_LINE degree [ edges [ i ] [ 1 ] ] += 1 ; NEW_LINE DEDENT DEDENT def performQueries ( edges , q , n ) : NEW_LINE INDENT degree = [ 0 ] * n ; NEW_LINE init ( degree , edges , n ) ; NEW_LINE for i in range ( len ( q ) ) : NEW_LINE INDENT node = q [ i ] ; NEW_LINE if ( node == 0 ) : NEW_LINE INDENT print ( " No " ) ; NEW_LINE continue ; NEW_LINE DEDENT if ( degree [ node ] == 1 ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 ; NEW_LINE edges = [ [ 0 , 1 ] , [ 0 , 2 ] , [ 1 , 3 ] , [ 1 , 4 ] , [ 4 , 5 ] ] ; NEW_LINE q = [ 0 , 3 , 4 , 5 ] ; NEW_LINE performQueries ( edges , q , n ) ; NEW_LINE DEDENT
def KnapSack ( val , wt , n , W ) : NEW_LINE INDENT mat = [ [ 0 for i in range ( W + 1 ) ] for i in range ( 2 ) ] NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT j = 0 NEW_LINE if i % 2 == 0 : NEW_LINE INDENT while j < W : NEW_LINE INDENT j += 1 NEW_LINE if wt [ i ] <= j : NEW_LINE INDENT mat [ 1 ] [ j ] = max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 1 ] [ j ] = mat [ 0 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT while j < W : NEW_LINE INDENT j += 1 NEW_LINE if wt [ i ] <= j : NEW_LINE INDENT mat [ 0 ] [ j ] = max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) NEW_LINE DEDENT else : NEW_LINE INDENT mat [ 0 ] [ j ] = mat [ 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT i += 1 NEW_LINE DEDENT if n % 2 == 0 : NEW_LINE INDENT return mat [ 0 ] [ W ] NEW_LINE DEDENT else : NEW_LINE INDENT return mat [ 1 ] [ W ] NEW_LINE DEDENT DEDENT val = [ 7 , 8 , 4 ] NEW_LINE wt = [ 3 , 8 , 6 ] NEW_LINE W = 10 NEW_LINE n = 3 NEW_LINE print ( KnapSack ( val , wt , n , W ) ) NEW_LINE
def numberOfPaths ( m , n ) : NEW_LINE INDENT if ( m == 1 or n == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) NEW_LINE DEDENT m = 3 NEW_LINE n = 3 NEW_LINE print ( numberOfPaths ( m , n ) ) NEW_LINE
def minimumCost ( cost , n ) : NEW_LINE INDENT dp = [ None ] * n NEW_LINE if n == 1 : NEW_LINE INDENT return cost [ 0 ] NEW_LINE DEDENT dp [ 0 ] = cost [ 0 ] NEW_LINE dp [ 1 ] = cost [ 1 ] NEW_LINE for i in range ( 2 , n ) : NEW_LINE INDENT dp [ i ] = min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] NEW_LINE DEDENT return min ( dp [ n - 2 ] , dp [ n - 1 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 16 , 19 , 10 , 12 , 18 ] NEW_LINE n = len ( a ) NEW_LINE print ( minimumCost ( a , n ) ) NEW_LINE DEDENT
def sum ( x , n ) : NEW_LINE INDENT total = 1.0 ; NEW_LINE previous = 1.0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT previous = ( previous * x ) / ( i + 1 ) ; NEW_LINE total = total + previous ; NEW_LINE DEDENT return total ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 ; NEW_LINE n = 4 ; NEW_LINE print ( " Sum ▁ is : ▁ " , sum ( x , n ) ) ; NEW_LINE DEDENT
def countIncreasing ( arr , n ) : NEW_LINE INDENT cnt = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if arr [ j ] > arr [ j - 1 ] : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT return cnt NEW_LINE DEDENT arr = [ 1 , 2 , 2 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is " , countIncreasing ( arr , n ) ) NEW_LINE
def isBinary ( number ) : NEW_LINE INDENT while ( number > 0 ) : NEW_LINE INDENT digit = number % 10 NEW_LINE if ( digit > 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT number //= 10 NEW_LINE DEDENT return True NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 1000111 NEW_LINE if ( isBinary ( n ) == 1 ) : NEW_LINE INDENT print ( " true " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) NEW_LINE DEDENT DEDENT
def isVowel ( c ) : NEW_LINE INDENT vowel = " aeiou " NEW_LINE for i in range ( len ( vowel ) ) : NEW_LINE INDENT if ( vowel [ i ] == c ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def printRLE ( str , typed ) : NEW_LINE INDENT n = len ( str ) NEW_LINE m = len ( typed ) NEW_LINE j = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if str [ i ] != typed [ j ] : NEW_LINE INDENT return False NEW_LINE DEDENT if isVowel ( str [ i ] ) == False : NEW_LINE INDENT j = j + 1 NEW_LINE continue NEW_LINE DEDENT count1 = 1 NEW_LINE while ( i < n - 1 and ( str [ i ] == str [ i + 1 ] ) ) : NEW_LINE INDENT count1 = count1 + 1 NEW_LINE i = i + 1 NEW_LINE DEDENT count2 = 1 NEW_LINE while ( j < m - 1 and typed [ j ] == str [ i ] ) : NEW_LINE INDENT count2 = count2 + 1 NEW_LINE j = j + 1 NEW_LINE DEDENT if count1 > count2 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT name = " alex " NEW_LINE typed = " aaalaeex " NEW_LINE if ( printRLE ( name , typed ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def avg_of_even_num ( n ) : NEW_LINE INDENT return n + 1 NEW_LINE DEDENT n = 8 NEW_LINE print ( avg_of_even_num ( n ) ) NEW_LINE
def solve ( n , base ) : NEW_LINE INDENT result = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT remainder = n % base NEW_LINE result = result + remainder NEW_LINE n = int ( n / base ) NEW_LINE DEDENT return result NEW_LINE DEDENT def printSumsOfDigits ( n ) : NEW_LINE INDENT for base in range ( 2 , n ) : NEW_LINE INDENT print ( solve ( n , base ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 8 NEW_LINE printSumsOfDigits ( n ) NEW_LINE
def printDiamond ( n ) : NEW_LINE INDENT print ( " " ) NEW_LINE j = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for j in range ( 0 , 2 * i + 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , n ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT for i in range ( 0 , n - 1 ) : NEW_LINE INDENT for j in range ( 0 , i + 2 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT for j in range ( 0 , 2 * ( n - 1 - i ) - 1 ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( 0 , i + 2 ) : NEW_LINE INDENT print ( " * " , end = " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT print ( " " ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( " Inverse ▁ Diamond ▁ Pattern ▁ for ▁ n ▁ = ▁ " , n ) NEW_LINE printDiamond ( n ) NEW_LINE n = 7 NEW_LINE print ( " \n Inverse ▁ Diamond ▁ Pattern ▁ for ▁ n ▁ = ▁ " , n ) NEW_LINE printDiamond ( n ) NEW_LINE DEDENT
def center_pentadecagonal_num ( n ) : NEW_LINE INDENT return ( 15 * n * n - 15 * n + 2 ) // 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 NEW_LINE print ( n , " rd ▁ number ▁ : ▁ " , center_pentadecagonal_num ( n ) ) NEW_LINE n = 10 NEW_LINE print ( n , " th ▁ number ▁ : ▁ " , center_pentadecagonal_num ( n ) ) NEW_LINE DEDENT
def findevenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT oddCount = count * ( count - 1 ) / 2 NEW_LINE return ( int ) ( ( N * ( N - 1 ) / 2 ) - oddCount ) NEW_LINE DEDENT a = [ 5 , 1 , 3 , 2 ] NEW_LINE n = len ( a ) NEW_LINE print ( findevenPair ( a , n ) ) NEW_LINE
from math import sqrt NEW_LINE def pairCount ( arr , n ) : NEW_LINE INDENT max_val = arr [ 0 ] NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT if ( arr [ i ] > max_val ) : NEW_LINE INDENT max_val = arr [ i ] NEW_LINE DEDENT DEDENT prime = [ True for i in range ( max_val + 1 ) ] NEW_LINE prime [ 0 ] = False NEW_LINE prime [ 1 ] = False NEW_LINE k = int ( sqrt ( max_val ) ) + 1 NEW_LINE for p in range ( 2 , k , 1 ) : NEW_LINE INDENT if ( prime [ p ] == True ) : NEW_LINE INDENT for i in range ( p * 2 , max_val + 1 , p ) : NEW_LINE INDENT prime [ i ] = False NEW_LINE DEDENT DEDENT DEDENT count = 0 NEW_LINE for i in range ( 0 , n , 1 ) : NEW_LINE INDENT if ( prime [ arr [ i ] ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT return ( count * ( count - 1 ) ) / 2 NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE print ( int ( pairCount ( arr , n ) ) ) NEW_LINE DEDENT
import math NEW_LINE def GIF ( n ) : NEW_LINE INDENT return int ( math . floor ( n ) ) ; NEW_LINE DEDENT n = 2.3 ; NEW_LINE print ( GIF ( n ) ) ; NEW_LINE
def min_element ( a ) : NEW_LINE INDENT m = 10000000 NEW_LINE for i in range ( 0 , len ( a ) ) : NEW_LINE INDENT if ( a [ i ] < m ) : NEW_LINE INDENT m = a [ i ] NEW_LINE DEDENT DEDENT return m NEW_LINE DEDENT def findSmallest ( a , n ) : NEW_LINE INDENT smallest = min_element ( a ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( a [ i ] % smallest >= 1 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT return smallest NEW_LINE DEDENT a = [ 25 , 20 , 5 , 10 , 100 ] NEW_LINE n = len ( a ) NEW_LINE print ( findSmallest ( a , n ) ) NEW_LINE
import sys NEW_LINE def MatrixChainOrder ( p , n ) : NEW_LINE INDENT m = [ [ 0 for x in range ( n ) ] for x in range ( n ) ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT m [ i ] [ i ] = 0 NEW_LINE DEDENT for L in range ( 2 , n ) : NEW_LINE INDENT for i in range ( 1 , n - L + 1 ) : NEW_LINE INDENT j = i + L - 1 NEW_LINE m [ i ] [ j ] = sys . maxint NEW_LINE for k in range ( i , j ) : NEW_LINE INDENT q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] NEW_LINE if q < m [ i ] [ j ] : NEW_LINE INDENT m [ i ] [ j ] = q NEW_LINE DEDENT DEDENT DEDENT DEDENT return m [ 1 ] [ n - 1 ] NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 ] NEW_LINE size = len ( arr ) NEW_LINE print ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + str ( MatrixChainOrder ( arr , size ) ) ) NEW_LINE
def numbers ( n , arr , m ) : NEW_LINE INDENT isZero = 0 NEW_LINE isFive = 0 NEW_LINE result = 0 NEW_LINE if ( m < n ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT for i in range ( m ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT isZero = 1 NEW_LINE DEDENT if ( arr [ i ] == 5 ) : NEW_LINE INDENT isFive = 1 NEW_LINE DEDENT DEDENT if ( isZero and isFive ) : NEW_LINE INDENT result = 2 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT m -= 1 NEW_LINE result = result * ( m ) NEW_LINE DEDENT DEDENT elif ( isZero or isFive ) : NEW_LINE INDENT result = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT m -= 1 NEW_LINE result = result * ( m ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT result = - 1 NEW_LINE DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE m = 6 NEW_LINE arr = [ 2 , 3 , 5 , 6 , 7 , 9 ] NEW_LINE print ( numbers ( n , arr , m ) ) NEW_LINE DEDENT
def findMinRemoval ( arr , n ) : NEW_LINE INDENT value = 0 NEW_LINE maximum = 0 NEW_LINE if ( n == 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( i != 0 and i != n - 1 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = ( abs ( arr [ i ] - arr [ i + 1 ] ) + abs ( arr [ i ] - arr [ i - 1 ] ) - abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ) NEW_LINE DEDENT elif ( i == 0 ) : NEW_LINE INDENT value = value + abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE temp = abs ( arr [ i ] - arr [ i + 1 ] ) NEW_LINE DEDENT else : NEW_LINE INDENT temp = abs ( arr [ i ] - arr [ i - 1 ] ) NEW_LINE DEDENT maximum = max ( maximum , temp ) NEW_LINE DEDENT return ( value - maximum ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 5 , 3 , 2 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMinRemoval ( arr , n ) ) NEW_LINE DEDENT
def getOddOccurrence ( arr , arr_size ) : NEW_LINE INDENT for i in range ( 0 , arr_size ) : NEW_LINE INDENT count = 0 NEW_LINE for j in range ( 0 , arr_size ) : NEW_LINE INDENT if arr [ i ] == arr [ j ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT if ( count % 2 != 0 ) : NEW_LINE INDENT return arr [ i ] NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getOddOccurrence ( arr , n ) ) NEW_LINE
def ComputePrefixXor ( arr , PrefixXor , n ) : NEW_LINE INDENT PrefixXor [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] ; NEW_LINE DEDENT DEDENT def Xor_Sum ( arr , n ) : NEW_LINE INDENT PrefixXor = [ 0 ] * n ; NEW_LINE ComputePrefixXor ( arr , PrefixXor , n ) ; NEW_LINE sum , index = 0 , 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) : NEW_LINE INDENT sum = PrefixXor [ i ] + \ NEW_LINE INDENT ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) ; NEW_LINE DEDENT index = i ; NEW_LINE DEDENT DEDENT return index + 1 ; NEW_LINE DEDENT arr = [ 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Xor_Sum ( arr , n ) ) ; NEW_LINE
def LucasSum ( N ) : NEW_LINE INDENT Sum = 0 NEW_LINE a = 2 NEW_LINE b = 1 NEW_LINE c = 0 NEW_LINE Sum += a NEW_LINE while ( b <= N ) : NEW_LINE INDENT Sum += b NEW_LINE c = a + b NEW_LINE a = b NEW_LINE b = c NEW_LINE DEDENT return Sum NEW_LINE DEDENT N = 20 NEW_LINE print ( LucasSum ( N ) ) NEW_LINE
def isPalindrome ( str ) : NEW_LINE INDENT l = 0 NEW_LINE h = len ( str ) - 1 NEW_LINE while ( h > l ) : NEW_LINE INDENT if ( str [ l ] != str [ h ] ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT l = l + 1 NEW_LINE h = h - 1 NEW_LINE DEDENT return 1 NEW_LINE DEDENT def minRemovals ( str ) : NEW_LINE INDENT if ( str [ 0 ] == ' ' ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT if ( isPalindrome ( str ) ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 2 NEW_LINE DEDENT print ( minRemovals ( "010010" ) ) NEW_LINE print ( minRemovals ( "0100101" ) ) NEW_LINE
import math NEW_LINE def pronic_check ( n ) : NEW_LINE INDENT x = ( int ) ( math . sqrt ( n ) ) NEW_LINE if ( x * ( x + 1 ) == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT n = 56 NEW_LINE if ( pronic_check ( n ) == True ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT
def centered_square_num ( n ) : NEW_LINE INDENT return n * n + ( ( n - 1 ) * ( n - 1 ) ) NEW_LINE DEDENT n = 7 NEW_LINE print ( " % sth ▁ Centered ▁ square ▁ number : ▁ " % n , centered_square_num ( n ) ) NEW_LINE
def solve ( interval , N , Q ) : NEW_LINE INDENT Mark = [ 0 for i in range ( Q ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE for j in range ( l , r + 1 ) : NEW_LINE INDENT Mark [ j ] += 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for i in range ( Q ) : NEW_LINE INDENT if ( Mark [ i ] ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT count1 = [ 0 for i in range ( Q ) ] NEW_LINE if ( Mark [ 0 ] == 1 ) : NEW_LINE INDENT count1 [ 0 ] = 1 NEW_LINE DEDENT for i in range ( 1 , Q ) : NEW_LINE INDENT if ( Mark [ i ] == 1 ) : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT count1 [ i ] = count1 [ i - 1 ] NEW_LINE DEDENT DEDENT maxindex = 0 NEW_LINE maxcoverage = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT l = interval [ i ] [ 0 ] - 1 NEW_LINE r = interval [ i ] [ 1 ] - 1 NEW_LINE elem1 = 0 NEW_LINE if ( l != 0 ) : NEW_LINE INDENT elem1 = count1 [ r ] - count1 [ l - 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT elem1 = count1 [ r ] NEW_LINE DEDENT if ( count - elem1 >= maxcoverage ) : NEW_LINE INDENT maxcoverage = count - elem1 NEW_LINE maxindex = i NEW_LINE DEDENT DEDENT print ( " Maximum ▁ Coverage ▁ is " , maxcoverage , " after ▁ removing ▁ interval ▁ at ▁ index " , maxindex ) NEW_LINE DEDENT interval = [ [ 1 , 4 ] , [ 4 , 5 ] , [ 5 , 6 ] , [ 6 , 7 ] , [ 3 , 5 ] ] NEW_LINE N = len ( interval ) NEW_LINE Q = 7 NEW_LINE solve ( interval , N , Q ) NEW_LINE
import collections NEW_LINE def minIncrementForUnique ( A ) : NEW_LINE INDENT count = collections . Counter ( A ) NEW_LINE taken = [ ] NEW_LINE ans = 0 NEW_LINE for x in range ( 100000 ) : NEW_LINE INDENT if count [ x ] >= 2 : NEW_LINE INDENT taken . extend ( [ x ] * ( count [ x ] - 1 ) ) NEW_LINE DEDENT elif taken and count [ x ] == 0 : NEW_LINE INDENT ans += x - taken . pop ( ) NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT A = [ 3 , 2 , 1 , 2 , 1 , 7 ] NEW_LINE print ( minIncrementForUnique ( A ) ) NEW_LINE
from math import gcd as __gcd NEW_LINE def findLargest ( arr , n ) : NEW_LINE INDENT gcd = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT gcd = __gcd ( arr [ i ] , gcd ) NEW_LINE DEDENT return gcd NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 6 , 9 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findLargest ( arr , n ) ) NEW_LINE DEDENT
from math import sqrt , pow NEW_LINE def isPerfectPower ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT for x in range ( 2 , int ( sqrt ( n ) ) + 1 ) : NEW_LINE INDENT y = 2 NEW_LINE p = pow ( x , y ) NEW_LINE while ( p <= n and p > 0 ) : NEW_LINE INDENT if ( p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT y += 1 NEW_LINE p = pow ( x , y ) NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT def isStrongNumber ( n ) : NEW_LINE INDENT count = { i : 0 for i in range ( n ) } NEW_LINE while ( n % 2 == 0 ) : NEW_LINE INDENT n = int ( n / 2 ) NEW_LINE count [ 2 ] += 1 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) + 1 , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT n = int ( n / i ) NEW_LINE count [ i ] += 1 NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT count [ n ] += 1 NEW_LINE DEDENT flag = 0 NEW_LINE for ket , value in count . items ( ) : NEW_LINE INDENT if ( value == 1 ) : NEW_LINE INDENT flag = 1 NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT else : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT def isTrojan ( n ) : NEW_LINE INDENT if ( isPerfectPower ( n ) == False and isStrongNumber ( n ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 108 NEW_LINE if ( isTrojan ( n ) ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT C = [ [ 0 for i in range ( k + 1 ) ] for j in range ( n + 1 ) ] ; NEW_LINE i , j = 0 , 0 ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( min ( i , k ) + 1 ) : NEW_LINE INDENT if ( j == 0 or j == i ) : NEW_LINE INDENT C [ i ] [ j ] = 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; NEW_LINE DEDENT DEDENT DEDENT return C [ n ] [ k ] ; NEW_LINE DEDENT def count ( n , k ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT sum = sum + binomialCoeff ( n , j ) ; NEW_LINE DEDENT return sum ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 3 ; NEW_LINE k = 2 ; NEW_LINE print ( count ( n , k ) , end = " " ) ; NEW_LINE n1 = 5 ; NEW_LINE k1 = 2 ; NEW_LINE print ( count ( n1 , k1 ) ) ; NEW_LINE DEDENT
def countPairs ( a , n ) : NEW_LINE INDENT mp = dict . fromkeys ( a , 0 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ a [ i ] ] += 1 NEW_LINE DEDENT a . sort ( reverse = True ) NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( mp [ a [ i ] ] < 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT cur = 1 NEW_LINE while ( cur <= a [ i ] ) : NEW_LINE INDENT cur = cur << 1 NEW_LINE DEDENT if ( cur - a [ i ] in mp . keys ( ) ) : NEW_LINE INDENT if ( cur - a [ i ] == a [ i ] and mp [ a [ i ] ] == 1 ) : NEW_LINE INDENT continue NEW_LINE DEDENT count += 1 NEW_LINE mp [ cur - a [ i ] ] -= 1 NEW_LINE mp [ a [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 11 , 14 , 5 , 13 ] NEW_LINE n = len ( a ) NEW_LINE print ( countPairs ( a , n ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def startingPoint ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result1 = 0 NEW_LINE result2 = 0 NEW_LINE time1 = Length // Speed1 NEW_LINE time2 = Length // Speed2 NEW_LINE result1 = gcd ( time1 , time2 ) NEW_LINE result2 = time1 * time2 // ( result1 ) NEW_LINE return result2 NEW_LINE DEDENT def firstTime ( Length , Speed1 , Speed2 ) : NEW_LINE INDENT result = 0 NEW_LINE relativeSpeed = abs ( Speed1 - Speed2 ) NEW_LINE result = Length / relativeSpeed NEW_LINE return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 30 NEW_LINE S1 = 5 NEW_LINE S2 = 2 NEW_LINE first_Time = firstTime ( L , S1 , S2 ) NEW_LINE starting_Point = startingPoint ( L , S1 , S2 ) NEW_LINE print ( " Met ▁ first ▁ time ▁ after " , first_Time , " hrs " ) NEW_LINE print ( " Met ▁ at ▁ starting ▁ point ▁ after " , starting_Point , " hrs " ) NEW_LINE DEDENT
def binomialCoeff ( n , k ) : NEW_LINE INDENT res = 1 ; NEW_LINE if ( k > n - k ) : NEW_LINE INDENT k = n - k ; NEW_LINE DEDENT for i in range ( k ) : NEW_LINE INDENT res *= ( n - i ) ; NEW_LINE res /= ( i + 1 ) ; NEW_LINE DEDENT return int ( res ) ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT c = binomialCoeff ( 2 * n , n ) ; NEW_LINE return int ( c / ( n + 1 ) ) ; NEW_LINE DEDENT def findWays ( n ) : NEW_LINE INDENT if ( n & 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT return catalan ( int ( n / 2 ) ) ; NEW_LINE DEDENT n = 6 ; NEW_LINE print ( " Total ▁ possible ▁ expressions ▁ of ▁ length " , n , " is " , findWays ( 6 ) ) ; NEW_LINE
def print_sequence ( n , k ) : NEW_LINE INDENT b = int ( n / ( k * ( k + 1 ) / 2 ) ) ; NEW_LINE if b == 0 : NEW_LINE INDENT print ( " - 1" ) NEW_LINE DEDENT else : NEW_LINE INDENT r = 1 ; NEW_LINE x = 1 NEW_LINE while x ** 2 <= n : NEW_LINE INDENT if n % x != 0 : NEW_LINE INDENT continue ; NEW_LINE DEDENT elif x <= b and x > r : NEW_LINE INDENT r = x NEW_LINE DEDENT elif n / x <= b and n / x > r : NEW_LINE INDENT r = n / x NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT i = 1 NEW_LINE while i < k : NEW_LINE INDENT print ( r * i , end = " ▁ " ) NEW_LINE i = i + 1 NEW_LINE DEDENT last_term = n - ( r * ( k * ( k - 1 ) / 2 ) ) NEW_LINE print ( last_term ) NEW_LINE DEDENT DEDENT print_sequence ( 24 , 4 ) NEW_LINE print_sequence ( 24 , 5 ) NEW_LINE print_sequence ( 6 , 4 ) NEW_LINE
maxLen = 10 NEW_LINE dp = [ 0 ] * maxLen ; NEW_LINE visit = [ 0 ] * maxLen ; NEW_LINE def maxSum ( arr , i , n , k ) : NEW_LINE INDENT if ( i >= n ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( visit [ i ] ) : NEW_LINE INDENT return dp [ i ] ; NEW_LINE DEDENT visit [ i ] = 1 ; NEW_LINE tot = 0 ; NEW_LINE dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; NEW_LINE j = i NEW_LINE while ( j < i + k and j < n ) : NEW_LINE INDENT tot += arr [ j ] ; NEW_LINE dp [ i ] = max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; NEW_LINE j += 1 NEW_LINE DEDENT return dp [ i ] ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ - 1 , 2 , - 3 , 4 , 5 ] ; NEW_LINE k = 2 ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxSum ( arr , 0 , n , k ) ) ; NEW_LINE DEDENT
def findIndices ( arr , n ) : NEW_LINE INDENT leftMin , rightMin = 0 , 0 NEW_LINE leftMax , rightMax = 0 , 0 NEW_LINE min_element = arr [ 0 ] NEW_LINE max_element = arr [ 0 ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] < min_element ) : NEW_LINE INDENT leftMin = rightMin = i NEW_LINE min_element = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] == min_element ) : NEW_LINE INDENT rightMin = i NEW_LINE DEDENT if ( arr [ i ] > max_element ) : NEW_LINE INDENT leftMax = rightMax = i NEW_LINE max_element = arr [ i ] NEW_LINE DEDENT elif ( arr [ i ] == max_element ) : NEW_LINE INDENT rightMax = i NEW_LINE DEDENT DEDENT print ( " Minimum ▁ left ▁ : ▁ " , leftMin ) NEW_LINE print ( " Minimum ▁ right ▁ : ▁ " , rightMin ) NEW_LINE print ( " Maximum ▁ left ▁ : ▁ " , leftMax ) NEW_LINE print ( " Maximum ▁ right ▁ : ▁ " , rightMax ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE findIndices ( arr , n ) NEW_LINE DEDENT
def search ( mat , m , n , x ) : NEW_LINE INDENT i , j = m - 1 , 0 NEW_LINE while ( i >= 0 and j < n ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == x ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT if ( mat [ i ] [ j ] > x ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT j += 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 10 , 20 , 30 , 40 ] , [ 15 , 25 , 35 , 45 ] , [ 27 , 29 , 37 , 48 ] , [ 32 , 33 , 39 , 50 ] , [ 50 , 60 , 70 , 80 ] ] NEW_LINE if ( search ( mat , 5 , 4 , 29 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def minOperations ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE freq = [ 0 ] * 1000001 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT freq [ arr [ i ] ] += 1 NEW_LINE DEDENT maxi = max ( arr ) NEW_LINE for i in range ( 1 , maxi + 1 ) : NEW_LINE INDENT if freq [ i ] != 0 : NEW_LINE INDENT for j in range ( i * 2 , maxi + 1 , i ) : NEW_LINE INDENT freq [ j ] = 0 NEW_LINE DEDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 4 , 2 , 4 , 4 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minOperations ( arr , n ) ) NEW_LINE DEDENT
from math import gcd NEW_LINE def FindRatio ( a , b , c ) : NEW_LINE INDENT up = abs ( b - c ) NEW_LINE down = abs ( c - a ) NEW_LINE g = gcd ( up , down ) NEW_LINE up //= g NEW_LINE down //= g NEW_LINE print ( up , " : " , down ) NEW_LINE DEDENT a = 4 NEW_LINE b = 10 NEW_LINE c = 6 NEW_LINE FindRatio ( a , b , c ) NEW_LINE
def CalculatePairs ( a , n ) : NEW_LINE INDENT cnt_zero = 0 NEW_LINE cnt_one = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( a [ i ] % 2 == 0 ) : NEW_LINE INDENT cnt_zero += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt_one += 1 NEW_LINE DEDENT DEDENT total_XOR_pairs = cnt_zero * cnt_one NEW_LINE total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 NEW_LINE print ( " cntXOR ▁ = ▁ " , int ( total_XOR_pairs ) ) NEW_LINE print ( " cntAND ▁ = ▁ " , int ( total_AND_pairs ) ) NEW_LINE print ( " cntOR ▁ = ▁ " , int ( total_OR_pairs ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 1 , 3 , 4 , 2 ] NEW_LINE n = len ( a ) NEW_LINE CalculatePairs ( a , n ) NEW_LINE DEDENT
def subset ( ar , n ) : NEW_LINE INDENT res = 0 NEW_LINE ar . sort ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT count = 1 NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT if ar [ i ] == ar [ i + 1 ] : NEW_LINE INDENT count += 1 NEW_LINE DEDENT else : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT res = max ( res , count ) NEW_LINE DEDENT return res NEW_LINE DEDENT ar = [ 5 , 6 , 9 , 3 , 4 , 3 , 4 ] NEW_LINE n = len ( ar ) NEW_LINE print ( subset ( ar , n ) ) NEW_LINE
from math import sqrt , floor NEW_LINE pref = [ 0 ] * 100010 ; NEW_LINE def isPerfectSquare ( x ) : NEW_LINE INDENT sr = sqrt ( x ) ; NEW_LINE rslt = x if ( sr - floor ( sr ) == 0 ) else 0 ; NEW_LINE return rslt ; NEW_LINE DEDENT def compute ( ) : NEW_LINE INDENT for i in range ( 1 , 100001 ) : NEW_LINE INDENT pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; NEW_LINE DEDENT DEDENT def printSum ( L , R ) : NEW_LINE INDENT sum = pref [ R ] - pref [ L - 1 ] ; NEW_LINE print ( sum , end = " ▁ " ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT compute ( ) ; NEW_LINE Q = 4 ; NEW_LINE arr = [ [ 1 , 10 ] , [ 1 , 100 ] , [ 2 , 25 ] , [ 4 , 50 ] ] ; NEW_LINE for i in range ( Q ) : NEW_LINE INDENT printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; NEW_LINE DEDENT DEDENT
def isToOneRec ( n : int , s : set ) -> bool : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return True NEW_LINE DEDENT if n in s : NEW_LINE INDENT return False NEW_LINE DEDENT if n % 2 : NEW_LINE INDENT return isToOneRec ( 3 * n + 1 , s ) NEW_LINE DEDENT else : NEW_LINE INDENT return isToOneRec ( n // 2 , s ) NEW_LINE DEDENT DEDENT def isToOne ( n : int ) -> bool : NEW_LINE INDENT s = set ( ) NEW_LINE return isToOneRec ( n , s ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE if isToOne ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def ways ( n ) : NEW_LINE INDENT first = 2 ; NEW_LINE second = 3 ; NEW_LINE res = 0 ; NEW_LINE for i in range ( 3 , n + 1 ) : NEW_LINE INDENT res = first + second ; NEW_LINE first = second ; NEW_LINE second = res ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT n = 7 ; NEW_LINE print ( " Total ▁ ways ▁ are : ▁ " , ways ( n ) ) ; NEW_LINE
N = 100 NEW_LINE def pre_process ( dp , s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT dp [ i ] [ j ] = False NEW_LINE DEDENT DEDENT for j in range ( 1 , n + 1 ) : NEW_LINE INDENT for i in range ( n - j + 1 ) : NEW_LINE INDENT if ( j <= 2 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = True NEW_LINE DEDENT DEDENT elif ( s [ i ] == s [ i + j - 1 ] ) : NEW_LINE INDENT dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] NEW_LINE DEDENT DEDENT DEDENT DEDENT def answerQuery ( l , r , dp ) : NEW_LINE INDENT if ( dp [ l ] [ r ] ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT s = " abaaab " NEW_LINE dp = [ [ 0 for i in range ( N ) ] for i in range ( N ) ] NEW_LINE pre_process ( dp , s ) NEW_LINE queries = [ [ 0 , 1 ] , [ 1 , 5 ] ] NEW_LINE q = len ( queries ) NEW_LINE for i in range ( q ) : NEW_LINE INDENT answerQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , dp ) NEW_LINE DEDENT
def distribution ( arr , n ) : NEW_LINE INDENT resources = set ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT resources . add ( arr [ i ] ) ; NEW_LINE DEDENT return min ( len ( resources ) , n // 2 ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 , 1 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( distribution ( arr , n ) , " " ) ; NEW_LINE DEDENT
def countOdd ( arr , n ) : NEW_LINE INDENT odd = 0 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 1 ) : NEW_LINE INDENT odd = odd + 1 ; NEW_LINE DEDENT DEDENT return odd ; NEW_LINE DEDENT def countValidPairs ( arr , n ) : NEW_LINE INDENT odd = countOdd ( arr , n ) ; NEW_LINE return ( odd * ( odd - 1 ) ) / 2 ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( int ( countValidPairs ( arr , n ) ) ) ; NEW_LINE
def isBinary ( n ) : NEW_LINE INDENT while n != 0 : NEW_LINE INDENT temp = n % 10 NEW_LINE if temp != 0 and temp != 1 : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 10 NEW_LINE DEDENT return True NEW_LINE DEDENT def formBinaryStr ( n , a ) : NEW_LINE INDENT flag = True NEW_LINE s = " " NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if isBinary ( a [ i ] ) == True : NEW_LINE INDENT s += str ( a [ i ] ) NEW_LINE DEDENT else : NEW_LINE INDENT flag = False NEW_LINE break NEW_LINE DEDENT DEDENT if flag == True : NEW_LINE INDENT print ( s ) NEW_LINE DEDENT else : NEW_LINE INDENT cout << " - 1 \n " NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 10 , 1 , 0 , 11 , 10 ] NEW_LINE N = len ( a ) NEW_LINE formBinaryStr ( N , a ) NEW_LINE DEDENT
def bonacciseries ( n , m ) : NEW_LINE INDENT a = [ 0 for i in range ( m ) ] NEW_LINE a [ n - 1 ] = 1 NEW_LINE a [ n ] = 1 NEW_LINE for i in range ( n + 1 , m ) : NEW_LINE INDENT a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] NEW_LINE DEDENT for i in range ( 0 , m ) : NEW_LINE INDENT print ( a [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N , M = 5 , 15 NEW_LINE bonacciseries ( N , M ) NEW_LINE DEDENT
def countPairs ( arr , n ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( arr [ i ] != arr [ j ] ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT return cnt ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( countPairs ( arr , n ) ) ; NEW_LINE DEDENT
def generate ( st , s ) : NEW_LINE INDENT if len ( s ) == 0 : NEW_LINE INDENT return NEW_LINE DEDENT if s not in st : NEW_LINE INDENT st . add ( s ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT t = list ( s ) . copy ( ) NEW_LINE t . remove ( s [ i ] ) NEW_LINE t = ' ' . join ( t ) NEW_LINE generate ( st , t ) NEW_LINE DEDENT DEDENT return NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " xyz " NEW_LINE st = set ( ) NEW_LINE generate ( st , s ) NEW_LINE for i in st : NEW_LINE INDENT print ( i ) NEW_LINE DEDENT DEDENT
def printknapSack ( W , wt , val , n ) : NEW_LINE INDENT K = [ [ 0 for w in range ( W + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for w in range ( W + 1 ) : NEW_LINE INDENT if i == 0 or w == 0 : NEW_LINE INDENT K [ i ] [ w ] = 0 NEW_LINE DEDENT elif wt [ i - 1 ] <= w : NEW_LINE INDENT K [ i ] [ w ] = max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) NEW_LINE DEDENT else : NEW_LINE INDENT K [ i ] [ w ] = K [ i - 1 ] [ w ] NEW_LINE DEDENT DEDENT DEDENT res = K [ n ] [ W ] NEW_LINE print ( res ) NEW_LINE w = W NEW_LINE for i in range ( n , 0 , - 1 ) : NEW_LINE INDENT if res <= 0 : NEW_LINE INDENT break NEW_LINE DEDENT if res == K [ i - 1 ] [ w ] : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT print ( wt [ i - 1 ] ) NEW_LINE res = res - val [ i - 1 ] NEW_LINE w = w - wt [ i - 1 ] NEW_LINE DEDENT DEDENT DEDENT val = [ 60 , 100 , 120 ] NEW_LINE wt = [ 10 , 20 , 30 ] NEW_LINE W = 50 NEW_LINE n = len ( val ) NEW_LINE printknapSack ( W , wt , val , n ) NEW_LINE
def findSum ( arr , n ) : NEW_LINE INDENT s = set ( ) NEW_LINE sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] not in s : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT DEDENT for i in s : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT return sum NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findSum ( arr , n ) ) NEW_LINE
def sumOfDigit ( n , b ) : NEW_LINE INDENT unitDigit = 0 NEW_LINE sum = 0 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT unitDigit = n % b NEW_LINE sum += unitDigit NEW_LINE n = n // b NEW_LINE DEDENT return sum NEW_LINE DEDENT n = 50 NEW_LINE b = 2 NEW_LINE print ( sumOfDigit ( n , b ) ) NEW_LINE
def minflip ( arr1 , arr2 , arr3 , p , q , n ) : NEW_LINE INDENT flip = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr1 [ i ] ^ arr2 [ i ] != arr3 [ i ] ) : NEW_LINE INDENT flip += 1 NEW_LINE DEDENT DEDENT return flip if ( flip <= p + q ) else - 1 NEW_LINE DEDENT arr1 = [ 1 , 0 , 1 , 1 , 1 , 1 , 1 ] NEW_LINE arr2 = [ 0 , 1 , 1 , 1 , 1 , 0 , 0 ] NEW_LINE arr3 = [ 1 , 1 , 1 , 1 , 0 , 0 , 1 ] NEW_LINE n = len ( arr1 ) NEW_LINE p = 2 NEW_LINE q = 4 NEW_LINE print ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) NEW_LINE
def checkArray ( arr , n ) : NEW_LINE INDENT return ( ( arr [ 0 ] % 2 ) and ( arr [ n - 1 ] % 2 ) and ( n % 2 ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE n = len ( arr ) ; NEW_LINE if checkArray ( arr , n ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def pattern ( N ) : NEW_LINE INDENT k , space , rows = 0 , 1 , N NEW_LINE for i in range ( rows , 0 , - 1 ) : NEW_LINE INDENT for j in range ( 1 , i + 1 ) : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT if i != rows : NEW_LINE INDENT for k in range ( 1 , space + 1 ) : NEW_LINE INDENT print ( ' ▁ ' , end = ' ' ) NEW_LINE DEDENT space += 2 NEW_LINE DEDENT for j in range ( i , 0 , - 1 ) : NEW_LINE INDENT if j != rows : NEW_LINE INDENT print ( ' * ' , end = ' ' ) NEW_LINE DEDENT DEDENT print ( ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT N = 6 NEW_LINE pattern ( N ) NEW_LINE
import math ; NEW_LINE def discreteLogarithm ( a , b , m ) : NEW_LINE INDENT n = int ( math . sqrt ( m ) + 1 ) ; NEW_LINE an = 1 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT an = ( an * a ) % m ; NEW_LINE DEDENT value = [ 0 ] * m ; NEW_LINE cur = an ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( value [ cur ] == 0 ) : NEW_LINE INDENT value [ cur ] = i ; NEW_LINE DEDENT cur = ( cur * an ) % m ; NEW_LINE DEDENT cur = b ; NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT if ( value [ cur ] > 0 ) : NEW_LINE INDENT ans = value [ cur ] * n - i ; NEW_LINE if ( ans < m ) : NEW_LINE INDENT return ans ; NEW_LINE DEDENT DEDENT cur = ( cur * a ) % m ; NEW_LINE DEDENT return - 1 ; NEW_LINE DEDENT a = 2 ; NEW_LINE b = 3 ; NEW_LINE m = 5 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE a = 3 ; NEW_LINE b = 7 ; NEW_LINE m = 11 ; NEW_LINE print ( discreteLogarithm ( a , b , m ) ) ; NEW_LINE
def calculateDiff ( i , j , arr ) : NEW_LINE INDENT return abs ( arr [ i ] - arr [ j ] ) + abs ( i - j ) NEW_LINE DEDENT def maxDistance ( arr , n ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( calculateDiff ( i , j , arr ) > result ) : NEW_LINE INDENT result = calculateDiff ( i , j , arr ) NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT arr = [ - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 ] NEW_LINE n = len ( arr ) NEW_LINE print ( maxDistance ( arr , n ) ) NEW_LINE
def zeroUpto ( digits ) : NEW_LINE INDENT first = int ( ( pow ( 10 , digits ) - 1 ) / 9 ) ; NEW_LINE second = int ( ( pow ( 9 , digits ) - 1 ) / 8 ) ; NEW_LINE return 9 * ( first - second ) ; NEW_LINE DEDENT def countZero ( num ) : NEW_LINE INDENT k = len ( num ) ; NEW_LINE total = zeroUpto ( k - 1 ) ; NEW_LINE non_zero = 0 ; NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT if ( num [ i ] == '0' ) : NEW_LINE INDENT non_zero -= 1 ; NEW_LINE break ; NEW_LINE DEDENT non_zero += ( ( ( ord ( num [ i ] ) - ord ( '0' ) ) - 1 ) * ( pow ( 9 , k - 1 - i ) ) ) ; NEW_LINE DEDENT no = 0 ; NEW_LINE remaining = 0 ; NEW_LINE calculatedUpto = 0 ; NEW_LINE for i in range ( len ( num ) ) : NEW_LINE INDENT no = no * 10 + ( ord ( num [ i ] ) - ord ( '0' ) ) ; NEW_LINE if ( i != 0 ) : NEW_LINE INDENT calculatedUpto = calculatedUpto * 10 + 9 ; NEW_LINE DEDENT DEDENT remaining = no - calculatedUpto ; NEW_LINE ans = zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) ; NEW_LINE return ans ; NEW_LINE DEDENT num = "107" ; NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to " , num , " is " , countZero ( num ) ) ; NEW_LINE num = "1264" ; NEW_LINE print ( " Count ▁ of ▁ numbers ▁ from ▁ 1 ▁ to " , num , " is " , countZero ( num ) ) ; NEW_LINE
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def prList ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE print ( temp . data , end = " - > " ) NEW_LINE temp = temp . next NEW_LINE while ( temp != head ) : NEW_LINE INDENT print ( temp . data , end = " - > " ) NEW_LINE temp = temp . next NEW_LINE DEDENT print ( head . data ) NEW_LINE DEDENT def deleteK ( head_ref , k ) : NEW_LINE INDENT head = head_ref NEW_LINE if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT curr = head NEW_LINE prev = None NEW_LINE while True : NEW_LINE INDENT if ( curr . next == head and curr == head ) : NEW_LINE INDENT break NEW_LINE DEDENT prList ( head ) NEW_LINE for i in range ( k ) : NEW_LINE INDENT prev = curr NEW_LINE curr = curr . next NEW_LINE DEDENT if ( curr == head ) : NEW_LINE INDENT prev = head NEW_LINE while ( prev . next != head ) : NEW_LINE INDENT prev = prev . next NEW_LINE DEDENT head = curr . next NEW_LINE prev . next = head NEW_LINE head_ref = head NEW_LINE DEDENT elif ( curr . next == head ) : NEW_LINE INDENT prev . next = head NEW_LINE DEDENT else : NEW_LINE INDENT prev . next = curr . next NEW_LINE DEDENT DEDENT DEDENT def insertNode ( head_ref , x ) : NEW_LINE INDENT head = head_ref NEW_LINE temp = Node ( x ) NEW_LINE if ( head == None ) : NEW_LINE INDENT temp . next = temp NEW_LINE head_ref = temp NEW_LINE return head_ref NEW_LINE DEDENT else : NEW_LINE INDENT temp1 = head NEW_LINE while ( temp1 . next != head ) : NEW_LINE INDENT temp1 = temp1 . next NEW_LINE DEDENT temp1 . next = temp NEW_LINE temp . next = head NEW_LINE DEDENT return head NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = insertNode ( head , 1 ) NEW_LINE head = insertNode ( head , 2 ) NEW_LINE head = insertNode ( head , 3 ) NEW_LINE head = insertNode ( head , 4 ) NEW_LINE head = insertNode ( head , 5 ) NEW_LINE head = insertNode ( head , 6 ) NEW_LINE head = insertNode ( head , 7 ) NEW_LINE head = insertNode ( head , 8 ) NEW_LINE head = insertNode ( head , 9 ) NEW_LINE k = 4 NEW_LINE deleteK ( head , k ) NEW_LINE DEDENT
def possibleways ( n ) : NEW_LINE INDENT if ( n % 2 == 1 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT elif ( n % 4 == 0 ) : NEW_LINE INDENT return n // 4 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return n // 4 ; NEW_LINE DEDENT DEDENT n = 20 ; NEW_LINE print ( possibleways ( n ) ) ; NEW_LINE
def numberOfWays ( x ) : NEW_LINE INDENT if x == 0 or x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return ( numberOfWays ( x - 1 ) + ( x - 1 ) * numberOfWays ( x - 2 ) ) NEW_LINE DEDENT DEDENT x = 3 NEW_LINE print ( numberOfWays ( x ) ) NEW_LINE
def properDivisorSum ( n ) : NEW_LINE INDENT sum = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum += ( n // i ) * i NEW_LINE DEDENT return sum - n * ( n + 1 ) // 2 NEW_LINE DEDENT n = 4 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE n = 5 NEW_LINE print ( properDivisorSum ( n ) ) NEW_LINE
def diff ( n , mid ) : NEW_LINE INDENT if ( n > ( mid * mid * mid ) ) : NEW_LINE INDENT return ( n - ( mid * mid * mid ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( ( mid * mid * mid ) - n ) NEW_LINE DEDENT DEDENT def cubicRoot ( n ) : NEW_LINE INDENT start = 0 NEW_LINE end = n NEW_LINE e = 0.0000001 NEW_LINE while ( True ) : NEW_LINE INDENT mid = ( start + end ) / 2 NEW_LINE error = diff ( n , mid ) NEW_LINE if ( error <= e ) : NEW_LINE INDENT return mid NEW_LINE DEDENT if ( ( mid * mid * mid ) > n ) : NEW_LINE INDENT end = mid NEW_LINE DEDENT else : NEW_LINE INDENT start = mid NEW_LINE DEDENT DEDENT DEDENT n = 3 NEW_LINE print ( " Cubic ▁ root ▁ of " , n , " is " , round ( cubicRoot ( n ) , 6 ) ) NEW_LINE
def getMin ( arr , n ) : NEW_LINE INDENT return min ( arr ) ; NEW_LINE DEDENT def getMax ( arr , n ) : NEW_LINE INDENT return max ( arr ) ; NEW_LINE DEDENT arr = [ 12 , 1234 , 45 , 67 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( " Minimum ▁ element ▁ of ▁ array : ▁ " , getMin ( arr , n ) ) ; NEW_LINE print ( " Maximum ▁ element ▁ of ▁ array : ▁ " , getMax ( arr , n ) ) ; NEW_LINE
def printPascal ( n ) : NEW_LINE INDENT for line in range ( 1 , n + 1 ) : NEW_LINE INDENT C = 1 ; NEW_LINE for i in range ( 1 , line + 1 ) : NEW_LINE INDENT print ( C , end = " ▁ " ) ; NEW_LINE C = int ( C * ( line - i ) / i ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT DEDENT n = 5 ; NEW_LINE printPascal ( n ) ; NEW_LINE
def fillWithFreq ( arr , n ) : NEW_LINE INDENT temp = [ 0 for i in range ( n ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT temp [ arr [ i ] ] += 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT arr [ i ] = temp [ i ] NEW_LINE DEDENT DEDENT arr = [ 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 ] NEW_LINE n = len ( arr ) NEW_LINE fillWithFreq ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
s = " Mr ▁ John ▁ Smith ▁ " NEW_LINE s = s . strip ( ) NEW_LINE s = s . replace ( ' ▁ ' , " % 20" ) NEW_LINE print ( s ) NEW_LINE
def cntgloves ( arr , n ) : NEW_LINE INDENT count = 0 ; NEW_LINE arr . sort ( ) ; NEW_LINE i = 0 ; NEW_LINE while i < ( n - 1 ) : NEW_LINE INDENT if ( arr [ i ] == arr [ i + 1 ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE i = i + 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT i += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 6 , 5 , 2 , 3 , 5 , 2 , 2 , 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( cntgloves ( arr , n ) ) ; NEW_LINE DEDENT
def inversegrayCode ( n ) : NEW_LINE INDENT inv = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT inv = inv ^ n ; NEW_LINE n = n >> 1 ; NEW_LINE DEDENT return inv ; NEW_LINE DEDENT n = 15 ; NEW_LINE print ( inversegrayCode ( n ) ) ; NEW_LINE
def isPerfectSquare ( arr , n ) : NEW_LINE INDENT umap = dict . fromkeys ( arr , n ) ; NEW_LINE for key in arr : NEW_LINE INDENT umap [ key ] += 1 ; NEW_LINE DEDENT for key in arr : NEW_LINE INDENT if ( umap [ key ] % 2 == 1 ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT return True ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 2 , 2 , 7 , 7 ] ; NEW_LINE n = len ( arr ) NEW_LINE if ( isPerfectSquare ( arr , n ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def findPairs ( arr , n ) : NEW_LINE INDENT cntEven = 0 ; cntOdd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( arr [ i ] % 2 == 0 ) : NEW_LINE INDENT cntEven += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT cntOdd += 1 ; NEW_LINE DEDENT DEDENT evenPairs = 0 ; NEW_LINE evenPairs += ( ( cntEven * ( cntEven - 1 ) ) // 2 ) ; NEW_LINE evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) // 2 ) ; NEW_LINE oddPairs = 0 ; NEW_LINE oddPairs += ( cntEven * cntOdd ) ; NEW_LINE print ( " Odd ▁ pairs ▁ = ▁ " , oddPairs ) ; NEW_LINE print ( " Even ▁ pairs ▁ = ▁ " , evenPairs ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 , 5 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE findPairs ( arr , n ) ; NEW_LINE DEDENT
def shuffle ( N , key ) : NEW_LINE INDENT NO_OF_BITS = N NEW_LINE reverse_num = 0 NEW_LINE for i in range ( NO_OF_BITS ) : NEW_LINE INDENT temp = ( key & ( 1 << i ) ) NEW_LINE if ( temp ) : NEW_LINE INDENT reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) NEW_LINE DEDENT DEDENT print ( reverse_num ) NEW_LINE DEDENT N = 3 NEW_LINE key = 3 NEW_LINE shuffle ( N , key ) NEW_LINE
def bubble_count ( arr , start , end ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT for j in range ( i + 1 , end ) : NEW_LINE INDENT if ( arr [ i ] > arr [ j ] ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT def inversion_count ( n , k , a ) : NEW_LINE INDENT count = 0 ; NEW_LINE for start in range ( 0 , n - k + 1 ) : NEW_LINE INDENT end = start + k ; NEW_LINE count += bubble_count ( a , start , end ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 ; NEW_LINE arr = [ 15 , 51 , 44 , 44 , 76 , 50 , 29 , 88 , 48 , 50 ] ; NEW_LINE k = 5 ; NEW_LINE result = inversion_count ( n , k , arr ) ; NEW_LINE print ( result ) ; NEW_LINE DEDENT
def printParenthesis ( str , n ) : NEW_LINE INDENT if ( n > 0 ) : NEW_LINE INDENT _printParenthesis ( str , 0 , n , 0 , 0 ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT def _printParenthesis ( str , pos , n , open , close ) : NEW_LINE INDENT if ( close == n ) : NEW_LINE INDENT for i in str : NEW_LINE INDENT print ( i , end = " " ) ; NEW_LINE DEDENT print ( ) ; NEW_LINE return ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( open > close ) : NEW_LINE INDENT str [ pos ] = ' } ' ; NEW_LINE _printParenthesis ( str , pos + 1 , n , open , close + 1 ) ; NEW_LINE DEDENT if ( open < n ) : NEW_LINE INDENT str [ pos ] = ' { ' ; NEW_LINE _printParenthesis ( str , pos + 1 , n , open + 1 , close ) ; NEW_LINE DEDENT DEDENT DEDENT n = 3 ; NEW_LINE str = [ " " ] * 2 * n ; NEW_LINE printParenthesis ( str , n ) ; NEW_LINE
def fun ( x ) : NEW_LINE INDENT y = ( x // 4 ) * 4 NEW_LINE ans = 0 NEW_LINE for i in range ( y , x + 1 ) : NEW_LINE INDENT ans ^= i NEW_LINE DEDENT return ans NEW_LINE DEDENT def query ( x ) : NEW_LINE INDENT if ( x == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT k = ( x + 1 ) // 2 NEW_LINE if x % 2 == 0 : NEW_LINE INDENT return ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) NEW_LINE DEDENT else : NEW_LINE INDENT return ( 2 * fun ( k ) ) NEW_LINE DEDENT DEDENT def allQueries ( q , l , r ) : NEW_LINE INDENT for i in range ( q ) : NEW_LINE INDENT print ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) NEW_LINE DEDENT DEDENT q = 3 NEW_LINE l = [ 2 , 2 , 5 ] NEW_LINE r = [ 4 , 8 , 9 ] NEW_LINE allQueries ( q , l , r ) NEW_LINE
def isDivisible ( n ) : NEW_LINE INDENT temp = n NEW_LINE sum = 0 ; NEW_LINE while ( n ) : NEW_LINE INDENT k = n % 10 ; NEW_LINE sum += k ; NEW_LINE n /= 10 ; NEW_LINE DEDENT if ( temp % sum == 0 ) : NEW_LINE INDENT return " YES " ; NEW_LINE DEDENT return " NO " ; NEW_LINE DEDENT n = 123 ; NEW_LINE print ( isDivisible ( n ) ) ; NEW_LINE
def find ( n , m ) : NEW_LINE INDENT if ( n <= 2 * m ) : NEW_LINE INDENT print ( " Minimum ▁ " , 0 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Minimum ▁ " , n - 2 * m ) NEW_LINE DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i * ( i - 1 ) // 2 >= m ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( " Maximum ▁ " , n - i ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 2 NEW_LINE find ( n , m ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT if ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def checkPossibility ( s1 , s2 ) : NEW_LINE INDENT l1 = len ( s1 ) NEW_LINE l2 = len ( s2 ) NEW_LINE if ( l1 != l2 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( l1 ) : NEW_LINE INDENT if ( isVowel ( s1 [ i ] ) and isVowel ( s2 [ i ] ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT elif ( ( isVowel ( s1 [ i ] ) ) == False and ( isVowel ( s2 [ i ] ) == False ) ) : NEW_LINE INDENT continue NEW_LINE DEDENT else : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT S1 , S2 = " abcgle " , " ezggli " NEW_LINE if ( checkPossibility ( S1 , S2 ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def findNthTerm ( N ) : NEW_LINE INDENT ans = 0 ; NEW_LINE if ( N % 2 == 0 ) : NEW_LINE INDENT ans = ( N // 2 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT ans = ( N // 2 + 1 ) * 6 + ( N // 2 ) * 2 ; NEW_LINE DEDENT print ( ans ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 3 ; NEW_LINE findNthTerm ( N ) ; NEW_LINE DEDENT
def matrix_multiplication ( M , N ) : NEW_LINE INDENT R = [ [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] , [ 0 , 0 , 0 , 0 ] ] NEW_LINE for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT for k in range ( 0 , 4 ) : NEW_LINE INDENT R [ i ] [ j ] += M [ i ] [ k ] * N [ k ] [ j ] NEW_LINE DEDENT DEDENT DEDENT for i in range ( 0 , 4 ) : NEW_LINE INDENT for j in range ( 0 , 4 ) : NEW_LINE INDENT print ( R [ i ] [ j ] , end = " ▁ " ) NEW_LINE DEDENT print ( " \n " , end = " " ) NEW_LINE DEDENT DEDENT M = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE N = [ [ 1 , 1 , 1 , 1 ] , [ 2 , 2 , 2 , 2 ] , [ 3 , 3 , 3 , 3 ] , [ 4 , 4 , 4 , 4 ] ] NEW_LINE matrix_multiplication ( M , N ) NEW_LINE
dp = [ 0 ] * 1024 ; NEW_LINE def get_binary ( u ) : NEW_LINE INDENT ans = 0 ; NEW_LINE while ( u ) : NEW_LINE INDENT rem = u % 10 ; NEW_LINE ans |= ( 1 << rem ) ; NEW_LINE u //= 10 ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT def recur ( u , array , n ) : NEW_LINE INDENT if ( u == 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( dp [ u ] != - 1 ) : NEW_LINE INDENT return dp [ u ] ; NEW_LINE DEDENT temp = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mask = get_binary ( array [ i ] ) ; NEW_LINE if ( ( mask | u ) == u ) : NEW_LINE INDENT dp [ u ] = max ( max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; NEW_LINE DEDENT DEDENT return dp [ u ] ; NEW_LINE DEDENT def solve ( array , n ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT dp [ i ] = - 1 ; NEW_LINE i += 1 NEW_LINE DEDENT ans = 0 ; NEW_LINE i = 0 NEW_LINE while ( i < ( 1 << 10 ) ) : NEW_LINE INDENT ans = max ( ans , recur ( i , array , n ) ) ; NEW_LINE i += 1 NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT array = [ 22 , 132 , 4 , 45 , 12 , 223 ] ; NEW_LINE n = len ( array ) ; NEW_LINE print ( solve ( array , n ) ) ; NEW_LINE DEDENT
def findSum ( N , K ) : NEW_LINE INDENT ans = 0 ; NEW_LINE y = N / K ; NEW_LINE x = N % K ; NEW_LINE ans = ( ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ) ; NEW_LINE return int ( ans ) ; NEW_LINE DEDENT N = 10 ; NEW_LINE K = 2 ; NEW_LINE print ( findSum ( N , K ) ) ; NEW_LINE
def decimalToBinary ( N ) : NEW_LINE INDENT B_Number = 0 NEW_LINE cnt = 0 NEW_LINE while ( N != 0 ) : NEW_LINE INDENT rem = N % 2 NEW_LINE c = pow ( 10 , cnt ) NEW_LINE B_Number += rem * c NEW_LINE N //= 2 NEW_LINE cnt += 1 NEW_LINE DEDENT return B_Number NEW_LINE DEDENT N = 17 NEW_LINE print ( decimalToBinary ( N ) ) NEW_LINE
def isTriPerfect ( n ) : NEW_LINE INDENT sum = 1 + n NEW_LINE i = 2 NEW_LINE while i * i <= n : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT if n / i == i : NEW_LINE INDENT sum = sum + i NEW_LINE DEDENT else : NEW_LINE INDENT sum = sum + i + n / i NEW_LINE DEDENT DEDENT i += 1 NEW_LINE DEDENT return ( True if sum == 3 * n and n != 1 else False ) NEW_LINE DEDENT n = 120 NEW_LINE if isTriPerfect ( n ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ Triperfect ▁ number " ) NEW_LINE DEDENT
def xorEqualsOrCount ( N ) : NEW_LINE INDENT count = 0 NEW_LINE while ( N > 0 ) : NEW_LINE INDENT bit = N % 2 NEW_LINE if bit == 0 : NEW_LINE INDENT count += 1 NEW_LINE DEDENT N //= 2 NEW_LINE DEDENT return int ( pow ( 2 , count ) ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 7 NEW_LINE print ( xorEqualsOrCount ( N ) ) NEW_LINE DEDENT
def judgeSquareSum ( c ) : NEW_LINE INDENT a = 0 ; NEW_LINE while ( a * a <= c ) : NEW_LINE INDENT b = c - int ( a * a ) ; NEW_LINE if ( binary_search ( 0 , b , b ) ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT a += 1 ; NEW_LINE DEDENT return 0 ; NEW_LINE DEDENT def binary_search ( s , e , n ) : NEW_LINE INDENT if ( s > e ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT mid = s + int ( ( e - s ) / 2 ) ; NEW_LINE if ( int ( mid * mid ) == n ) : NEW_LINE INDENT return 1 ; NEW_LINE DEDENT if ( int ( mid * mid ) > n ) : NEW_LINE INDENT return binary_search ( s , mid - 1 , n ) ; NEW_LINE DEDENT return binary_search ( mid + 1 , e , n ) ; NEW_LINE DEDENT c = 17 ; NEW_LINE if ( judgeSquareSum ( c ) ) : NEW_LINE INDENT print ( " true " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " false " ) ; NEW_LINE DEDENT
def isOdd ( arr , n ) : NEW_LINE INDENT flag = 0 ; flag1 = 0 ; sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT sum += arr [ i ] ; NEW_LINE if ( arr [ i ] % 2 == 0 and flag == 0 ) : NEW_LINE INDENT flag = 1 ; NEW_LINE l = arr [ i ] ; NEW_LINE DEDENT if ( arr [ i ] % 2 != 0 and flag1 == 0 ) : NEW_LINE INDENT r = arr [ i ] ; NEW_LINE flag1 = 1 ; NEW_LINE DEDENT DEDENT if ( sum % 2 != 0 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag1 == 1 and flag == 1 ) : NEW_LINE INDENT return True ; NEW_LINE DEDENT else : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 4 , 4 , 5 , 1 , 3 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE res = isOdd ( arr , n ) ; NEW_LINE if ( res ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT DEDENT
def nthTerm ( n ) : NEW_LINE INDENT return 3 * pow ( n , 2 ) + 2 * n - 5 NEW_LINE DEDENT N = 4 NEW_LINE print ( nthTerm ( N ) ) NEW_LINE
MAX = 256 NEW_LINE def smallestStr ( str , n ) : NEW_LINE INDENT i , j = 0 , 0 NEW_LINE chk = [ 0 for i in range ( MAX ) ] NEW_LINE for i in range ( MAX ) : NEW_LINE INDENT chk [ i ] = - 1 NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT if ( chk [ ord ( str [ i ] ) ] == - 1 ) : NEW_LINE INDENT chk [ ord ( str [ i ] ) ] = i NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT flag = False NEW_LINE for j in range ( ord ( str [ i ] ) ) : NEW_LINE INDENT if ( chk [ j ] > chk [ ord ( str [ i ] ) ] ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT if ( i < n ) : NEW_LINE INDENT ch1 = ( str [ i ] ) NEW_LINE ch2 = chr ( j ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( str [ i ] == ch1 ) : NEW_LINE INDENT str [ i ] = ch2 NEW_LINE DEDENT elif ( str [ i ] == ch2 ) : NEW_LINE INDENT str [ i ] = ch1 NEW_LINE DEDENT DEDENT DEDENT return " " . join ( str ) NEW_LINE DEDENT st = " ccad " NEW_LINE str = [ i for i in st ] NEW_LINE n = len ( str ) NEW_LINE print ( smallestStr ( str , n ) ) NEW_LINE
N = 3 NEW_LINE def numberOfCells ( mat ) : NEW_LINE INDENT row = [ [ False for i in range ( N ) ] for i in range ( N ) ] NEW_LINE col = [ [ False for i in range ( N ) ] for i in range ( N ) ] NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT if j + 1 < N : NEW_LINE INDENT row [ i ] [ j ] = row [ i ] [ j + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT row [ i ] [ j ] = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT row [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT for j in range ( N ) : NEW_LINE INDENT for i in range ( N - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mat [ i ] [ j ] == 1 ) : NEW_LINE INDENT if i + 1 < N : NEW_LINE INDENT col [ i ] [ j ] = col [ i + 1 ] [ j ] NEW_LINE DEDENT else : NEW_LINE INDENT col [ i ] [ j ] = True NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT col [ i ] [ j ] = False NEW_LINE DEDENT DEDENT DEDENT cnt = 0 NEW_LINE for i in range ( N - 1 ) : NEW_LINE INDENT for j in range ( N - 1 ) : NEW_LINE INDENT if ( row [ i ] [ j ] and col [ i ] [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT DEDENT for i in range ( N ) : NEW_LINE INDENT if ( col [ i ] [ N - 1 ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT for j in range ( N - 1 ) : NEW_LINE INDENT if ( row [ N - 1 ] [ j ] ) : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT mat = [ [ 0 , 1 , 1 ] , [ 0 , 1 , 1 ] , [ 0 , 1 , 1 ] ] NEW_LINE print ( numberOfCells ( mat ) ) NEW_LINE
def printRLE ( s ) : NEW_LINE INDENT i = 0 NEW_LINE while ( i < len ( s ) - 1 ) : NEW_LINE INDENT count = 1 NEW_LINE while s [ i ] == s [ i + 1 ] : NEW_LINE INDENT i += 1 NEW_LINE count += 1 NEW_LINE if i + 1 == len ( s ) : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT print ( str ( s [ i ] ) + str ( count ) , end = " ▁ " ) NEW_LINE i += 1 NEW_LINE DEDENT print ( ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT printRLE ( " GeeeEEKKKss " ) NEW_LINE printRLE ( " cccc0ddEEE " ) NEW_LINE DEDENT
import sys NEW_LINE def getPairsCount ( arr , n , sum ) : NEW_LINE INDENT m = [ 0 ] * 1000 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT m [ arr [ i ] ] NEW_LINE m [ arr [ i ] ] += 1 NEW_LINE DEDENT twice_count = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT twice_count += m [ sum - arr [ i ] ] NEW_LINE if ( sum - arr [ i ] == arr [ i ] ) : NEW_LINE INDENT twice_count -= 1 NEW_LINE DEDENT DEDENT return int ( twice_count / 2 ) NEW_LINE DEDENT arr = [ 1 , 5 , 7 , - 1 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE sum = 6 NEW_LINE print ( " Count ▁ of ▁ pairs ▁ is " , getPairsCount ( arr , n , sum ) ) NEW_LINE
if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT matrix = [ [ 0 for i in range ( 5 ) ] for j in range ( 5 ) ] NEW_LINE row_index , column_index , x , size = 0 , 0 , 0 , 5 ; NEW_LINE for row_index in range ( size ) : NEW_LINE INDENT for column_index in range ( size ) : NEW_LINE INDENT x += 1 ; NEW_LINE matrix [ row_index ] [ column_index ] = x ; NEW_LINE DEDENT DEDENT print ( " The ▁ matrix ▁ is " ) ; NEW_LINE for row_index in range ( size ) : NEW_LINE INDENT for column_index in range ( size ) : NEW_LINE INDENT print ( matrix [ row_index ] [ column_index ] , end = " \t " ) ; NEW_LINE DEDENT print ( " " ) ; NEW_LINE DEDENT print ( " \n Boundary ▁ Elements ▁ are : " ) ; NEW_LINE for row_index in range ( size ) : NEW_LINE INDENT for column_index in range ( size ) : NEW_LINE INDENT if ( ( row_index == 0 or row_index == size - 1   \ or column_index == 0 or column_index == size - 1 ) ) : NEW_LINE INDENT print ( matrix [ row_index ] [ column_index ] , end = " , ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT DEDENT
def isPrime ( c ) : NEW_LINE INDENT return ( c == '2' or c == '3' or c == '5' or c == '7' ) NEW_LINE DEDENT def decrease ( s , i ) : NEW_LINE INDENT if ( s [ i ] <= '2' ) : NEW_LINE INDENT s [ i ] = '7' NEW_LINE DEDENT elif ( s [ i ] == '3' ) : NEW_LINE INDENT s [ i ] = '2' NEW_LINE DEDENT elif ( s [ i ] <= '5' ) : NEW_LINE INDENT s [ i ] = '3' NEW_LINE DEDENT elif ( s [ i ] <= '7' ) : NEW_LINE INDENT s [ i ] = '5' NEW_LINE DEDENT else : NEW_LINE INDENT s [ i ] = '7' NEW_LINE DEDENT DEDENT def primeDigits ( s ) : NEW_LINE INDENT s = [ i for i in s ] NEW_LINE i = 0 NEW_LINE while i < len ( s ) : NEW_LINE INDENT if ( isPrime ( s [ i ] ) == False ) : NEW_LINE INDENT while ( s [ i ] <= '2' and i >= 0 ) : NEW_LINE INDENT i -= 1 NEW_LINE DEDENT if ( i < 0 ) : NEW_LINE INDENT i = 0 NEW_LINE decrease ( s , i ) NEW_LINE DEDENT else : NEW_LINE INDENT decrease ( s , i ) NEW_LINE DEDENT for j in range ( i + 1 , len ( s ) ) : NEW_LINE INDENT s [ j ] = '7' NEW_LINE DEDENT break NEW_LINE DEDENT i += 1 NEW_LINE DEDENT return " " . join ( s ) NEW_LINE DEDENT s = "45" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "1000" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "7721" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "7221" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE s = "74545678912345689748593275897894708927680" NEW_LINE print ( primeDigits ( s ) ) NEW_LINE
N = 1000005 NEW_LINE primeFactors = [ 0 ] * N ; NEW_LINE def findPrimeFactors ( ) : NEW_LINE INDENT for i in range ( 2 , N ) : NEW_LINE INDENT if ( primeFactors [ i ] == 0 ) : NEW_LINE INDENT for j in range ( i , N , i ) : NEW_LINE INDENT primeFactors [ j ] = primeFactors [ j // i ] + 1 ; NEW_LINE DEDENT DEDENT DEDENT for i in range ( 1 , N ) : NEW_LINE INDENT primeFactors [ i ] += primeFactors [ i - 1 ] ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT findPrimeFactors ( ) ; NEW_LINE a = 6 ; b = 3 ; NEW_LINE print ( primeFactors [ a ] - primeFactors [ b ] ) ; NEW_LINE DEDENT
def findNDigitNumsUtil ( n , out , index , evenSum , oddSum ) : NEW_LINE INDENT if ( index > n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( index == n ) : NEW_LINE INDENT if ( abs ( evenSum - oddSum ) == 1 ) : NEW_LINE INDENT out [ index ] = ' ' NEW_LINE out = ' ' . join ( out ) NEW_LINE print ( out , end = " ▁ " ) NEW_LINE DEDENT return NEW_LINE DEDENT if ( index & 1 ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) NEW_LINE DEDENT DEDENT DEDENT def findNDigitNums ( n ) : NEW_LINE INDENT out = [ 0 ] * ( n + 1 ) NEW_LINE index = 0 NEW_LINE evenSum = 0 NEW_LINE oddSum = 0 NEW_LINE for i in range ( 1 , 10 ) : NEW_LINE INDENT out [ index ] = chr ( i + ord ( '0' ) ) NEW_LINE findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 NEW_LINE findNDigitNums ( n ) NEW_LINE DEDENT
def ksmallest ( arr , n , k ) : NEW_LINE INDENT arr . sort ( ) ; NEW_LINE if ( k < arr [ 0 ] ) : NEW_LINE INDENT return k ; NEW_LINE DEDENT if ( k == arr [ 0 ] ) : NEW_LINE INDENT return arr [ 0 ] + 1 ; NEW_LINE DEDENT if ( k > arr [ n - 1 ] ) : NEW_LINE INDENT return k + n ; NEW_LINE DEDENT if ( arr [ 0 ] == 1 ) : NEW_LINE INDENT k -= 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= ( arr [ 0 ] - 1 ) ; NEW_LINE DEDENT for i in range ( 1 , n ) : NEW_LINE INDENT c = arr [ i ] - arr [ i - 1 ] - 1 ; NEW_LINE if ( k <= c ) : NEW_LINE INDENT return arr [ i - 1 ] + k ; NEW_LINE DEDENT else : NEW_LINE INDENT k -= c ; NEW_LINE DEDENT DEDENT return arr [ n - 1 ] + k ; NEW_LINE DEDENT k = 1 ; NEW_LINE arr = [ 1 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( ksmallest ( arr , n , k ) ) ; NEW_LINE
INT_MIN , INT_MAX = float ( ' - inf ' ) , float ( ' inf ' ) NEW_LINE class NodeDetails : NEW_LINE INDENT def __init__ ( self , data , min , max ) : NEW_LINE INDENT self . data = data NEW_LINE self . min = min NEW_LINE self . max = max NEW_LINE DEDENT DEDENT def levelOrderIsOfBST ( arr , n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return True NEW_LINE DEDENT q = [ ] NEW_LINE i = 0 NEW_LINE newNode = NodeDetails ( arr [ i ] , INT_MIN , INT_MAX ) NEW_LINE i += 1 NEW_LINE q . append ( newNode ) NEW_LINE while i != n and len ( q ) != 0 : NEW_LINE INDENT temp = q . pop ( 0 ) NEW_LINE if i < n and ( arr [ i ] < temp . data and arr [ i ] > temp . min ) : NEW_LINE INDENT newNode = NodeDetails ( arr [ i ] , temp . min , temp . data ) NEW_LINE i += 1 NEW_LINE q . append ( newNode ) NEW_LINE DEDENT if i < n and ( arr [ i ] > temp . data and arr [ i ] < temp . max ) : NEW_LINE INDENT newNode = NodeDetails ( arr [ i ] , temp . data , temp . max ) NEW_LINE i += 1 NEW_LINE q . append ( newNode ) NEW_LINE DEDENT DEDENT if i == n : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 7 , 4 , 12 , 3 , 6 , 8 , 1 , 5 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE if levelOrderIsOfBST ( arr , n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
if __name__ == " _ _ main _ _ " : NEW_LINE INDENT marks = [ 25 , 65 , 46 , 98 , 78 , 65 ] NEW_LINE max_marks = len ( marks ) * 100 NEW_LINE total = 0 NEW_LINE grade = ' F ' NEW_LINE for i in range ( len ( marks ) ) : NEW_LINE INDENT total += marks [ i ] NEW_LINE DEDENT percentage = ( ( total ) / max_marks ) * 100 NEW_LINE if ( percentage >= 90 ) : NEW_LINE INDENT grade = ' A ' NEW_LINE DEDENT else : NEW_LINE INDENT if ( percentage >= 80 and percentage <= 89 ) : NEW_LINE INDENT grade = ' B ' NEW_LINE DEDENT else : NEW_LINE INDENT if ( percentage >= 60 and percentage <= 79 ) : NEW_LINE INDENT grade = ' C ' NEW_LINE DEDENT else : NEW_LINE INDENT if ( percentage >= 33 and percentage <= 59 ) : NEW_LINE INDENT grade = ' D ' NEW_LINE DEDENT else : NEW_LINE INDENT grade = ' F ' NEW_LINE DEDENT DEDENT DEDENT DEDENT print ( grade ) NEW_LINE DEDENT
def printPartition ( n , m ) : NEW_LINE INDENT k = int ( n / m ) NEW_LINE ct = n % m NEW_LINE for i in range ( 1 , ct + 1 , 1 ) : NEW_LINE INDENT print ( k + 1 , end = " ▁ " ) NEW_LINE DEDENT count = i NEW_LINE for i in range ( count , m , 1 ) : NEW_LINE INDENT print ( k , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE m = 2 NEW_LINE printPartition ( n , m ) NEW_LINE DEDENT
def prevComplement ( n , b ) : NEW_LINE INDENT maxNum , digits , num = 0 , 0 , n NEW_LINE while n > 1 : NEW_LINE INDENT digits += 1 NEW_LINE n = n // 10 NEW_LINE DEDENT maxDigit = b - 1 NEW_LINE while digits : NEW_LINE INDENT maxNum = maxNum * 10 + maxDigit NEW_LINE digits -= 1 NEW_LINE DEDENT return maxNum - num NEW_LINE DEDENT def complement ( n , b ) : NEW_LINE INDENT return prevComplement ( n , b ) + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( prevComplement ( 25 , 7 ) ) NEW_LINE print ( complement ( 25 , 7 ) ) NEW_LINE DEDENT
N = 1000 NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT size = ( 2 * N ) + 1 NEW_LINE freq = [ 0 for i in range ( size ) ] NEW_LINE for i in range ( n ) : NEW_LINE INDENT x = arr [ i ] NEW_LINE freq [ x + N ] += 1 NEW_LINE DEDENT ans = 0 NEW_LINE for i in range ( size ) : NEW_LINE INDENT if ( freq [ i ] > 0 ) : NEW_LINE INDENT ans += int ( ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ) NEW_LINE for j in range ( i + 2 , 2001 , 2 ) : NEW_LINE INDENT if ( freq [ j ] > 0 and ( freq [ int ( ( i + j ) / 2 ) ] > 0 ) ) : NEW_LINE INDENT ans += ( freq [ i ] * freq [ j ] ) NEW_LINE DEDENT DEDENT DEDENT DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 4 , 2 , 5 , 1 , 3 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE DEDENT
def countToMake0lternate ( s ) : NEW_LINE INDENT result = 0 NEW_LINE for i in range ( len ( s ) - 1 ) : NEW_LINE INDENT if ( s [ i ] == s [ i + 1 ] ) : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( countToMake0lternate ( "000111" ) ) NEW_LINE print ( countToMake0lternate ( "11111" ) ) NEW_LINE print ( countToMake0lternate ( "01010101" ) ) NEW_LINE DEDENT
def numOfSubseq ( arr , n ) : NEW_LINE INDENT i , inc_count , dec_count = 0 , 0 , 0 ; NEW_LINE max = [ 0 ] * n ; NEW_LINE min = [ 0 ] * n ; NEW_LINE k1 = 0 ; NEW_LINE k2 = 0 ; NEW_LINE if ( arr [ 0 ] < arr [ 1 ] ) : NEW_LINE INDENT min [ k1 ] = 0 ; NEW_LINE k1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT max [ k2 ] = 0 ; NEW_LINE k2 += 1 ; NEW_LINE DEDENT for i in range ( 1 , n - 1 ) : NEW_LINE INDENT if ( arr [ i ] < arr [ i - 1 ] and arr [ i ] < arr [ i + 1 ] ) : NEW_LINE INDENT min [ k1 ] = i ; NEW_LINE k1 += 1 ; NEW_LINE DEDENT if ( arr [ i ] > arr [ i - 1 ] and arr [ i ] > arr [ i + 1 ] ) : NEW_LINE INDENT max [ k2 ] = i ; NEW_LINE k2 += 1 ; NEW_LINE DEDENT DEDENT if ( arr [ n - 1 ] < arr [ n - 2 ] ) : NEW_LINE INDENT min [ k1 ] = n - 1 ; NEW_LINE k1 += 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT max [ k2 ] = n - 1 ; NEW_LINE k2 += 1 ; NEW_LINE DEDENT if ( min [ 0 ] == 0 ) : NEW_LINE INDENT inc_count = k2 ; NEW_LINE dec_count = k1 - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT inc_count = k2 - 1 ; NEW_LINE dec_count = k1 ; NEW_LINE DEDENT print ( " Increasing ▁ Subsequence ▁ Count : ▁ " , inc_count ) ; NEW_LINE print ( " Decreasing ▁ Subsequence ▁ Count : ▁ " , dec_count ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 12 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE numOfSubseq ( arr , n ) ; NEW_LINE DEDENT
N = 10000 ; NEW_LINE arr = [ 0 ] * N ; NEW_LINE def seive ( ) : NEW_LINE INDENT i = 2 ; NEW_LINE while ( i * i < N ) : NEW_LINE INDENT if ( arr [ i ] == 0 ) : NEW_LINE INDENT j = 2 ; NEW_LINE while ( i * j < N ) : NEW_LINE INDENT arr [ i * j ] += i ; NEW_LINE j += 1 ; NEW_LINE DEDENT DEDENT i += 1 ; NEW_LINE DEDENT DEDENT def sum ( l , r ) : NEW_LINE INDENT seive ( ) ; NEW_LINE pref_arr = [ 0 ] * ( r + 1 ) ; NEW_LINE pref_arr [ 0 ] = arr [ 0 ] ; NEW_LINE for i in range ( 1 , r + 1 ) : NEW_LINE INDENT pref_arr [ i ] = pref_arr [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT if ( l == 1 ) : NEW_LINE INDENT return ( pref_arr [ r ] ) ; NEW_LINE DEDENT else : NEW_LINE INDENT return ( pref_arr [ r ] - pref_arr [ l - 1 ] ) ; NEW_LINE DEDENT DEDENT l = 5 ; NEW_LINE r = 10 ; NEW_LINE print ( sum ( l , r ) ) ; NEW_LINE
PI = 3.14159265 NEW_LINE def area_cicumscribed ( c ) : NEW_LINE INDENT return ( c * c * ( PI / 4 ) ) NEW_LINE DEDENT c = 8.0 NEW_LINE print ( area_cicumscribed ( c ) ) NEW_LINE
N = 3 NEW_LINE M = 3 NEW_LINE def majorityInMatrix ( arr ) : NEW_LINE INDENT mp = { i : 0 for i in range ( 7 ) } NEW_LINE for i in range ( len ( arr ) ) : NEW_LINE INDENT for j in range ( len ( arr ) ) : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] += 1 NEW_LINE DEDENT DEDENT countMajority = 0 NEW_LINE for key , value in mp . items ( ) : NEW_LINE INDENT if ( value >= ( int ( ( N * M ) / 2 ) ) ) : NEW_LINE INDENT countMajority += 1 NEW_LINE DEDENT DEDENT return countMajority NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT mat = [ [ 1 , 2 , 2 ] , [ 1 , 3 , 2 ] , [ 1 , 2 , 6 ] ] NEW_LINE print ( majorityInMatrix ( mat ) ) NEW_LINE DEDENT
def printSumSeries ( N ) : NEW_LINE INDENT sum = 0 ; NEW_LINE for i in range ( 1 , N + 1 ) : NEW_LINE INDENT sum += 1.0 / ( 2 * i - 1 ) ; NEW_LINE DEDENT print ( sum ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT N = 6 ; NEW_LINE printSumSeries ( N ) ; NEW_LINE DEDENT
def deleteElement ( A , L , R , N ) : NEW_LINE INDENT j = 0 NEW_LINE for i in range ( N ) : NEW_LINE INDENT if i <= L or i >= R : NEW_LINE INDENT A [ j ] = A [ i ] NEW_LINE j += 1 NEW_LINE DEDENT DEDENT return j NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A = [ 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 ] NEW_LINE L , R = 2 , 7 NEW_LINE n = len ( A ) NEW_LINE res_size = deleteElement ( A , L , R , n ) NEW_LINE for i in range ( res_size ) : NEW_LINE INDENT print ( A [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def areElementsContiguous ( arr , n ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( arr [ i ] - arr [ i - 1 ] > 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT return 1 NEW_LINE DEDENT arr = [ 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE if areElementsContiguous ( arr , n ) : print ( " Yes " ) NEW_LINE else : print ( " No " ) NEW_LINE
maxin = 100001 ; NEW_LINE divisors = [ 0 ] * ( maxin + 1 ) ; NEW_LINE def Calc_Max_Div ( arr , n ) : NEW_LINE INDENT vis = [ 1 ] * ( maxin + 1 ) ; NEW_LINE vis [ 0 ] = vis [ 1 ] = 0 ; NEW_LINE for i in range ( 1 , maxin + 1 ) : NEW_LINE INDENT divisors [ i ] = i ; NEW_LINE DEDENT for i in range ( 4 , maxin + 1 , 2 ) : NEW_LINE INDENT vis [ i ] = 0 ; NEW_LINE divisors [ i ] = i // 2 ; NEW_LINE DEDENT for i in range ( 3 , maxin + 1 , 2 ) : NEW_LINE INDENT if ( divisors [ i ] != i ) : NEW_LINE INDENT divisors [ i ] = i // divisors [ i ] ; NEW_LINE DEDENT if ( vis [ i ] == 1 ) : NEW_LINE INDENT for j in range ( i * i , maxin , i ) : NEW_LINE INDENT vis [ j ] = 0 ; NEW_LINE if ( divisors [ j ] == j ) : NEW_LINE INDENT divisors [ j ] = i ; NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT if ( divisors [ arr [ i ] ] == arr [ i ] ) : NEW_LINE INDENT print ( " - 1 ▁ " , end = " " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( divisors [ arr [ i ] ] , end = " ▁ " ) ; NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 5 , 6 , 7 , 8 , 9 , 10 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE Calc_Max_Div ( arr , n ) ; NEW_LINE DEDENT
MAX = 10000 NEW_LINE sequence = [ 0 ] * ( MAX + 1 ) ; NEW_LINE def vanEckSequence ( ) : NEW_LINE INDENT for i in range ( MAX ) : NEW_LINE INDENT for j in range ( i - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( sequence [ j ] == sequence [ i ] ) : NEW_LINE INDENT sequence [ i + 1 ] = i - j ; NEW_LINE break ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def getCount ( n ) : NEW_LINE INDENT count = 1 ; NEW_LINE i = n - 1 ; NEW_LINE while ( sequence [ i + 1 ] != 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE i = i - sequence [ i + 1 ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT vanEckSequence ( ) ; NEW_LINE n = 5 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE n = 11 ; NEW_LINE print ( getCount ( n ) ) ; NEW_LINE DEDENT
def countGreater ( arr , n , k ) : NEW_LINE INDENT l = 0 NEW_LINE r = n - 1 NEW_LINE leftGreater = n NEW_LINE while ( l <= r ) : NEW_LINE INDENT m = int ( l + ( r - l ) / 2 ) NEW_LINE if ( arr [ m ] > k ) : NEW_LINE INDENT leftGreater = m NEW_LINE r = m - 1 NEW_LINE DEDENT else : NEW_LINE INDENT l = m + 1 NEW_LINE DEDENT DEDENT return ( n - leftGreater ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 ] NEW_LINE n = len ( arr ) NEW_LINE k = 7 NEW_LINE print ( countGreater ( arr , n , k ) ) NEW_LINE DEDENT
def counLastDigitK ( low , high , k ) : NEW_LINE INDENT count = ( high - low ) / 10 NEW_LINE if ( high % 10 >= k ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT if ( low % 10 > k ) : NEW_LINE INDENT count -= 1 NEW_LINE DEDENT return int ( count ) NEW_LINE DEDENT low = 3 NEW_LINE high = 35 NEW_LINE k = 3 NEW_LINE print ( counLastDigitK ( low , high , k ) ) NEW_LINE
def squareRootExists ( n , p ) : NEW_LINE INDENT n = n % p NEW_LINE for x in range ( 2 , p , 1 ) : NEW_LINE INDENT if ( ( x * x ) % p == n ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT p = 7 NEW_LINE n = 2 NEW_LINE if ( squareRootExists ( n , p ) == True ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def findWays ( f , d , s ) : NEW_LINE INDENT mem = [ [ 0 for i in range ( s + 1 ) ] for j in range ( d + 1 ) ] NEW_LINE mem [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , d + 1 ) : NEW_LINE INDENT for j in range ( 1 , s + 1 ) : NEW_LINE INDENT mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] NEW_LINE if j - f - 1 >= 0 : NEW_LINE INDENT mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] NEW_LINE DEDENT DEDENT DEDENT return mem [ d ] [ s ] NEW_LINE DEDENT print ( findWays ( 4 , 2 , 1 ) ) NEW_LINE print ( findWays ( 2 , 2 , 3 ) ) NEW_LINE print ( findWays ( 6 , 3 , 8 ) ) NEW_LINE print ( findWays ( 4 , 2 , 5 ) ) NEW_LINE print ( findWays ( 4 , 3 , 5 ) ) NEW_LINE
from math import * NEW_LINE def nextFibonacci ( n ) : NEW_LINE INDENT a = n * ( 1 + sqrt ( 5 ) ) / 2.0 NEW_LINE return round ( a ) NEW_LINE DEDENT n = 5 NEW_LINE print ( nextFibonacci ( n ) ) NEW_LINE
def maxLCM ( n ) : NEW_LINE INDENT return ( n * ( n - 1 ) ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 3 ; NEW_LINE print ( maxLCM ( n ) ) ; NEW_LINE DEDENT
def isPrime ( n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 2 , n ) : NEW_LINE INDENT if n % i == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def printPrime ( n ) : NEW_LINE INDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if isPrime ( i ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 7 NEW_LINE printPrime ( n ) NEW_LINE DEDENT
def divide ( a , b ) : NEW_LINE INDENT for i in range ( 2 , min ( a , b ) + 1 ) : NEW_LINE INDENT while ( a % i == 0 and b % i == 0 ) : NEW_LINE INDENT a = a // i NEW_LINE b = b // i NEW_LINE DEDENT DEDENT print ( " A ▁ = " , a , " , ▁ B ▁ = " , b ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT A , B = 10 , 15 NEW_LINE divide ( A , B ) NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT if n <= 1 : NEW_LINE INDENT return NEW_LINE DEDENT prev = arr [ 0 ] NEW_LINE arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT curr = arr [ i ] NEW_LINE arr [ i ] = prev ^ arr [ i + 1 ] NEW_LINE prev = curr NEW_LINE DEDENT arr [ n - 1 ] = prev ^ arr [ n - 1 ] NEW_LINE DEDENT arr = [ 2 , 3 , 4 , 5 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def countOne ( n ) : NEW_LINE INDENT count = 0 NEW_LINE while ( n ) : NEW_LINE INDENT n = n & ( n - 1 ) NEW_LINE count += 1 NEW_LINE DEDENT if ( count % 2 == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return 0 NEW_LINE DEDENT DEDENT def summDigits ( n ) : NEW_LINE INDENT summ = 0 NEW_LINE while ( n != 0 ) : NEW_LINE INDENT summ += n % 10 NEW_LINE n //= 10 NEW_LINE DEDENT return summ NEW_LINE DEDENT arr = [ 4 , 9 , 15 ] NEW_LINE n = len ( arr ) NEW_LINE total_summ = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( countOne ( arr [ i ] ) ) : NEW_LINE INDENT total_summ += summDigits ( arr [ i ] ) NEW_LINE DEDENT DEDENT print ( total_summ ) NEW_LINE
import math as mt NEW_LINE def countPairs ( arr , n ) : NEW_LINE INDENT count_2 , count_others = 0 , 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] == 2 : NEW_LINE INDENT count_2 += 1 NEW_LINE DEDENT elif arr [ i ] > 2 : NEW_LINE INDENT count_others += 1 NEW_LINE DEDENT DEDENT ans = ( count_2 * count_others + ( count_others * ( count_others - 1 ) ) // 2 ) NEW_LINE return ans NEW_LINE DEDENT arr = [ 5 , 0 , 3 , 1 , 2 ] NEW_LINE n = len ( arr ) NEW_LINE print ( countPairs ( arr , n ) ) NEW_LINE
def checkCentrosymmetricted ( n , m ) : NEW_LINE INDENT mid_row = 0 ; NEW_LINE if ( ( n & 1 ) > 0 ) : NEW_LINE INDENT mid_row = n / 2 + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT mid_row = n / 2 ; NEW_LINE DEDENT for i in range ( int ( mid_row ) ) : NEW_LINE INDENT for j in range ( n ) : NEW_LINE INDENT if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) : NEW_LINE INDENT return False ; NEW_LINE DEDENT DEDENT DEDENT return True ; NEW_LINE DEDENT n = 3 ; NEW_LINE m = [ [ 1 , 3 , 5 ] , [ 6 , 8 , 6 ] , [ 5 , 3 , 1 ] ] ; NEW_LINE if ( checkCentrosymmetricted ( n , m ) ) : NEW_LINE INDENT print ( " Yes " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) ; NEW_LINE DEDENT
MAX_LEN , MAX_CHAR = 1005 , 26 NEW_LINE cnt = [ [ 0 for i in range ( MAX_CHAR ) ] for j in range ( MAX_LEN ) ] NEW_LINE def preProcess ( s ) : NEW_LINE INDENT n = len ( s ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT cnt [ i ] [ ord ( s [ i ] ) - ord ( ' a ' ) ] += 1 NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT for j in range ( 0 , 26 ) : NEW_LINE INDENT cnt [ i ] [ j ] += cnt [ i - 1 ] [ j ] NEW_LINE DEDENT DEDENT DEDENT def findCharFreq ( l , r , c ) : NEW_LINE INDENT return ( cnt [ r ] [ ord ( c ) - 97 ] - cnt [ l - 1 ] [ ord ( c ) - 97 ] ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeksforgeeks " NEW_LINE Q = 4 NEW_LINE preProcess ( s ) NEW_LINE print ( findCharFreq ( 0 , 5 , ' e ' ) ) NEW_LINE print ( findCharFreq ( 2 , 6 , ' f ' ) ) NEW_LINE print ( findCharFreq ( 4 , 7 , ' m ' ) ) NEW_LINE print ( findCharFreq ( 0 , 12 , ' e ' ) ) NEW_LINE DEDENT
from collections import deque NEW_LINE def minimumColors ( N , E , U , V ) : NEW_LINE INDENT adj = [ [ ] for i in range ( N ) ] NEW_LINE count = [ 0 ] * N NEW_LINE colors = [ 1 ] * ( N ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT adj [ V [ i ] - 1 ] . append ( U [ i ] - 1 ) NEW_LINE count [ U [ i ] - 1 ] += 1 NEW_LINE DEDENT Q = deque ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT if ( count [ i ] == 0 ) : NEW_LINE INDENT Q . append ( i ) NEW_LINE DEDENT DEDENT while len ( Q ) > 0 : NEW_LINE INDENT u = Q . popleft ( ) NEW_LINE for x in adj [ u ] : NEW_LINE INDENT count [ x ] -= 1 NEW_LINE if ( count [ x ] == 0 ) : NEW_LINE INDENT Q . append ( x ) NEW_LINE DEDENT if ( colors [ x ] <= colors [ u ] ) : NEW_LINE INDENT colors [ x ] = 1 + colors [ u ] NEW_LINE DEDENT DEDENT DEDENT minColor = - 1 NEW_LINE for i in range ( N ) : NEW_LINE INDENT minColor = max ( minColor , colors [ i ] ) NEW_LINE DEDENT print ( minColor ) NEW_LINE DEDENT N = 5 NEW_LINE E = 6 NEW_LINE U = [ 1 , 2 , 3 , 1 , 2 , 3 ] NEW_LINE V = [ 3 , 3 , 4 , 4 , 5 , 5 ] NEW_LINE minimumColors ( N , E , U , V ) NEW_LINE
import math NEW_LINE def findRoots ( a , b , c ) : NEW_LINE INDENT if a == 0 : NEW_LINE INDENT print ( " Invalid " ) NEW_LINE return - 1 NEW_LINE DEDENT d = b * b - 4 * a * c NEW_LINE sqrt_val = math . sqrt ( abs ( d ) ) NEW_LINE if d > 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ " ) NEW_LINE print ( ( - b + sqrt_val ) / ( 2 * a ) ) NEW_LINE print ( ( - b - sqrt_val ) / ( 2 * a ) ) NEW_LINE DEDENT elif d == 0 : NEW_LINE INDENT print ( " Roots ▁ are ▁ real ▁ and ▁ same " ) NEW_LINE print ( - b / ( 2 * a ) ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Roots ▁ are ▁ complex " ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ + ▁ i " , sqrt_val ) NEW_LINE print ( - b / ( 2 * a ) , " ▁ - ▁ i " , sqrt_val ) NEW_LINE DEDENT DEDENT a = 1 NEW_LINE b = - 7 NEW_LINE c = 12 NEW_LINE findRoots ( a , b , c ) NEW_LINE
import sys NEW_LINE N = 3 NEW_LINE M = 3 NEW_LINE def sumOddOccuring ( arr ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( N ) : NEW_LINE INDENT for j in range ( M ) : NEW_LINE INDENT if arr [ i ] [ j ] in mp : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] [ j ] ] = 1 NEW_LINE DEDENT DEDENT DEDENT s = 0 NEW_LINE for i in mp : NEW_LINE INDENT if mp [ i ] % 2 == 0 : NEW_LINE INDENT x = mp [ i ] NEW_LINE s += i * mp [ i ] NEW_LINE DEDENT DEDENT return s NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT mat = [ [ 1 , 2 , 3 ] , [ 1 , 3 , 2 ] , [ 1 , 5 , 6 ] ] NEW_LINE print ( sumOddOccuring ( mat ) ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = 5 NEW_LINE while ( i * i <= n ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT i = i + 6 NEW_LINE DEDENT return True NEW_LINE DEDENT def power ( x , y , p ) : NEW_LINE INDENT res = 1 NEW_LINE x = x % p NEW_LINE while ( y > 0 ) : NEW_LINE INDENT if ( y & 1 ) : NEW_LINE INDENT res = ( res * x ) % p NEW_LINE DEDENT y = y >> 1 NEW_LINE x = ( x * x ) % p NEW_LINE DEDENT return res NEW_LINE DEDENT def findPrimefactors ( s , n ) : NEW_LINE INDENT while ( n % 2 == 0 ) : NEW_LINE INDENT s . add ( 2 ) NEW_LINE n = n // 2 NEW_LINE DEDENT for i in range ( 3 , int ( sqrt ( n ) ) , 2 ) : NEW_LINE INDENT while ( n % i == 0 ) : NEW_LINE INDENT s . add ( i ) NEW_LINE n = n // i NEW_LINE DEDENT DEDENT if ( n > 2 ) : NEW_LINE INDENT s . add ( n ) NEW_LINE DEDENT DEDENT def findPrimitive ( n ) : NEW_LINE INDENT s = set ( ) NEW_LINE if ( isPrime ( n ) == False ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT phi = n - 1 NEW_LINE findPrimefactors ( s , phi ) NEW_LINE for r in range ( 2 , phi + 1 ) : NEW_LINE INDENT flag = False NEW_LINE for it in s : NEW_LINE INDENT if ( power ( r , phi // it , n ) == 1 ) : NEW_LINE INDENT flag = True NEW_LINE break NEW_LINE DEDENT DEDENT if ( flag == False ) : NEW_LINE INDENT return r NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT n = 761 NEW_LINE print ( " Smallest ▁ primitive ▁ root ▁ of " , n , " is " , findPrimitive ( n ) ) NEW_LINE
max = 50009 NEW_LINE def find_Indices ( arr , n ) : NEW_LINE INDENT sum = [ 0 for i in range ( max ) ] NEW_LINE k = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT sum [ i ] = sum [ i - 1 ] + arr [ k ] ; NEW_LINE k += 1 NEW_LINE DEDENT ans = - ( 1e15 ) NEW_LINE index_1 = index_2 = index_3 = - 1 NEW_LINE for l in range ( n + 1 ) : NEW_LINE INDENT index = 0 NEW_LINE vmin = ( 1e15 ) NEW_LINE for r in range ( l , n + 1 ) : NEW_LINE INDENT if ( sum [ r ] < vmin ) : NEW_LINE INDENT vmin = sum [ r ] NEW_LINE index = r NEW_LINE DEDENT if ( sum [ l ] + sum [ r ] - vmin > ans ) : NEW_LINE INDENT ans = sum [ l ] + sum [ r ] - vmin NEW_LINE index_1 = l NEW_LINE index_2 = index NEW_LINE index_3 = r NEW_LINE DEDENT DEDENT DEDENT print ( index_1 , " ▁ " , index_2 , " ▁ " , index_3 ) NEW_LINE DEDENT arr = [ - 1 , 2 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE find_Indices ( arr , n ) NEW_LINE
def countWays ( n , l , r ) : NEW_LINE INDENT tL , tR = l , r NEW_LINE L = [ 0 for i in range ( 2 ) ] NEW_LINE R = [ 0 for i in range ( 2 ) ] NEW_LINE L [ l % 2 ] = l NEW_LINE R [ r % 2 ] = r NEW_LINE l += 1 NEW_LINE r -= 1 NEW_LINE if ( l <= tR and r >= tL ) : NEW_LINE INDENT L [ l % 2 ] , R [ r % 2 ] = l , r NEW_LINE DEDENT cnt0 , cnt1 = 0 , 0 NEW_LINE if ( R [ 0 ] and L [ 0 ] ) : NEW_LINE INDENT cnt0 = ( R [ 0 ] - L [ 0 ] ) // 2 + 1 NEW_LINE DEDENT if ( R [ 1 ] and L [ 1 ] ) : NEW_LINE INDENT cnt1 = ( R [ 1 ] - L [ 1 ] ) // 2 + 1 NEW_LINE DEDENT dp = [ [ 0 for i in range ( 2 ) ] for i in range ( n + 1 ) ] NEW_LINE dp [ 1 ] [ 0 ] = cnt0 NEW_LINE dp [ 1 ] [ 1 ] = cnt1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) NEW_LINE dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) NEW_LINE DEDENT return dp [ n ] [ 0 ] NEW_LINE DEDENT n , l , r = 2 , 1 , 3 NEW_LINE print ( countWays ( n , l , r ) ) NEW_LINE
def printPair ( g , l ) : NEW_LINE INDENT n = g * l ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( n % i == 0 ) : NEW_LINE INDENT first = i ; NEW_LINE second = n // i ; NEW_LINE gcd = __gcd ( first , second ) ; NEW_LINE if ( gcd == g and l % first == 0 and l % second == 0 ) : NEW_LINE INDENT print ( first , " ▁ " , second ) ; NEW_LINE return ; NEW_LINE DEDENT DEDENT DEDENT DEDENT def __gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a ; NEW_LINE DEDENT else : NEW_LINE INDENT return __gcd ( b , a % b ) ; NEW_LINE DEDENT DEDENT g = 3 ; NEW_LINE l = 12 ; NEW_LINE printPair ( g , l ) ; NEW_LINE
def count_pairs ( s1 , s2 , n1 , n2 ) : NEW_LINE INDENT mp = { s1 [ i ] : 0 for i in range ( len ( s1 ) ) } NEW_LINE for i in range ( n1 ) : NEW_LINE INDENT mp [ s1 [ i ] ] += 1 NEW_LINE DEDENT cnt = 0 NEW_LINE for i in range ( n2 ) : NEW_LINE INDENT if ( mp [ s2 [ i ] ] > 0 ) : NEW_LINE INDENT cnt += 1 NEW_LINE mp [ s2 [ i ] ] -= 1 NEW_LINE DEDENT DEDENT return cnt NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT s1 = [ " abc " , " def " ] NEW_LINE s2 = [ " abc " , " abc " ] NEW_LINE n1 = len ( s1 ) NEW_LINE n2 = len ( s2 ) NEW_LINE print ( count_pairs ( s1 , s2 , n1 , n2 ) ) NEW_LINE DEDENT
NA = - 1 NEW_LINE def moveToEnd ( mPlusN , size ) : NEW_LINE INDENT i = 0 NEW_LINE j = size - 1 NEW_LINE for i in range ( size - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( mPlusN [ i ] != NA ) : NEW_LINE INDENT mPlusN [ j ] = mPlusN [ i ] NEW_LINE j -= 1 NEW_LINE DEDENT DEDENT DEDENT def merge ( mPlusN , N , m , n ) : NEW_LINE INDENT i = n NEW_LINE j = 0 NEW_LINE k = 0 NEW_LINE while ( k < ( m + n ) ) : NEW_LINE INDENT if ( ( i < ( m + n ) and mPlusN [ i ] <= N [ j ] ) or ( j == n ) ) : NEW_LINE INDENT mPlusN [ k ] = mPlusN [ i ] NEW_LINE k += 1 NEW_LINE i += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mPlusN [ k ] = N [ j ] NEW_LINE k += 1 NEW_LINE j += 1 NEW_LINE DEDENT DEDENT DEDENT def printArray ( arr , size ) : NEW_LINE INDENT for i in range ( size ) : NEW_LINE INDENT print ( arr [ i ] , " ▁ " , end = " " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT mPlusN = [ 2 , 8 , NA , NA , NA , 13 , NA , 15 , 20 ] NEW_LINE N = [ 5 , 7 , 9 , 25 ] NEW_LINE n = len ( N ) NEW_LINE m = len ( mPlusN ) - n NEW_LINE moveToEnd ( mPlusN , m + n ) NEW_LINE merge ( mPlusN , N , m , n ) NEW_LINE printArray ( mPlusN , m + n ) NEW_LINE
def isDivisibleby17 ( n ) : NEW_LINE INDENT if ( n == 0 or n == 17 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n < 17 ) : NEW_LINE INDENT return False NEW_LINE DEDENT return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) NEW_LINE DEDENT n = 35 NEW_LINE if ( isDivisibleby17 ( n ) ) : NEW_LINE INDENT print ( n , " is ▁ divisible ▁ by ▁ 17" ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ divisible ▁ by ▁ 17" ) NEW_LINE DEDENT
min1 = 10 ** 9 NEW_LINE _count = 0 NEW_LINE def permutation ( str1 , i , n , p ) : NEW_LINE INDENT global min1 , _count NEW_LINE if ( i == n ) : NEW_LINE INDENT str1 = " " . join ( str1 ) NEW_LINE q = int ( str1 ) NEW_LINE if ( q - p > 0 and q < min1 ) : NEW_LINE INDENT min1 = q NEW_LINE _count = 1 NEW_LINE DEDENT DEDENT else : NEW_LINE INDENT for j in range ( i , n + 1 ) : NEW_LINE INDENT str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ] NEW_LINE permutation ( str1 , i + 1 , n , p ) NEW_LINE str1 [ i ] , str1 [ j ] = str1 [ j ] , str1 [ i ] NEW_LINE DEDENT DEDENT return min1 NEW_LINE DEDENT A = 213 NEW_LINE B = 111 NEW_LINE str2 = str ( A ) NEW_LINE str1 = [ i for i in str2 ] NEW_LINE le = len ( str1 ) NEW_LINE h = permutation ( str1 , 0 , le - 1 , B ) NEW_LINE if _count == 1 : NEW_LINE INDENT print ( h ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( - 1 ) NEW_LINE DEDENT
def stepRequired ( n ) : NEW_LINE INDENT return bin ( 94 ) . count ( '1' ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 94 NEW_LINE print ( stepRequired ( n ) ) NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT res = 0 ; NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( i % 3 == 0 or i % 7 == 0 ) : NEW_LINE INDENT res += 1 ; NEW_LINE DEDENT DEDENT return res ; NEW_LINE DEDENT print ( " Count ▁ = " , countMultiples ( 25 ) ) ; NEW_LINE
arr = [ 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 ] ; NEW_LINE def countKeyPressed ( string , length ) : NEW_LINE INDENT count = 0 ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT count += arr [ ord ( string [ i ] ) - ord ( ' a ' ) ] ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT string = " abcdef " ; NEW_LINE length = len ( string ) ; NEW_LINE print ( countKeyPressed ( string , length ) ) ; NEW_LINE DEDENT
def fact ( n ) : NEW_LINE INDENT if n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT else : NEW_LINE INDENT return n * fact ( n - 1 ) NEW_LINE DEDENT DEDENT def sum ( x , n ) : NEW_LINE INDENT total = 1.0 NEW_LINE for i in range ( 1 , n + 1 , 1 ) : NEW_LINE INDENT total = total + ( pow ( x , i ) / fact ( i + 1 ) ) NEW_LINE DEDENT return total NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x = 5 NEW_LINE n = 4 NEW_LINE print ( " Sum ▁ is : ▁ { 0 : . 4f } " . format ( sum ( x , n ) ) ) NEW_LINE DEDENT
from collections import defaultdict NEW_LINE def longestPermutation ( a , n ) : NEW_LINE INDENT freq = defaultdict ( int ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT freq [ a [ i ] ] += 1 NEW_LINE DEDENT length = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT if ( freq [ i ] == 0 ) : NEW_LINE INDENT break NEW_LINE DEDENT length += 1 NEW_LINE DEDENT return length NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 2 , 1 , 6 , 5 ] NEW_LINE n = len ( arr ) NEW_LINE print ( longestPermutation ( arr , n ) ) NEW_LINE DEDENT
import math NEW_LINE def findLCM ( arr , n ) : NEW_LINE INDENT lcm = arr [ 0 ] ; NEW_LINE for i in range ( 1 , n - 1 ) : NEW_LINE INDENT lcm = ( lcm * arr [ i ] ) / math . gcd ( arr [ i ] , lcm ) ; NEW_LINE DEDENT return lcm ; NEW_LINE DEDENT def countNumbers ( arr , n , l , r ) : NEW_LINE INDENT lcm = int ( findLCM ( arr , n ) ) ; NEW_LINE count = ( r / lcm ) - ( ( l - 1 ) / lcm ) ; NEW_LINE print ( int ( count ) ) ; NEW_LINE DEDENT arr = [ 1 , 4 , 2 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE l = 1 ; NEW_LINE r = 10 ; NEW_LINE countNumbers ( arr , n , l , r ) ; NEW_LINE
def findNum ( a , n , b , m ) : NEW_LINE INDENT x = max ( a ) ; NEW_LINE y = max ( b ) ; NEW_LINE print ( x , y ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 2 , 2 ] ; NEW_LINE n = len ( a ) ; NEW_LINE b = [ 1 , 5 , 7 , 7 , 9 ] ; NEW_LINE m = len ( b ) ; NEW_LINE findNum ( a , n , b , m ) ; NEW_LINE DEDENT
def type1 ( arr , start , limit ) : NEW_LINE INDENT for i in range ( start , limit + 1 ) : NEW_LINE INDENT arr [ i ] += 1 NEW_LINE DEDENT DEDENT def type2 ( arr , query , start , limit ) : NEW_LINE INDENT for i in range ( start , limit + 1 ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) NEW_LINE DEDENT elif ( query [ i ] [ 0 ] == 2 ) : NEW_LINE INDENT type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) NEW_LINE DEDENT DEDENT DEDENT n = 5 NEW_LINE m = 5 NEW_LINE arr = [ 0 for i in range ( n + 1 ) ] NEW_LINE temp = [ 1 , 1 , 2 , 1 , 4 , 5 , 2 , 1 , 2 , 2 , 1 , 3 , 2 , 3 , 4 ] NEW_LINE query = [ [ 0 for i in range ( 3 ) ] for j in range ( 6 ) ] NEW_LINE j = 0 NEW_LINE for i in range ( 1 , m + 1 ) : NEW_LINE INDENT query [ i ] [ 0 ] = temp [ j ] NEW_LINE j += 1 NEW_LINE query [ i ] [ 1 ] = temp [ j ] NEW_LINE j += 1 NEW_LINE query [ i ] [ 2 ] = temp [ j ] NEW_LINE j += 1 NEW_LINE DEDENT for i in range ( 1 , m + 1 ) : NEW_LINE INDENT if ( query [ i ] [ 0 ] == 1 ) : NEW_LINE INDENT type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) NEW_LINE DEDENT elif ( query [ i ] [ 0 ] == 2 ) : NEW_LINE INDENT type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) NEW_LINE DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT
def count ( S , m , n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT if ( n < 0 ) : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT if ( m <= 0 and n >= 1 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 ] NEW_LINE m = len ( arr ) NEW_LINE print ( count ( arr , m , 4 ) ) NEW_LINE
def Divisors ( x ) : NEW_LINE INDENT c = 0 NEW_LINE v = [ ] NEW_LINE while ( x % 2 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 2 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 3 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 3 NEW_LINE DEDENT v . append ( c ) NEW_LINE c = 0 NEW_LINE while ( x % 7 == 0 ) : NEW_LINE INDENT c += 1 NEW_LINE x /= 7 NEW_LINE DEDENT v . append ( c ) NEW_LINE v . append ( x ) NEW_LINE return v NEW_LINE DEDENT def MinOperations ( a , b ) : NEW_LINE INDENT va = Divisors ( a ) NEW_LINE vb = Divisors ( b ) NEW_LINE if ( va [ 3 ] != vb [ 3 ] ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT minOperations = abs ( va [ 0 ] - vb [ 0 ] ) + abs ( va [ 1 ] - vb [ 1 ] ) + abs ( va [ 2 ] - vb [ 2 ] ) NEW_LINE return minOperations NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 14 NEW_LINE b = 28 NEW_LINE print ( MinOperations ( a , b ) ) NEW_LINE DEDENT
def areDistinct ( arr ) : NEW_LINE INDENT n = len ( arr ) NEW_LINE s = set ( ) NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT s . add ( arr [ i ] ) NEW_LINE DEDENT return ( len ( s ) == len ( arr ) ) NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 2 ] NEW_LINE if ( areDistinct ( arr ) ) : NEW_LINE INDENT print ( " All ▁ Elements ▁ are ▁ Distinct " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ all ▁ Elements ▁ are ▁ Distinct " ) NEW_LINE DEDENT
def createSemiPrimeSieve ( n ) : NEW_LINE INDENT v = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT v [ i ] = i NEW_LINE DEDENT countDivision = [ 0 for i in range ( n + 1 ) ] NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT countDivision [ i ] = 2 NEW_LINE DEDENT for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( v [ i ] == i and countDivision [ i ] == 2 ) : NEW_LINE INDENT for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT if ( countDivision [ j ] > 0 ) : NEW_LINE INDENT v [ j ] = int ( v [ j ] / i ) NEW_LINE countDivision [ j ] -= 1 NEW_LINE DEDENT DEDENT DEDENT DEDENT res = [ ] NEW_LINE for i in range ( 2 , n + 1 , 1 ) : NEW_LINE INDENT if ( v [ i ] == 1 and countDivision [ i ] == 0 ) : NEW_LINE INDENT res . append ( i ) NEW_LINE DEDENT DEDENT return res NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 16 NEW_LINE semiPrime = createSemiPrimeSieve ( n ) NEW_LINE for i in range ( len ( semiPrime ) ) : NEW_LINE INDENT print ( semiPrime [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def findPattern ( n ) : NEW_LINE INDENT prev = n % 2 NEW_LINE n = n // 2 NEW_LINE while ( n > 0 ) : NEW_LINE INDENT curr = n % 2 NEW_LINE if ( curr == prev ) : NEW_LINE INDENT return False NEW_LINE DEDENT prev = curr NEW_LINE n = n // 2 NEW_LINE DEDENT return True NEW_LINE DEDENT n = 10 NEW_LINE print ( " Yes " ) if ( findPattern ( n ) ) else print ( " No " ) NEW_LINE
def countSubstringWithEqualEnds ( s ) : NEW_LINE INDENT result = 0 ; NEW_LINE n = len ( s ) ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( i , n ) : NEW_LINE INDENT if ( s [ i ] == s [ j ] ) : NEW_LINE INDENT result = result + 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT s = " abcab " ; NEW_LINE print ( countSubstringWithEqualEnds ( s ) ) NEW_LINE
def arraySum ( arr , n ) : NEW_LINE INDENT _sum = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT _sum = _sum + arr [ i ] NEW_LINE DEDENT return _sum NEW_LINE DEDENT arr = [ 10 , 11 , 12 , 13 , 12 , 11 , 10 ] NEW_LINE n = len ( arr ) NEW_LINE print ( arraySum ( arr , n ) ) NEW_LINE
from math import tan NEW_LINE def InscribedCircleArea ( n , a ) : NEW_LINE INDENT if ( a < 0 and n < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT r = a / ( 2 * tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; NEW_LINE Area = 3.14 * r * r NEW_LINE return Area NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = 4 NEW_LINE n = 6 NEW_LINE print ( ' { 0 : . 6 } ' . format ( InscribedCircleArea ( n , a ) ) ) NEW_LINE DEDENT
def minChanges ( arr , n ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] in mp . keys ( ) : NEW_LINE INDENT mp [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT maxElem = 0 NEW_LINE for x in mp : NEW_LINE INDENT maxElem = max ( maxElem , mp [ x ] ) NEW_LINE DEDENT return n - maxElem NEW_LINE DEDENT arr = [ 2 , 3 , 3 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minChanges ( arr , n ) ) NEW_LINE
def factorial ( n ) : NEW_LINE INDENT fact = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT fact = fact * i NEW_LINE DEDENT return ( fact ) NEW_LINE DEDENT def result ( n , m ) : NEW_LINE INDENT return ( factorial ( n ) - factorial ( n - m + 1 ) * factorial ( m ) ) NEW_LINE DEDENT print ( result ( 5 , 3 ) ) NEW_LINE
def maxWeight ( arr , n , w1_r , w2_r , i ) : NEW_LINE INDENT if i == n : NEW_LINE INDENT return 0 NEW_LINE DEDENT if dp [ i ] [ w1_r ] [ w2_r ] != - 1 : NEW_LINE INDENT return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT fill_w1 , fill_w2 , fill_none = 0 , 0 , 0 NEW_LINE if w1_r >= arr [ i ] : NEW_LINE INDENT fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) NEW_LINE DEDENT if w2_r >= arr [ i ] : NEW_LINE INDENT fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) NEW_LINE DEDENT fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) NEW_LINE dp [ i ] [ w1_r ] [ w2_r ] = max ( fill_none , max ( fill_w1 , fill_w2 ) ) NEW_LINE return dp [ i ] [ w1_r ] [ w2_r ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 8 , 2 , 3 ] NEW_LINE maxN , maxW = 31 , 31 NEW_LINE dp = [ [ [ - 1 ] * maxW ] * maxW ] * maxN NEW_LINE n = len ( arr ) NEW_LINE w1 , w2 = 10 , 3 NEW_LINE print ( maxWeight ( arr , n , w1 , w2 , 0 ) ) NEW_LINE DEDENT
def Count ( str ) : NEW_LINE INDENT upper , lower , number , special = 0 , 0 , 0 , 0 NEW_LINE for i in range ( len ( str ) ) : NEW_LINE INDENT if str [ i ] >= ' A ' and str [ i ] <= ' Z ' : NEW_LINE INDENT upper += 1 NEW_LINE DEDENT elif str [ i ] >= ' a ' and str [ i ] <= ' z ' : NEW_LINE INDENT lower += 1 NEW_LINE DEDENT elif str [ i ] >= '0' and str [ i ] <= '9' : NEW_LINE INDENT number += 1 NEW_LINE DEDENT else : NEW_LINE INDENT special += 1 NEW_LINE DEDENT DEDENT print ( ' Upper ▁ case ▁ letters : ' , upper ) NEW_LINE print ( ' Lower ▁ case ▁ letters : ' , lower ) NEW_LINE print ( ' Number : ' , number ) NEW_LINE print ( ' Special ▁ characters : ' , special ) NEW_LINE DEDENT str = " # GeeKs01fOr @ gEEks07" NEW_LINE Count ( str ) NEW_LINE
def val ( c ) : NEW_LINE INDENT if ( c >= '0' and c <= '9' ) : NEW_LINE INDENT return int ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT return c - ' A ' + 10 NEW_LINE DEDENT DEDENT def toDeci ( strr , base ) : NEW_LINE INDENT lenn = len ( strr ) NEW_LINE power = 1 NEW_LINE num = 0 NEW_LINE for i in range ( lenn - 1 , - 1 , - 1 ) : NEW_LINE INDENT if ( val ( strr [ i ] ) >= base ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT num += val ( strr [ i ] ) * power NEW_LINE power = power * base NEW_LINE DEDENT return num NEW_LINE DEDENT def checkCorrespond ( strr , x ) : NEW_LINE INDENT counter = 0 NEW_LINE n = len ( strr ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT for j in range ( 2 , 37 ) : NEW_LINE INDENT if ( toDeci ( strr [ i ] , j ) == x ) : NEW_LINE INDENT counter += 1 NEW_LINE break NEW_LINE DEDENT DEDENT DEDENT if ( counter == n ) : NEW_LINE INDENT print ( " YES " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) NEW_LINE DEDENT DEDENT x = 16 NEW_LINE strr = [ "10000" , "20" , "16" ] NEW_LINE checkCorrespond ( strr , x ) NEW_LINE
def count ( x , y ) : NEW_LINE INDENT ans = 0 NEW_LINE m = dict ( ) NEW_LINE while x % y != 0 : NEW_LINE INDENT x %= y NEW_LINE ans += 1 NEW_LINE if x in m : NEW_LINE INDENT return - 1 NEW_LINE DEDENT m [ x ] = 1 NEW_LINE x *= 10 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT res = count ( 1 , 2 ) NEW_LINE print ( " INF " ) if res == - 1 else print ( res ) NEW_LINE res = count ( 5 , 3 ) NEW_LINE print ( " INF " ) if res == - 1 else print ( res ) NEW_LINE res = count ( 3 , 5 ) NEW_LINE print ( " INF " ) if res == - 1 else print ( res ) NEW_LINE DEDENT
def nextPowerOf2 ( n ) : NEW_LINE INDENT p = 1 NEW_LINE if ( n and not ( n & ( n - 1 ) ) ) : NEW_LINE INDENT return n NEW_LINE DEDENT while ( p < n ) : NEW_LINE INDENT p <<= 1 NEW_LINE DEDENT return p ; NEW_LINE DEDENT n = 5 NEW_LINE print ( nextPowerOf2 ( n ) ) ; NEW_LINE
def LCM ( arr , n ) : NEW_LINE INDENT max_num = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( max_num < arr [ i ] ) : NEW_LINE INDENT max_num = arr [ i ] ; NEW_LINE DEDENT DEDENT res = 1 ; NEW_LINE x = 2 ; NEW_LINE while ( x <= max_num ) : NEW_LINE INDENT indexes = [ ] ; NEW_LINE for j in range ( n ) : NEW_LINE INDENT if ( arr [ j ] % x == 0 ) : NEW_LINE INDENT indexes . append ( j ) ; NEW_LINE DEDENT DEDENT if ( len ( indexes ) >= 2 ) : NEW_LINE INDENT for j in range ( len ( indexes ) ) : NEW_LINE INDENT arr [ indexes [ j ] ] = int ( arr [ indexes [ j ] ] / x ) ; NEW_LINE DEDENT res = res * x ; NEW_LINE DEDENT else : NEW_LINE INDENT x += 1 ; NEW_LINE DEDENT DEDENT for i in range ( n ) : NEW_LINE INDENT res = res * arr [ i ] ; NEW_LINE DEDENT return res ; NEW_LINE DEDENT arr = [ 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( LCM ( arr , n ) ) ; NEW_LINE
def maxConsecutiveOnes ( x ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( x != 0 ) : NEW_LINE INDENT x = ( x & ( x << 1 ) ) ; NEW_LINE count += 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def maxOnes ( arr , n ) : NEW_LINE INDENT ans = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT currMax = maxConsecutiveOnes ( arr [ i ] ) ; NEW_LINE ans = max ( ans , currMax ) ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 1 , 2 , 3 , 4 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( maxOnes ( arr , n ) ) ; NEW_LINE DEDENT
def countSegments ( a , n , x ) : NEW_LINE INDENT flag = False NEW_LINE count = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( a [ i ] > x ) : NEW_LINE INDENT flag = True NEW_LINE DEDENT else : NEW_LINE INDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT flag = False NEW_LINE DEDENT DEDENT if ( flag ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT a = [ 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 ] NEW_LINE n = len ( a ) NEW_LINE x = 13 NEW_LINE print ( countSegments ( a , n , x ) ) NEW_LINE DEDENT
def line ( x0 , y0 ) : NEW_LINE INDENT c = 2 * y0 * x0 NEW_LINE print ( y0 , " x " , " + " , x0 , " y = " , c ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT x0 = 4 NEW_LINE y0 = 3 NEW_LINE line ( x0 , y0 ) NEW_LINE DEDENT
def minDiff ( n , x , A ) : NEW_LINE INDENT mn = A [ 0 ] NEW_LINE mx = A [ 0 ] NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT mn = min ( mn , A [ i ] ) NEW_LINE mx = max ( mx , A [ i ] ) NEW_LINE DEDENT return max ( 0 , mx - mn - 2 * x ) NEW_LINE DEDENT n = 3 NEW_LINE x = 3 NEW_LINE A = [ 1 , 3 , 6 ] NEW_LINE print ( minDiff ( n , x , A ) ) NEW_LINE
def fact ( num ) : NEW_LINE INDENT fact = 1 ; NEW_LINE while ( num > 1 ) : NEW_LINE INDENT fact = fact * num ; NEW_LINE num = num - 1 ; NEW_LINE DEDENT return fact ; NEW_LINE DEDENT def catalan ( n ) : NEW_LINE INDENT return fact ( 2 * n ) // ( fact ( n ) * fact ( n + 1 ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 5 NEW_LINE arr = [ 1 , 2 , 3 , 4 , 5 ] NEW_LINE for k in range ( n ) : NEW_LINE INDENT s = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if arr [ i ] < arr [ k ] : NEW_LINE INDENT s += 1 NEW_LINE DEDENT DEDENT catalan_leftBST = catalan ( s ) NEW_LINE catalan_rightBST = catalan ( n - s - 1 ) NEW_LINE totalBST = catalan_rightBST * catalan_leftBST NEW_LINE print ( totalBST , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def nthPalindrome ( n , k ) : NEW_LINE INDENT if ( k & 1 ) : NEW_LINE INDENT temp = k // 2 NEW_LINE DEDENT else : NEW_LINE INDENT temp = k // 2 - 1 NEW_LINE DEDENT palindrome = 10 ** temp NEW_LINE palindrome = palindrome + n - 1 NEW_LINE print ( palindrome , end = " " ) NEW_LINE if ( k & 1 ) : NEW_LINE INDENT palindrome = palindrome // 10 NEW_LINE DEDENT while ( palindrome ) : NEW_LINE INDENT print ( palindrome % 10 , end = " " ) NEW_LINE palindrome = palindrome // 10 NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE k = 5 NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " ▁ digit ▁ = ▁ " , end = " ▁ " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE print ( ) NEW_LINE n = 10 NEW_LINE k = 6 NEW_LINE print ( n , " th ▁ palindrome ▁ of " , k , " digit ▁ = ▁ " , end = " ▁ " ) NEW_LINE nthPalindrome ( n , k ) NEW_LINE DEDENT
def getAvg ( x , n , sum ) : NEW_LINE INDENT sum = sum + x ; NEW_LINE return float ( sum ) / n ; NEW_LINE DEDENT def streamAvg ( arr , n ) : NEW_LINE INDENT avg = 0 ; NEW_LINE sum = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT avg = getAvg ( arr [ i ] , i + 1 , sum ) ; NEW_LINE sum = avg * ( i + 1 ) ; NEW_LINE print ( " Average ▁ of ▁ " , end = " " ) ; NEW_LINE print ( i + 1 , end = " " ) ; NEW_LINE print ( " ▁ numbers ▁ is ▁ " , end = " " ) ; NEW_LINE print ( avg ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 50 , 60 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE streamAvg ( arr , n ) ; NEW_LINE
def Permutations ( n , k ) : NEW_LINE INDENT ans = 1 NEW_LINE if k >= 2 : NEW_LINE INDENT ans += ( n ) * ( n - 1 ) // 2 NEW_LINE DEDENT if k >= 3 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * 2 // 6 ) NEW_LINE DEDENT if k >= 4 : NEW_LINE INDENT ans += ( ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 // 24 ) NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n , k = 5 , 2 NEW_LINE print ( Permutations ( n , k ) ) NEW_LINE DEDENT
import math NEW_LINE class Node : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT def push ( head_ref , new_data ) : NEW_LINE INDENT new_node = Node ( new_data ) NEW_LINE new_node . data = new_data NEW_LINE new_node . next = head_ref NEW_LINE head_ref = new_node NEW_LINE return head_ref NEW_LINE DEDENT def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , n + 1 , 6 ) : NEW_LINE INDENT if ( i * i < n + 2 and ( n % i == 0 or n % ( i + 2 ) == 0 ) ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def deleteNonPrimeNodes ( head_ref ) : NEW_LINE INDENT ptr = head_ref NEW_LINE while ( ptr != None and isPrime ( ptr . data ) != True ) : NEW_LINE INDENT temp = ptr NEW_LINE ptr = ptr . next NEW_LINE DEDENT head_ref = ptr NEW_LINE if ( ptr == None ) : NEW_LINE INDENT return None NEW_LINE DEDENT curr = ptr . next NEW_LINE while ( curr != None ) : NEW_LINE INDENT if ( isPrime ( curr . data ) != True ) : NEW_LINE INDENT ptr . next = curr . next NEW_LINE curr = ptr . next NEW_LINE DEDENT else : NEW_LINE INDENT ptr = curr NEW_LINE curr = curr . next NEW_LINE DEDENT return head_ref NEW_LINE DEDENT DEDENT def printList ( head ) : NEW_LINE INDENT while ( head != None ) : NEW_LINE INDENT print ( head . data , end = " ▁ " ) NEW_LINE head = head . next NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT head = None NEW_LINE head = push ( head , 17 ) NEW_LINE head = push ( head , 7 ) NEW_LINE head = push ( head , 6 ) NEW_LINE head = push ( head , 16 ) NEW_LINE head = push ( head , 15 ) NEW_LINE print ( " Original ▁ List : ▁ " ) NEW_LINE printList ( head ) NEW_LINE head = deleteNonPrimeNodes ( head ) NEW_LINE print ( " \n Modified ▁ List : ▁ " ) NEW_LINE printList ( head ) NEW_LINE DEDENT
def findMinLenStr ( str , k ) : NEW_LINE INDENT n = len ( str ) NEW_LINE st = 0 NEW_LINE end = 0 NEW_LINE cnt = [ 0 ] * 26 NEW_LINE distEle = 0 NEW_LINE currlen = 0 NEW_LINE minlen = n NEW_LINE startInd = - 1 NEW_LINE while ( end < n ) : NEW_LINE INDENT cnt [ ord ( str [ end ] ) - ord ( ' a ' ) ] += 1 NEW_LINE if ( cnt [ ord ( str [ end ] ) - ord ( ' a ' ) ] == 1 ) : NEW_LINE INDENT distEle += 1 NEW_LINE DEDENT if ( distEle > k ) : NEW_LINE INDENT while ( st < end and distEle > k ) : NEW_LINE INDENT if ( cnt [ ord ( str [ st ] ) - ord ( ' a ' ) ] == 1 ) : NEW_LINE INDENT distEle -= 1 NEW_LINE DEDENT cnt [ ord ( str [ st ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE st += 1 NEW_LINE DEDENT DEDENT if ( distEle == k ) : NEW_LINE INDENT while ( st < end and cnt [ ord ( str [ st ] ) - ord ( ' a ' ) ] > 1 ) : NEW_LINE INDENT cnt [ ord ( str [ st ] ) - ord ( ' a ' ) ] -= 1 NEW_LINE st += 1 NEW_LINE DEDENT currlen = end - st + 1 NEW_LINE if ( currlen < minlen ) : NEW_LINE INDENT minlen = currlen NEW_LINE startInd = st NEW_LINE DEDENT DEDENT end += 1 NEW_LINE DEDENT return str [ startInd : startInd + minlen ] NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str = " efecfefd " NEW_LINE k = 4 NEW_LINE print ( findMinLenStr ( str , k ) ) NEW_LINE DEDENT
import math NEW_LINE def longestSubarray ( arr , n ) : NEW_LINE INDENT i = d = 0 ; NEW_LINE HASH1 = [ [ 0 for x in range ( 10 ) ] for y in range ( 2 ) ] ; NEW_LINE currRow = 0 ; NEW_LINE maxLen = 1 ; NEW_LINE len1 = 0 ; NEW_LINE tmp = 0 ; NEW_LINE tmp = arr [ 0 ] ; NEW_LINE while ( tmp > 0 ) : NEW_LINE INDENT HASH1 [ 0 ] [ tmp % 10 ] = 1 ; NEW_LINE tmp = tmp // 10 ; NEW_LINE DEDENT currRow = 1 ; NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT tmp = arr [ i ] ; NEW_LINE for d in range ( 0 , 10 ) : NEW_LINE INDENT HASH1 [ currRow ] [ d ] = 0 ; NEW_LINE DEDENT while ( tmp > 0 ) : NEW_LINE INDENT HASH1 [ currRow ] [ tmp % 10 ] = 1 ; NEW_LINE tmp = tmp // 10 ; NEW_LINE DEDENT for d in range ( 0 , 10 ) : NEW_LINE INDENT if ( HASH1 [ currRow ] [ d ] and HASH1 [ 1 - currRow ] [ d ] ) : NEW_LINE INDENT len1 += 1 ; NEW_LINE break ; NEW_LINE DEDENT DEDENT if ( d == 10 ) : NEW_LINE INDENT len1 = 1 ; NEW_LINE DEDENT maxLen = max ( maxLen , len1 ) ; NEW_LINE currRow = 1 - currRow ; NEW_LINE DEDENT return maxLen ; NEW_LINE DEDENT arr = [ 11 , 22 , 33 , 44 , 54 , 56 , 63 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( longestSubarray ( arr , n ) ) ; NEW_LINE
def sumNatural ( n ) : NEW_LINE INDENT sum = ( n * ( n + 1 ) ) // 2 NEW_LINE return sum NEW_LINE DEDENT def suminRange ( l , r ) : NEW_LINE INDENT return sumNatural ( r ) - sumNatural ( l - 1 ) NEW_LINE DEDENT l = 2 ; r = 5 NEW_LINE print ( " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " , suminRange ( l , r ) ) NEW_LINE
def findIndex ( str ) : NEW_LINE INDENT l = len ( str ) NEW_LINE open = [ 0 ] * ( l + 1 ) NEW_LINE close = [ 0 ] * ( l + 1 ) NEW_LINE index = - 1 NEW_LINE open [ 0 ] = 0 NEW_LINE close [ l ] = 0 NEW_LINE if ( str [ 0 ] == ' ( ' ) : NEW_LINE INDENT open [ 1 ] = 1 NEW_LINE DEDENT if ( str [ l - 1 ] == ' ) ' ) : NEW_LINE INDENT close [ l - 1 ] = 1 NEW_LINE DEDENT for i in range ( 1 , l ) : NEW_LINE INDENT if ( str [ i ] == ' ( ' ) : NEW_LINE INDENT open [ i + 1 ] = open [ i ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT open [ i + 1 ] = open [ i ] NEW_LINE DEDENT DEDENT for i in range ( l - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( str [ i ] == ' ) ' ) : NEW_LINE INDENT close [ i ] = close [ i + 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT close [ i ] = close [ i + 1 ] NEW_LINE DEDENT DEDENT if ( open [ l ] == 0 ) : NEW_LINE INDENT return len NEW_LINE DEDENT if ( close [ 0 ] == 0 ) : NEW_LINE INDENT return 0 NEW_LINE DEDENT for i in range ( l + 1 ) : NEW_LINE INDENT if ( open [ i ] == close [ i ] ) : NEW_LINE INDENT index = i NEW_LINE DEDENT DEDENT return index NEW_LINE DEDENT str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " NEW_LINE print ( findIndex ( str ) ) NEW_LINE
def findLen ( A , n , k , ch ) : NEW_LINE INDENT maxlen = 1 NEW_LINE cnt = 0 NEW_LINE l = 0 NEW_LINE r = 0 NEW_LINE while r < n : NEW_LINE INDENT if A [ r ] != ch : NEW_LINE INDENT cnt += 1 NEW_LINE DEDENT while cnt > k : NEW_LINE INDENT if A [ l ] != ch : NEW_LINE INDENT cnt -= 1 NEW_LINE DEDENT l += 1 NEW_LINE DEDENT maxlen = max ( maxlen , r - l + 1 ) NEW_LINE r += 1 NEW_LINE DEDENT return maxlen NEW_LINE DEDENT def answer ( A , n , k ) : NEW_LINE INDENT maxlen = 1 NEW_LINE for i in range ( 26 ) : NEW_LINE INDENT maxlen = max ( maxlen , findLen ( A , n , k , chr ( i + ord ( ' A ' ) ) ) ) NEW_LINE maxlen = max ( maxlen , findLen ( A , n , k , chr ( i + ord ( ' a ' ) ) ) ) NEW_LINE DEDENT return maxlen NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 5 NEW_LINE k = 2 NEW_LINE A = " ABABA " NEW_LINE print ( " Maximum ▁ length ▁ = " , answer ( A , n , k ) ) NEW_LINE n = 6 NEW_LINE k = 4 NEW_LINE B = " HHHHHH " NEW_LINE print ( " Maximum ▁ length ▁ = " , answer ( B , n , k ) ) NEW_LINE DEDENT
def isTidy ( num ) : NEW_LINE INDENT prev = 10 NEW_LINE while ( num ) : NEW_LINE INDENT rem = num % 10 NEW_LINE num /= 10 NEW_LINE if rem > prev : NEW_LINE INDENT return False NEW_LINE DEDENT prev = rem NEW_LINE DEDENT return True NEW_LINE DEDENT num = 1556 NEW_LINE if isTidy ( num ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def isPowerOfTwo ( n ) : NEW_LINE INDENT return ( n and ( not ( n & ( n - 1 ) ) ) ) NEW_LINE DEDENT def isProthNumber ( n ) : NEW_LINE INDENT k = 1 NEW_LINE while ( k < ( n // k ) ) : NEW_LINE INDENT if ( n % k == 0 ) : NEW_LINE INDENT if ( isPowerOfTwo ( n // k ) ) : NEW_LINE INDENT return True NEW_LINE DEDENT DEDENT k = k + 2 NEW_LINE DEDENT return False NEW_LINE int n = 25 ; NEW_LINE DEDENT if ( isProthNumber ( n - 1 ) ) : NEW_LINE INDENT print ( " YES " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " NO " ) ; NEW_LINE DEDENT
def numberOfTriangles ( n ) : NEW_LINE INDENT ans = 2 * ( pow ( 3 , n ) ) - 1 ; NEW_LINE return ans ; NEW_LINE DEDENT n = 2 NEW_LINE print ( numberOfTriangles ( n ) ) NEW_LINE
def maximumNumberDistinctPrimeRange ( m , n ) : NEW_LINE INDENT factorCount = [ 0 ] * ( n + 1 ) NEW_LINE prime = [ False ] * ( n + 1 ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT factorCount [ i ] = 0 NEW_LINE prime [ i ] = True NEW_LINE DEDENT for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( prime [ i ] == True ) : NEW_LINE INDENT factorCount [ i ] = 1 NEW_LINE for j in range ( i * 2 , n + 1 , i ) : NEW_LINE INDENT factorCount [ j ] += 1 NEW_LINE prime [ j ] = False NEW_LINE DEDENT DEDENT DEDENT max = factorCount [ m ] NEW_LINE num = m NEW_LINE for i in range ( m , n + 1 ) : NEW_LINE INDENT if ( factorCount [ i ] > max ) : NEW_LINE INDENT max = factorCount [ i ] NEW_LINE num = i NEW_LINE DEDENT DEDENT return num NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT m = 4 NEW_LINE n = 6 NEW_LINE print ( maximumNumberDistinctPrimeRange ( m , n ) ) NEW_LINE DEDENT
def findEvenPair ( A , N ) : NEW_LINE INDENT count = 0 NEW_LINE for i in range ( 0 , N ) : NEW_LINE INDENT if ( A [ i ] % 2 != 0 ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT DEDENT totalPairs = ( N * ( N - 1 ) / 2 ) NEW_LINE oddEvenPairs = count * ( N - count ) NEW_LINE return ( int ) ( totalPairs - oddEvenPairs ) NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT a = [ 5 , 4 , 7 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE print ( findEvenPair ( a , n ) ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def wordReverse ( str ) : NEW_LINE INDENT i = len ( str ) - 1 NEW_LINE start = end = i + 1 NEW_LINE result = ' ' NEW_LINE while i >= 0 : NEW_LINE INDENT if str [ i ] == ' ▁ ' : NEW_LINE INDENT start = i + 1 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT result += ' ▁ ' NEW_LINE end = i NEW_LINE DEDENT i -= 1 NEW_LINE DEDENT start = 0 NEW_LINE while start != end : NEW_LINE INDENT result += str [ start ] NEW_LINE start += 1 NEW_LINE DEDENT return result NEW_LINE DEDENT str = ' I ▁ AM ▁ A ▁ GEEK ' NEW_LINE print ( wordReverse ( str ) ) NEW_LINE
def validate ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT temp = n ; NEW_LINE count = 0 ; NEW_LINE while ( temp ) : NEW_LINE INDENT if ( temp % 10 == i ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT if ( count > i ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT temp //= 10 ; NEW_LINE DEDENT DEDENT return 1 ; NEW_LINE DEDENT n = 1552793 ; NEW_LINE geek = " True " if validate ( n ) else " False " ; NEW_LINE print ( geek ) ; NEW_LINE
def towerOfHanoi ( n , from_rod , to_rod , aux_rod1 , aux_rod2 ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( n == 1 ) : NEW_LINE INDENT print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " c ▁ to ▁ rod " , to_rod ) NEW_LINE return NEW_LINE DEDENT towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) NEW_LINE print ( " Move ▁ disk " , n - 1 , " from ▁ rod " , from_rod , " c ▁ to ▁ rod " , aux_rod2 ) NEW_LINE print ( " Move ▁ disk " , n , " from ▁ rod " , from_rod , " c ▁ to ▁ rod " , to_rod ) NEW_LINE print ( " Move ▁ disk " , n - 1 , " from ▁ rod " , aux_rod2 , " c ▁ to ▁ rod " , to_rod ) NEW_LINE towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) NEW_LINE DEDENT n = 4 NEW_LINE towerOfHanoi ( n , ' A ' , ' D ' , ' B ' , ' C ' ) NEW_LINE
def findMajority ( arr , size ) : NEW_LINE INDENT m = { } NEW_LINE for i in range ( size ) : NEW_LINE INDENT if arr [ i ] in m : NEW_LINE INDENT m [ arr [ i ] ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT m [ arr [ i ] ] = 1 NEW_LINE DEDENT DEDENT count = 0 NEW_LINE for key in m : NEW_LINE INDENT if m [ key ] > size / 2 : NEW_LINE INDENT count = 1 NEW_LINE print ( " Majority ▁ found ▁ : - " , key ) NEW_LINE break NEW_LINE DEDENT DEDENT if ( count == 0 ) : NEW_LINE INDENT print ( " No ▁ Majority ▁ element " ) NEW_LINE DEDENT DEDENT arr = [ 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 ] NEW_LINE n = len ( arr ) NEW_LINE findMajority ( arr , n ) NEW_LINE
MAX_K = 15 NEW_LINE fac = [ 1 for i in range ( MAX_K ) ] NEW_LINE def factorial ( k ) : NEW_LINE INDENT fac [ 0 ] = 1 NEW_LINE for i in range ( 1 , k + 2 ) : NEW_LINE INDENT fac [ i ] = ( i * fac [ i - 1 ] ) NEW_LINE DEDENT DEDENT def bin ( a , b ) : NEW_LINE INDENT ans = fac [ a ] // ( fac [ a - b ] * fac [ b ] ) NEW_LINE return ans NEW_LINE DEDENT def sumofn ( n , k ) : NEW_LINE INDENT p = 0 NEW_LINE num1 , temp = 1 , 1 NEW_LINE arr = [ 1 for i in range ( 1000 ) ] NEW_LINE for j in range ( 1 , k + 1 ) : NEW_LINE INDENT if j == 1 : NEW_LINE INDENT num1 = ( n * ( n + 1 ) ) // 2 NEW_LINE arr [ p ] = num1 NEW_LINE p += 1 NEW_LINE DEDENT else : NEW_LINE INDENT temp = pow ( n + 1 , j + 1 ) - 1 - n NEW_LINE for s in range ( 1 , j ) : NEW_LINE INDENT temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) NEW_LINE DEDENT temp = temp // ( j + 1 ) NEW_LINE arr [ p ] = temp NEW_LINE p += 1 NEW_LINE DEDENT DEDENT temp = arr [ p - 1 ] NEW_LINE return temp NEW_LINE DEDENT n , k = 5 , 2 NEW_LINE factorial ( k ) NEW_LINE print ( sumofn ( n , k ) ) NEW_LINE
def countPattern ( n , pat ) : NEW_LINE INDENT pattern_int = 0 NEW_LINE power_two = 1 NEW_LINE all_ones = 0 NEW_LINE i = len ( pat ) - 1 NEW_LINE while ( i >= 0 ) : NEW_LINE INDENT current_bit = ord ( pat [ i ] ) - ord ( '0' ) NEW_LINE pattern_int += ( power_two * current_bit ) NEW_LINE all_ones = all_ones + power_two NEW_LINE power_two = power_two * 2 NEW_LINE i -= 1 NEW_LINE DEDENT count = 0 NEW_LINE while ( n != 0 and n >= pattern_int ) : NEW_LINE INDENT if ( ( n & all_ones ) == pattern_int ) : NEW_LINE INDENT count += 1 NEW_LINE DEDENT n = n >> 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 500 NEW_LINE pat = "10" NEW_LINE print ( countPattern ( n , pat ) ) NEW_LINE DEDENT
def gcd ( a , b ) : NEW_LINE INDENT if ( b == 0 ) : NEW_LINE INDENT return a NEW_LINE DEDENT else : NEW_LINE INDENT return gcd ( b , a % b ) NEW_LINE DEDENT DEDENT def isDivisible ( x , y ) : NEW_LINE INDENT if ( y == 1 ) : NEW_LINE INDENT return 1 NEW_LINE DEDENT z = gcd ( x , y ) ; NEW_LINE if ( z == 1 ) : NEW_LINE INDENT return false ; NEW_LINE DEDENT return isDivisible ( x , y / z ) ; NEW_LINE DEDENT x = 18 NEW_LINE y = 12 NEW_LINE if ( isDivisible ( x , y ) ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT
def LISusingLCS ( seq ) : NEW_LINE INDENT n = len ( seq ) NEW_LINE L = [ [ 0 for i in range ( n + 1 ) ] for i in range ( n + 1 ) ] NEW_LINE sortedseq = sorted ( seq ) NEW_LINE for i in range ( n + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if ( i == 0 or j == 0 ) : NEW_LINE INDENT L [ i ] [ j ] = 0 NEW_LINE DEDENT elif ( seq [ i - 1 ] == sortedseq [ j - 1 ] ) : NEW_LINE INDENT L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 NEW_LINE DEDENT else : NEW_LINE INDENT L [ i ] [ j ] = max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) NEW_LINE DEDENT DEDENT DEDENT return L [ n ] [ n ] NEW_LINE DEDENT sequence = [ 12 , 34 , 1 , 5 , 40 , 80 ] NEW_LINE print ( LISusingLCS ( sequence ) ) NEW_LINE
def findSmallest ( s ) : NEW_LINE INDENT length = len ( s ) ; NEW_LINE loccur = [ - 1 ] * 26 ; NEW_LINE for i in range ( length - 1 , - 1 , - 1 ) : NEW_LINE INDENT chI = ord ( s [ i ] ) - ord ( ' a ' ) ; NEW_LINE if ( loccur [ chI ] == - 1 ) : NEW_LINE INDENT loccur [ chI ] = i ; NEW_LINE DEDENT DEDENT sorted_s = s ; NEW_LINE sorted_s . sort ( ) ; NEW_LINE for i in range ( length ) : NEW_LINE INDENT if ( s [ i ] != sorted_s [ i ] ) : NEW_LINE INDENT chI = ord ( sorted_s [ i ] ) - ord ( ' a ' ) ; NEW_LINE last_occ = loccur [ chI ] ; NEW_LINE s [ i ] , s [ last_occ ] = s [ last_occ ] , s [ i ] NEW_LINE break ; NEW_LINE DEDENT DEDENT return " " . join ( s ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " geeks " ; NEW_LINE print ( findSmallest ( list ( s ) ) ) ; NEW_LINE DEDENT
def getTotalNumberOfSequences ( m , n ) : NEW_LINE INDENT T = [ [ 0 for i in range ( n + 1 ) ] for i in range ( m + 1 ) ] NEW_LINE for i in range ( m + 1 ) : NEW_LINE INDENT for j in range ( n + 1 ) : NEW_LINE INDENT if i == 0 or j == 0 : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif i < j : NEW_LINE INDENT T [ i ] [ j ] = 0 NEW_LINE DEDENT elif j == 1 : NEW_LINE INDENT T [ i ] [ j ] = i NEW_LINE DEDENT else : NEW_LINE INDENT T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i // 2 ] [ j - 1 ] NEW_LINE DEDENT DEDENT DEDENT return T [ m ] [ n ] NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT m = 10 NEW_LINE n = 4 NEW_LINE print ( ' Total ▁ number ▁ of ▁ possible ▁ sequences ▁ ' , getTotalNumberOfSequences ( m , n ) ) NEW_LINE DEDENT
import math NEW_LINE def area ( x1 , y1 , z1 , x2 , y2 , z2 ) : NEW_LINE INDENT area = math . sqrt ( ( y1 * z2 - y2 * z1 ) ** 2 + ( x1 * z2 - x2 * z1 ) ** 2 + ( x1 * y2 - x2 * y1 ) ** 2 ) NEW_LINE area = area / 2 NEW_LINE return area NEW_LINE DEDENT def main ( ) : NEW_LINE INDENT x1 = - 2 NEW_LINE y1 = 0 NEW_LINE z1 = - 5 NEW_LINE x2 = 1 NEW_LINE y2 = - 2 NEW_LINE z2 = - 1 NEW_LINE a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) NEW_LINE print ( " Area ▁ = ▁ " , a ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT main ( ) NEW_LINE DEDENT
def weightedMean ( X , W , n ) : NEW_LINE INDENT sum = 0 NEW_LINE numWeight = 0 NEW_LINE i = 0 NEW_LINE while i < n : NEW_LINE INDENT numWeight = numWeight + X [ i ] * W [ i ] NEW_LINE sum = sum + W [ i ] NEW_LINE i = i + 1 NEW_LINE DEDENT return ( float ) ( numWeight / sum ) NEW_LINE DEDENT X = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE W = [ 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 ] NEW_LINE n = len ( X ) NEW_LINE m = len ( W ) NEW_LINE if ( n == m ) : NEW_LINE INDENT print weightedMean ( X , W , n ) NEW_LINE DEDENT else : NEW_LINE INDENT print " - 1" NEW_LINE DEDENT
def Log2n ( n ) : NEW_LINE INDENT return ( 1 + Log2n ( n / 2 ) ) if ( n > 1 ) else 0 ; NEW_LINE DEDENT def isPowerOfd ( n , d ) : NEW_LINE INDENT count = 0 ; NEW_LINE if ( n and ( n & ( n - 1 ) ) == 0 ) : NEW_LINE INDENT while ( n > 1 ) : NEW_LINE INDENT n >>= 1 ; NEW_LINE count += 1 ; NEW_LINE DEDENT return ( count % ( Log2n ( d ) ) == 0 ) ; NEW_LINE DEDENT return False ; NEW_LINE DEDENT n = 64 ; NEW_LINE d = 8 ; NEW_LINE if ( isPowerOfd ( n , d ) ) : NEW_LINE INDENT print ( n , " is ▁ a ▁ power ▁ of " , d ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( n , " is ▁ not ▁ a ▁ power ▁ of " , d ) ; NEW_LINE DEDENT
def printRepeating ( arr , n ) : NEW_LINE INDENT for i in range ( 0 , n ) : NEW_LINE INDENT index = arr [ i ] % n NEW_LINE arr [ index ] += n NEW_LINE DEDENT for i in range ( 0 , n ) : NEW_LINE INDENT if ( arr [ i ] / n ) > 1 : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT DEDENT arr = [ 1 , 6 , 3 , 1 , 3 , 6 , 6 ] NEW_LINE arr_size = len ( arr ) NEW_LINE print ( " The ▁ repeating ▁ elements ▁ are : " ) NEW_LINE printRepeating ( arr , arr_size ) NEW_LINE
def countFreq ( a , n ) : NEW_LINE INDENT hm = { } NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT hm [ a [ i ] ] = hm . get ( a [ i ] , 0 ) + 1 NEW_LINE DEDENT st = set ( ) NEW_LINE for x in hm : NEW_LINE INDENT st . add ( ( x , hm [ x ] ) ) NEW_LINE DEDENT cumul = 0 NEW_LINE for x in sorted ( st ) : NEW_LINE INDENT cumul += x [ 1 ] NEW_LINE print ( x [ 0 ] , cumul ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 1 , 3 , 2 , 4 , 2 , 1 ] NEW_LINE n = len ( a ) NEW_LINE countFreq ( a , n ) NEW_LINE DEDENT
def checkIfPowerIsolated ( num ) : NEW_LINE INDENT input1 = num ; NEW_LINE count = 0 ; NEW_LINE factor = [ 0 ] * ( num + 1 ) ; NEW_LINE if ( num % 2 == 0 ) : NEW_LINE INDENT while ( num % 2 == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= 2 ; NEW_LINE DEDENT factor [ 2 ] = count ; NEW_LINE DEDENT i = 3 ; NEW_LINE while ( i * i <= num ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( num % i == 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE num //= i ; NEW_LINE DEDENT if ( count > 0 ) : NEW_LINE INDENT factor [ i ] = count ; NEW_LINE DEDENT i += 2 ; NEW_LINE DEDENT if ( num > 1 ) : NEW_LINE INDENT factor [ num ] = 1 ; NEW_LINE DEDENT product = 1 ; NEW_LINE for i in range ( 0 , len ( factor ) ) : NEW_LINE INDENT if ( factor [ i ] > 0 ) : NEW_LINE INDENT product = product * factor [ i ] * i ; NEW_LINE DEDENT DEDENT if ( product == input1 ) : NEW_LINE INDENT print ( " Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT else : NEW_LINE INDENT print ( " Not ▁ a ▁ Power - isolated ▁ Integer " ) ; NEW_LINE DEDENT DEDENT checkIfPowerIsolated ( 12 ) ; NEW_LINE checkIfPowerIsolated ( 18 ) ; NEW_LINE checkIfPowerIsolated ( 35 ) ; NEW_LINE
def maxAmount ( M , N , seats ) : NEW_LINE INDENT q = [ ] NEW_LINE for i in range ( M ) : NEW_LINE INDENT q . append ( seats [ i ] ) NEW_LINE DEDENT ticketSold = 0 NEW_LINE ans = 0 NEW_LINE q . sort ( reverse = True ) NEW_LINE while ( ticketSold < N and q [ 0 ] > 0 ) : NEW_LINE INDENT ans = ans + q [ 0 ] NEW_LINE temp = q [ 0 ] NEW_LINE q = q [ 1 : ] NEW_LINE q . append ( temp - 1 ) NEW_LINE q . sort ( reverse = True ) NEW_LINE ticketSold += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT seats = [ 1 , 2 , 4 ] NEW_LINE M = len ( seats ) NEW_LINE N = 3 NEW_LINE print ( maxAmount ( N , M , seats ) ) NEW_LINE DEDENT
def countPairs ( arr , n , k ) : NEW_LINE INDENT cnt = 0 ; NEW_LINE for i in range ( n - 1 ) : NEW_LINE INDENT for j in range ( i + 1 , n ) : NEW_LINE INDENT if ( ( arr [ i ] - arr [ j ] + k ) % k == 0 ) : NEW_LINE INDENT cnt += 1 ; NEW_LINE DEDENT DEDENT DEDENT print ( cnt ) ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 3 , 3 , 3 ] ; NEW_LINE k = 3 ; NEW_LINE n = len ( arr ) ; NEW_LINE countPairs ( arr , n , k ) ; NEW_LINE DEDENT
def canFormTeam ( n , m ) : NEW_LINE INDENT if ( n >= 1 and m >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( m >= 1 and n >= 2 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def maxTeams ( n , m ) : NEW_LINE INDENT count = 0 NEW_LINE while ( canFormTeam ( n , m ) ) : NEW_LINE INDENT if ( n > m ) : NEW_LINE INDENT n -= 2 NEW_LINE m -= 1 NEW_LINE DEDENT else : NEW_LINE INDENT m -= 2 NEW_LINE n -= 1 NEW_LINE DEDENT count += 1 NEW_LINE DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 4 NEW_LINE m = 5 NEW_LINE print ( maxTeams ( n , m ) ) NEW_LINE DEDENT
def printUncommon ( str1 , str2 ) : NEW_LINE INDENT a1 = 0 ; a2 = 0 ; NEW_LINE for i in range ( len ( str1 ) ) : NEW_LINE INDENT ch = ord ( str1 [ i ] ) - ord ( ' a ' ) ; NEW_LINE a1 = a1 | ( 1 << ch ) ; NEW_LINE DEDENT for i in range ( len ( str2 ) ) : NEW_LINE INDENT ch = ord ( str2 [ i ] ) - ord ( ' a ' ) ; NEW_LINE a2 = a2 | ( 1 << ch ) ; NEW_LINE DEDENT ans = a1 ^ a2 ; NEW_LINE i = 0 ; NEW_LINE while ( i < 26 ) : NEW_LINE INDENT if ( ans % 2 == 1 ) : NEW_LINE INDENT print ( chr ( ord ( ' a ' ) + i ) , end = " " ) ; NEW_LINE DEDENT ans = ans // 2 ; NEW_LINE i += 1 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT str1 = " geeksforgeeks " ; NEW_LINE str2 = " geeksquiz " ; NEW_LINE printUncommon ( str1 , str2 ) ; NEW_LINE DEDENT
class Node : NEW_LINE INDENT def __init__ ( self , data = 0 ) : NEW_LINE INDENT self . data = data NEW_LINE self . next = None NEW_LINE DEDENT DEDENT class treeNode : NEW_LINE INDENT def __init__ ( self , data ) : NEW_LINE INDENT self . data = data NEW_LINE self . left = None NEW_LINE self . right = None NEW_LINE DEDENT DEDENT def print_ ( head ) : NEW_LINE INDENT if ( head == None ) : NEW_LINE INDENT return NEW_LINE DEDENT temp = head NEW_LINE while ( temp != None ) : NEW_LINE INDENT print ( temp . data , end = " ▁ " ) NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT def sortedList ( head , root ) : NEW_LINE INDENT if ( root == None ) : NEW_LINE INDENT return head NEW_LINE DEDENT head = sortedList ( head , root . left ) NEW_LINE newNode = Node ( root . data ) NEW_LINE temp = head NEW_LINE prev = None NEW_LINE if ( temp == None ) : NEW_LINE INDENT head = newNode NEW_LINE DEDENT else : NEW_LINE INDENT while ( temp != None ) : NEW_LINE INDENT if ( temp . data > root . data ) : NEW_LINE INDENT break NEW_LINE DEDENT else : NEW_LINE INDENT prev = temp NEW_LINE temp = temp . next NEW_LINE DEDENT DEDENT if ( temp == None ) : NEW_LINE INDENT prev . next = newNode NEW_LINE DEDENT else : NEW_LINE INDENT if ( prev == None ) : NEW_LINE INDENT newNode . next = temp NEW_LINE head = newNode NEW_LINE DEDENT else : NEW_LINE INDENT newNode . next = temp NEW_LINE prev . next = newNode NEW_LINE DEDENT DEDENT DEDENT head = sortedList ( head , root . right ) NEW_LINE return head NEW_LINE DEDENT root = treeNode ( 10 ) NEW_LINE root . left = treeNode ( 15 ) NEW_LINE root . right = treeNode ( 2 ) NEW_LINE root . left . left = treeNode ( 1 ) NEW_LINE root . left . right = treeNode ( 5 ) NEW_LINE head = sortedList ( None , root ) NEW_LINE print_ ( head ) NEW_LINE
import math NEW_LINE def longDivision ( number , divisor ) : NEW_LINE INDENT ans = " " ; NEW_LINE idx = 0 ; NEW_LINE temp = ord ( number [ idx ] ) - ord ( '0' ) ; NEW_LINE while ( temp < divisor ) : NEW_LINE INDENT temp = ( temp * 10 + ord ( number [ idx + 1 ] ) - ord ( '0' ) ) ; NEW_LINE idx += 1 ; NEW_LINE DEDENT idx += 1 ; NEW_LINE while ( ( len ( number ) ) > idx ) : NEW_LINE INDENT ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) ; NEW_LINE temp = ( ( temp % divisor ) * 10 + ord ( number [ idx ] ) - ord ( '0' ) ) ; NEW_LINE idx += 1 ; NEW_LINE DEDENT ans += chr ( math . floor ( temp // divisor ) + ord ( '0' ) ) ; NEW_LINE if ( len ( ans ) == 0 ) : NEW_LINE INDENT return "0" ; NEW_LINE DEDENT return ans ; NEW_LINE DEDENT number = "1248163264128256512" ; NEW_LINE divisor = 125 ; NEW_LINE print ( longDivision ( number , divisor ) ) ; NEW_LINE
def powerOfTwo ( n ) : NEW_LINE INDENT return ( not ( n & n - 1 ) ) NEW_LINE DEDENT def onlyFirstAndLastAreSet ( n ) : NEW_LINE INDENT if ( n == 1 ) : NEW_LINE INDENT return True NEW_LINE DEDENT return powerOfTwo ( n - 1 ) NEW_LINE DEDENT n = 9 NEW_LINE if ( onlyFirstAndLastAreSet ( n ) ) : NEW_LINE INDENT print ( ' Yes ' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( ' No ' ) NEW_LINE DEDENT
def countUnmarked ( N ) : NEW_LINE INDENT if ( N % 2 == 0 ) : NEW_LINE INDENT return N / 2 ; NEW_LINE DEDENT else : NEW_LINE INDENT return N / 2 + 1 ; NEW_LINE DEDENT DEDENT N = 4 ; NEW_LINE print ( " Number ▁ of ▁ unmarked ▁ elements : " , int ( countUnmarked ( N ) ) ) ; NEW_LINE
from bisect import bisect_left NEW_LINE def printMissing ( arr , n , low , high ) : NEW_LINE INDENT arr . sort ( ) NEW_LINE ptr = bisect_left ( arr , low ) NEW_LINE index = ptr NEW_LINE i = index NEW_LINE x = low NEW_LINE while ( i < n and x <= high ) : NEW_LINE INDENT if ( arr [ i ] != x ) : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE DEDENT else : NEW_LINE INDENT i = i + 1 NEW_LINE DEDENT x = x + 1 NEW_LINE DEDENT while ( x <= high ) : NEW_LINE INDENT print ( x , end = " ▁ " ) NEW_LINE x = x + 1 NEW_LINE DEDENT DEDENT arr = [ 1 , 3 , 5 , 4 ] NEW_LINE n = len ( arr ) NEW_LINE low = 1 NEW_LINE high = 10 NEW_LINE printMissing ( arr , n , low , high ) ; NEW_LINE
def findMaxAverage ( arr , n , k ) : NEW_LINE INDENT if k > n : NEW_LINE INDENT return - 1 NEW_LINE DEDENT csum = [ 0 ] * n NEW_LINE csum [ 0 ] = arr [ 0 ] NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT csum [ i ] = csum [ i - 1 ] + arr [ i ] ; NEW_LINE DEDENT max_sum = csum [ k - 1 ] NEW_LINE max_end = k - 1 NEW_LINE for i in range ( k , n ) : NEW_LINE INDENT curr_sum = csum [ i ] - csum [ i - k ] NEW_LINE if curr_sum > max_sum : NEW_LINE INDENT max_sum = curr_sum NEW_LINE max_end = i NEW_LINE DEDENT DEDENT return max_end - k + 1 NEW_LINE DEDENT arr = [ 1 , 12 , - 5 , - 6 , 50 , 3 ] NEW_LINE k = 4 NEW_LINE n = len ( arr ) NEW_LINE print ( " The ▁ maximum ▁ average ▁ subarray ▁ of ▁ length " , k , " begins ▁ at ▁ index " , findMaxAverage ( arr , n , k ) ) NEW_LINE
import math as mt NEW_LINE def findSum ( arr , N ) : NEW_LINE INDENT mp = dict ( ) NEW_LINE for i in arr : NEW_LINE INDENT if i in mp . keys ( ) : NEW_LINE INDENT mp [ i ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT mp [ i ] = 1 NEW_LINE DEDENT DEDENT minFreq = 10 ** 9 NEW_LINE for itr in mp : NEW_LINE INDENT if mp [ itr ] < minFreq : NEW_LINE INDENT minFreq = mp [ itr ] NEW_LINE DEDENT DEDENT Sum = 0 NEW_LINE for itr in mp : NEW_LINE INDENT if mp [ itr ] == minFreq : NEW_LINE INDENT Sum += itr * mp [ itr ] NEW_LINE DEDENT DEDENT return Sum NEW_LINE DEDENT arr = [ 10 , 20 , 30 , 40 , 40 ] NEW_LINE N = len ( arr ) NEW_LINE print ( findSum ( arr , N ) ) NEW_LINE
def fibWord ( n ) : NEW_LINE INDENT Sn_1 = "0" NEW_LINE Sn = "01" NEW_LINE tmp = " " NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT tmp = Sn NEW_LINE Sn += Sn_1 NEW_LINE Sn_1 = tmp NEW_LINE DEDENT return Sn NEW_LINE DEDENT n = 6 NEW_LINE print ( fibWord ( n ) ) NEW_LINE
def gen ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 0 NEW_LINE DEDENT elif n == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT elif n % 2 == 0 : NEW_LINE INDENT return 4 * gen ( n // 2 ) NEW_LINE DEDENT elif n % 2 == 1 : NEW_LINE INDENT return 4 * gen ( n // 2 ) + 1 NEW_LINE DEDENT DEDENT def moserDeBruijn ( n ) : NEW_LINE INDENT for i in range ( n ) : NEW_LINE INDENT print ( gen ( i ) , end = " ▁ " ) NEW_LINE DEDENT DEDENT n = 15 NEW_LINE print ( " First " , n , " terms ▁ of ▁ " , " Moser - de ▁ Brujn ▁ Sequence : " ) NEW_LINE moserDeBruijn ( n ) NEW_LINE
from math import gcd NEW_LINE def MinDeletion ( a , n ) : NEW_LINE INDENT __gcd = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT __gcd = gcd ( __gcd , a [ i ] ) ; NEW_LINE DEDENT if ( __gcd > 1 ) : NEW_LINE INDENT return - 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT return 0 ; NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 3 , 6 , 12 , 81 , 9 ] ; NEW_LINE n = len ( a ) NEW_LINE print ( MinDeletion ( a , n ) ) ; NEW_LINE DEDENT
import math NEW_LINE def isPrime ( n ) : NEW_LINE INDENT if ( n <= 1 ) : NEW_LINE INDENT return False NEW_LINE DEDENT if ( n <= 3 ) : NEW_LINE INDENT return True NEW_LINE DEDENT if ( n % 2 == 0 or n % 3 == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT for i in range ( 5 , int ( math . sqrt ( n ) + 1 ) , 6 ) : NEW_LINE INDENT if ( n % i == 0 or n % ( i + 2 ) == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT def nextPrime ( N ) : NEW_LINE INDENT if ( N <= 1 ) : NEW_LINE INDENT return 2 NEW_LINE DEDENT prime = N NEW_LINE found = False NEW_LINE while ( not found ) : NEW_LINE INDENT prime = prime + 1 NEW_LINE if ( isPrime ( prime ) == True ) : NEW_LINE INDENT found = True NEW_LINE DEDENT DEDENT return prime NEW_LINE DEDENT N = 3 NEW_LINE print ( nextPrime ( N ) ) NEW_LINE
st = set ( ) NEW_LINE def generateNumbers ( n , num , a , b ) : NEW_LINE INDENT if ( num > 0 and num < n ) : NEW_LINE INDENT st . add ( num ) NEW_LINE DEDENT if ( num >= n ) : NEW_LINE INDENT return NEW_LINE DEDENT if ( num * 10 + a > num ) : NEW_LINE INDENT generateNumbers ( n , num * 10 + a , a , b ) NEW_LINE DEDENT generateNumbers ( n , num * 10 + b , a , b ) NEW_LINE DEDENT def printNumbers ( n ) : NEW_LINE INDENT for i in range ( 10 ) : NEW_LINE INDENT for j in range ( i + 1 , 10 , 1 ) : NEW_LINE INDENT generateNumbers ( n , 0 , i , j ) NEW_LINE DEDENT DEDENT print ( " The ▁ numbers ▁ are : " , end = " ▁ " ) NEW_LINE l = list ( st ) NEW_LINE for i in l : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 12 NEW_LINE printNumbers ( n ) NEW_LINE DEDENT
from math import sqrt NEW_LINE def checkPerfectSquare ( n ) : NEW_LINE INDENT d = sqrt ( n ) NEW_LINE if d * d == n : NEW_LINE INDENT return True NEW_LINE DEDENT return False NEW_LINE DEDENT def largestPerfectSquareNumber ( a , n ) : NEW_LINE INDENT maxi = - 1 NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( checkPerfectSquare ( a [ i ] ) ) : NEW_LINE INDENT maxi = max ( a [ i ] , maxi ) NEW_LINE DEDENT DEDENT return maxi NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT a = [ 16 , 20 , 25 , 2 , 3 , 10 ] NEW_LINE n = len ( a ) NEW_LINE print ( largestPerfectSquareNumber ( a , n ) ) NEW_LINE DEDENT
def isVowel ( c ) : NEW_LINE INDENT return ( c == ' a ' or c == ' e ' or c == ' i ' or c == ' o ' or c == ' u ' ) ; NEW_LINE DEDENT def countSubstringsUtil ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE mp = dict . fromkeys ( s , 0 ) ; NEW_LINE n = len ( s ) ; NEW_LINE start = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT mp [ s [ i ] ] += 1 ; NEW_LINE while ( mp [ ' a ' ] > 0 and mp [ ' e ' ] > 0 and mp [ ' i ' ] > 0 and mp [ ' o ' ] > 0 and mp [ ' u ' ] > 0 ) : NEW_LINE INDENT count += n - i ; NEW_LINE mp [ s [ start ] ] -= 1 ; NEW_LINE start += 1 ; NEW_LINE DEDENT DEDENT return count ; NEW_LINE DEDENT def countSubstrings ( s ) : NEW_LINE INDENT count = 0 ; NEW_LINE temp = " " ; NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT if ( isVowel ( s [ i ] ) ) : NEW_LINE INDENT temp += s [ i ] ; NEW_LINE DEDENT else : NEW_LINE INDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT temp = " " ; NEW_LINE DEDENT DEDENT if ( len ( temp ) > 0 ) : NEW_LINE INDENT count += countSubstringsUtil ( temp ) ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " aeouisddaaeeiouua " ; NEW_LINE print ( countSubstrings ( s ) ) ; NEW_LINE DEDENT
import sys NEW_LINE def findMaxValue ( ) : NEW_LINE INDENT res = 2 ; NEW_LINE fact = 2 ; NEW_LINE while ( True ) : NEW_LINE INDENT if ( fact < 0 or fact > sys . maxsize ) : NEW_LINE INDENT break ; NEW_LINE DEDENT res += 1 ; NEW_LINE fact = fact * res ; NEW_LINE DEDENT return res - 1 ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT print ( " Maximum ▁ value ▁ of ▁ integer : " , findMaxValue ( ) ) ; NEW_LINE DEDENT
M = 20 NEW_LINE dp = [ ] NEW_LINE d , K = None , None NEW_LINE def count ( pos , cnt , tight , nonz , num : list ) : NEW_LINE INDENT if pos == len ( num ) : NEW_LINE INDENT if cnt == K : NEW_LINE INDENT return 1 NEW_LINE DEDENT return 0 NEW_LINE DEDENT if dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 : NEW_LINE INDENT return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT ans = 0 NEW_LINE limit = 9 if tight else num [ pos ] NEW_LINE for dig in range ( limit + 1 ) : NEW_LINE INDENT currCnt = cnt NEW_LINE if dig == d : NEW_LINE INDENT if d != 0 or not d and nonz : NEW_LINE INDENT currCnt += 1 NEW_LINE DEDENT DEDENT currTight = tight NEW_LINE if dig < num [ pos ] : NEW_LINE INDENT currTight = 1 NEW_LINE DEDENT ans += count ( pos + 1 , currCnt , currTight , ( nonz or dig != 0 ) , num ) NEW_LINE DEDENT dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans NEW_LINE return dp [ pos ] [ cnt ] [ tight ] [ nonz ] NEW_LINE DEDENT def solve ( x ) : NEW_LINE INDENT global dp , K , d NEW_LINE num = [ ] NEW_LINE while x : NEW_LINE INDENT num . append ( x % 10 ) NEW_LINE x //= 10 NEW_LINE DEDENT num . reverse ( ) NEW_LINE dp = [ [ [ [ - 1 , - 1 ] for i in range ( 2 ) ] for j in range ( M ) ] for k in range ( M ) ] NEW_LINE return count ( 0 , 0 , 0 , 0 , num ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT L = 11 NEW_LINE R = 100 NEW_LINE d = 2 NEW_LINE K = 1 NEW_LINE print ( solve ( R ) - solve ( L - 1 ) ) NEW_LINE DEDENT
def getMaxLength ( arr , n ) : NEW_LINE INDENT start = 0 NEW_LINE preCnt = 0 NEW_LINE while ( start < n and arr [ start ] == 1 ) : NEW_LINE INDENT preCnt = preCnt + 1 NEW_LINE start = start + 1 NEW_LINE DEDENT end = n - 1 NEW_LINE suffCnt = 0 NEW_LINE while ( end >= 0 and arr [ end ] == 1 ) : NEW_LINE INDENT suffCnt = suffCnt + 1 NEW_LINE end = end - 1 NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT return n NEW_LINE DEDENT midCnt = 0 NEW_LINE i = start NEW_LINE result = 0 NEW_LINE while ( i <= end ) : NEW_LINE INDENT if ( arr [ i ] == 1 ) : NEW_LINE INDENT midCnt = midCnt + 1 NEW_LINE result = max ( result , midCnt ) NEW_LINE DEDENT else : NEW_LINE INDENT midCnt = 0 NEW_LINE DEDENT i = i + 1 NEW_LINE DEDENT return max ( result , preCnt + suffCnt ) NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT arr = [ 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 ] NEW_LINE n = len ( arr ) NEW_LINE print ( getMaxLength ( arr , n ) ) NEW_LINE DEDENT
def findMin ( arr , n ) : NEW_LINE INDENT m = 0 NEW_LINE for i in range ( n ) : NEW_LINE INDENT m = max ( m , arr [ i ] ) NEW_LINE DEDENT cnt = [ 0 ] * ( m + 2 ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT j = 1 NEW_LINE while j * j <= arr [ i ] : NEW_LINE INDENT if ( arr [ i ] % j == 0 ) : NEW_LINE INDENT if ( j * j == arr [ i ] ) : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE DEDENT else : NEW_LINE INDENT cnt [ j ] += 1 NEW_LINE cnt [ arr [ i ] // j ] += 1 NEW_LINE DEDENT DEDENT j += 1 NEW_LINE DEDENT DEDENT for i in range ( 1 , m + 2 ) : NEW_LINE INDENT if ( cnt [ i ] == 0 ) : NEW_LINE INDENT return i NEW_LINE DEDENT DEDENT return - 1 NEW_LINE DEDENT arr = [ 2 , 12 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE print ( findMin ( arr , n ) ) NEW_LINE
MAX = 1e9 NEW_LINE def minJumps ( arr , N ) : NEW_LINE INDENT fib = [ 0 for i in range ( 30 ) ] NEW_LINE fib [ 0 ] = 0 NEW_LINE fib [ 1 ] = 1 NEW_LINE for i in range ( 2 , 30 ) : NEW_LINE INDENT fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] NEW_LINE DEDENT DP = [ 0 for i in range ( N + 2 ) ] NEW_LINE DP [ 0 ] = 0 NEW_LINE for i in range ( 1 , N + 2 ) : NEW_LINE INDENT DP [ i ] = MAX NEW_LINE DEDENT for i in range ( 1 , N + 2 ) : NEW_LINE INDENT for j in range ( 1 , 30 ) : NEW_LINE INDENT if ( ( arr [ i - 1 ] == 1 or i == N + 1 ) and i - fib [ j ] >= 0 ) : NEW_LINE INDENT DP [ i ] = min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) NEW_LINE DEDENT DEDENT DEDENT if ( DP [ N + 1 ] != MAX ) : NEW_LINE INDENT return DP [ N + 1 ] NEW_LINE DEDENT else : NEW_LINE INDENT return - 1 NEW_LINE DEDENT DEDENT arr = [ 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE print ( minJumps ( arr , n - 1 ) ) NEW_LINE
def getHermiteNumber ( n ) : NEW_LINE INDENT if n == 0 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if n == 1 : NEW_LINE INDENT return 0 NEW_LINE DEDENT else : NEW_LINE INDENT return ( - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ) NEW_LINE DEDENT DEDENT n = 6 NEW_LINE print ( getHermiteNumber ( n ) ) ; NEW_LINE
def FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) : NEW_LINE INDENT x5 = max ( x1 , x3 ) NEW_LINE y5 = max ( y1 , y3 ) NEW_LINE x6 = min ( x2 , x4 ) NEW_LINE y6 = min ( y2 , y4 ) NEW_LINE if ( x5 > x6 or y5 > y6 ) : NEW_LINE INDENT print ( " No ▁ intersection " ) NEW_LINE return NEW_LINE DEDENT print ( " ( " , x5 , " , ▁ " , y5 , " ) ▁ " , end = " ▁ " ) NEW_LINE print ( " ( " , x6 , " , ▁ " , y6 , " ) ▁ " , end = " ▁ " ) NEW_LINE x7 = x5 NEW_LINE y7 = y6 NEW_LINE print ( " ( " , x7 , " , ▁ " , y7 , " ) ▁ " , end = " ▁ " ) NEW_LINE x8 = x6 NEW_LINE y8 = y5 NEW_LINE print ( " ( " , x8 , " , ▁ " , y8 , " ) ▁ " ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT x1 = 0 NEW_LINE y1 = 0 NEW_LINE x2 = 10 NEW_LINE y2 = 8 NEW_LINE x3 = 2 NEW_LINE y3 = 3 NEW_LINE x4 = 7 NEW_LINE y4 = 9 NEW_LINE FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) NEW_LINE DEDENT
def numberofDigits ( n ) : NEW_LINE INDENT cnt = 0 NEW_LINE while n > 0 : NEW_LINE INDENT cnt += 1 NEW_LINE n //= 10 NEW_LINE DEDENT return cnt NEW_LINE DEDENT def cal ( num ) : NEW_LINE INDENT digit = numberofDigits ( num ) NEW_LINE powTen = pow ( 10 , digit - 1 ) NEW_LINE for i in range ( digit - 1 ) : NEW_LINE INDENT firstDigit = num // powTen NEW_LINE left = ( num * 10 + firstDigit - ( firstDigit * powTen * 10 ) ) NEW_LINE print ( left , end = " ▁ " ) NEW_LINE num = left NEW_LINE DEDENT DEDENT num = 1445 NEW_LINE cal ( num ) NEW_LINE
def leastPrimeFactor ( n ) : NEW_LINE INDENT least_prime = [ 0 ] * ( n + 1 ) NEW_LINE least_prime [ 1 ] = 1 NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT if ( least_prime [ i ] == 0 ) : NEW_LINE INDENT least_prime [ i ] = i NEW_LINE for j in range ( 2 * i , n + 1 , i ) : NEW_LINE INDENT if ( least_prime [ j ] == 0 ) : NEW_LINE INDENT least_prime [ j ] = i NEW_LINE DEDENT DEDENT DEDENT DEDENT for i in range ( 1 , n + 1 ) : NEW_LINE INDENT print ( " Least ▁ Prime ▁ factor ▁ of ▁ " , i , " : ▁ " , least_prime [ i ] ) NEW_LINE DEDENT DEDENT n = 10 NEW_LINE leastPrimeFactor ( n ) NEW_LINE
def isPower ( x , y ) : NEW_LINE INDENT if ( x == 1 ) : NEW_LINE INDENT return ( y == 1 ) NEW_LINE DEDENT pow = 1 NEW_LINE while ( pow < y ) : NEW_LINE INDENT pow = pow * x NEW_LINE DEDENT return ( pow == y ) NEW_LINE DEDENT if ( isPower ( 10 , 1 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 1 , 20 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 2 , 128 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT if ( isPower ( 2 , 30 ) ) : NEW_LINE INDENT print ( 1 ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( 0 ) NEW_LINE DEDENT
def pattern ( rows_no ) : NEW_LINE INDENT for i in range ( 1 , rows_no + 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT for i in range ( rows_no - 1 , 0 , - 1 ) : NEW_LINE INDENT for k in range ( 1 , i ) : NEW_LINE INDENT print ( " ▁ " , end = " " ) NEW_LINE DEDENT for j in range ( i , rows_no + 1 ) : NEW_LINE INDENT print ( j , end = " ▁ " ) NEW_LINE DEDENT print ( ) NEW_LINE DEDENT DEDENT rows_no = 7 NEW_LINE pattern ( rows_no ) NEW_LINE
def printSmall ( arr , n , k ) : NEW_LINE INDENT for i in range ( k , n ) : NEW_LINE INDENT max_var = arr [ k - 1 ] NEW_LINE pos = k - 1 NEW_LINE for j in range ( k - 2 , - 1 , - 1 ) : NEW_LINE INDENT if ( arr [ j ] > max_var ) : NEW_LINE INDENT max_var = arr [ j ] NEW_LINE pos = j NEW_LINE DEDENT DEDENT if ( max_var > arr [ i ] ) : NEW_LINE INDENT j = pos NEW_LINE while ( j < k - 1 ) : NEW_LINE INDENT arr [ j ] = arr [ j + 1 ] NEW_LINE j += 1 NEW_LINE DEDENT arr [ k - 1 ] = arr [ i ] NEW_LINE DEDENT DEDENT for i in range ( 0 , k ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT arr = [ 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 ] NEW_LINE n = len ( arr ) NEW_LINE k = 5 NEW_LINE printSmall ( arr , n , k ) NEW_LINE
def smallest ( s ) : NEW_LINE INDENT l = len ( s ) NEW_LINE ans = " " NEW_LINE for i in range ( l ) : NEW_LINE INDENT if ( s [ i ] > s [ i + 1 ] ) : NEW_LINE INDENT for j in range ( l ) : NEW_LINE INDENT if ( i != j ) : NEW_LINE INDENT ans += s [ j ] NEW_LINE DEDENT DEDENT return ans NEW_LINE DEDENT DEDENT ans = s [ 0 : l - 1 ] NEW_LINE return ans NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT s = " abcda " NEW_LINE print ( smallest ( s ) ) NEW_LINE DEDENT
def countBits ( n ) : NEW_LINE INDENT count = 0 ; NEW_LINE while ( n > 0 ) : NEW_LINE INDENT count += 1 ; NEW_LINE n >>= 1 ; NEW_LINE DEDENT return count ; NEW_LINE DEDENT def findNearestNumber ( n ) : NEW_LINE INDENT cnt = countBits ( n ) ; NEW_LINE cnt -= 1 ; NEW_LINE if ( cnt % 2 ) : NEW_LINE INDENT return 1 << ( cnt + 1 ) ; NEW_LINE DEDENT else : NEW_LINE INDENT tempnum = 0 ; NEW_LINE for i in range ( 0 , cnt + 1 , 2 ) : NEW_LINE INDENT tempnum += 1 << i ; NEW_LINE DEDENT if ( tempnum < n ) : NEW_LINE INDENT return ( 1 << ( cnt + 2 ) ) ; NEW_LINE DEDENT elif ( tempnum == n ) : NEW_LINE INDENT return n ; NEW_LINE DEDENT for i in range ( 0 , cnt + 1 , 2 ) : NEW_LINE INDENT tempnum -= ( 1 << i ) ; NEW_LINE if ( tempnum < n ) : NEW_LINE INDENT tempnum += ( 1 << i ) ; NEW_LINE return tempnum ; NEW_LINE DEDENT DEDENT DEDENT DEDENT n = 19 ; NEW_LINE print ( findNearestNumber ( n ) ) ; NEW_LINE
from collections import deque NEW_LINE def run_tasks ( A , B ) : NEW_LINE INDENT total_time = 0 NEW_LINE while ( len ( A ) > 0 ) : NEW_LINE INDENT x = A . popleft ( ) NEW_LINE y = B . popleft ( ) NEW_LINE if ( x == y ) : NEW_LINE INDENT total_time += 1 NEW_LINE DEDENT else : NEW_LINE INDENT B . appendleft ( y ) NEW_LINE A . append ( x ) NEW_LINE total_time += 2 NEW_LINE DEDENT DEDENT return total_time NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT A = deque ( ) NEW_LINE A . append ( 3 ) NEW_LINE A . append ( 2 ) NEW_LINE A . append ( 1 ) NEW_LINE A . append ( 4 ) NEW_LINE B = deque ( ) NEW_LINE B . append ( 4 ) NEW_LINE B . append ( 1 ) NEW_LINE B . append ( 3 ) NEW_LINE B . append ( 2 ) NEW_LINE print ( run_tasks ( A , B ) ) NEW_LINE DEDENT
def findAllSequences ( diff , out , start , end ) : NEW_LINE INDENT if ( abs ( diff ) > ( end - start + 1 ) // 2 ) : NEW_LINE INDENT return ; NEW_LINE DEDENT if ( start > end ) : NEW_LINE INDENT if ( diff == 0 ) : NEW_LINE INDENT print ( ' ' . join ( list ( out ) ) , end = " ▁ " ) ; NEW_LINE DEDENT return ; NEW_LINE DEDENT out [ start ] = '0' ; NEW_LINE out [ end ] = '1' ; NEW_LINE findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = out [ end ] = '1' ; NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = out [ end ] = '0' ; NEW_LINE findAllSequences ( diff , out , start + 1 , end - 1 ) ; NEW_LINE out [ start ] = '1' ; NEW_LINE out [ end ] = '0' ; NEW_LINE findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; NEW_LINE DEDENT n = 2 ; NEW_LINE out = [ " " ] * ( 2 * n ) ; NEW_LINE findAllSequences ( 0 , out , 0 , 2 * n - 1 ) ; NEW_LINE
def Count_subarray ( arr , n ) : NEW_LINE INDENT total_sum = 0 ; NEW_LINE count = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT total_sum += arr [ i ] ; NEW_LINE DEDENT for i in range ( n ) : NEW_LINE INDENT subarray_sum = 0 ; NEW_LINE for j in range ( i , n ) : NEW_LINE INDENT subarray_sum += arr [ j ] ; NEW_LINE remaining_sum = total_sum - subarray_sum ; NEW_LINE if ( subarray_sum > remaining_sum ) : NEW_LINE INDENT count += 1 ; NEW_LINE DEDENT DEDENT DEDENT return count ; NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 10 , 9 , 12 , 6 ] ; NEW_LINE n = len ( arr ) ; NEW_LINE print ( Count_subarray ( arr , n ) ) ; NEW_LINE DEDENT
def countMultiples ( n ) : NEW_LINE INDENT multiple = [ 2 , 3 , 5 ] NEW_LINE count = 0 NEW_LINE mask = int ( pow ( 2 , 3 ) ) NEW_LINE for i in range ( 1 , mask ) : NEW_LINE INDENT prod = 1 NEW_LINE for j in range ( 3 ) : NEW_LINE INDENT if ( i & ( 1 << j ) ) : NEW_LINE INDENT prod = prod * multiple [ j ] NEW_LINE DEDENT DEDENT if ( bin ( i ) . count ( '1' ) % 2 == 1 ) : NEW_LINE INDENT count = count + n // prod NEW_LINE DEDENT else : NEW_LINE INDENT count = count - n // prod NEW_LINE DEDENT DEDENT return count NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 10 NEW_LINE print ( countMultiples ( n ) ) NEW_LINE DEDENT
def stringToInt ( str ) : NEW_LINE INDENT if ( len ( str ) == 1 ) : NEW_LINE INDENT return ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE DEDENT y = stringToInt ( str [ 1 : ] ) ; NEW_LINE x = ord ( str [ 0 ] ) - ord ( '0' ) ; NEW_LINE x = x * ( 10 ** ( len ( str ) - 1 ) ) + y ; NEW_LINE return int ( x ) ; NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT str = "1235" ; NEW_LINE print ( stringToInt ( str ) ) ; NEW_LINE DEDENT
def calcFunction ( n , r ) : NEW_LINE INDENT finalDenominator = 1 NEW_LINE mx = max ( r , n - r ) NEW_LINE for i in range ( mx + 1 , n + 1 ) : NEW_LINE INDENT denominator = pow ( i , i ) NEW_LINE numerator = pow ( i - mx , i - mx ) NEW_LINE finalDenominator = ( finalDenominator * denominator ) // numerator NEW_LINE DEDENT return finalDenominator NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 6 NEW_LINE r = 2 NEW_LINE print ( "1 / " , end = " " ) NEW_LINE print ( calcFunction ( n , r ) ) NEW_LINE DEDENT
import math NEW_LINE def countDigits ( n ) : NEW_LINE INDENT ans = 0 NEW_LINE for i in range ( 1 , n + 1 ) : NEW_LINE INDENT ans += math . log10 ( i ) NEW_LINE DEDENT ans = ans * n NEW_LINE return 1 + math . floor ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 4 NEW_LINE print ( countDigits ( n ) ) NEW_LINE DEDENT
def ReplaceElements ( arr , n ) : NEW_LINE INDENT max_ele = arr [ 0 ] NEW_LINE arr [ 0 ] = - 1 NEW_LINE for i in range ( 1 , n ) : NEW_LINE INDENT if ( max_ele > arr [ i ] ) : NEW_LINE INDENT arr [ i ] = max_ele NEW_LINE DEDENT elif ( max_ele <= arr [ i ] ) : NEW_LINE INDENT temp = arr [ i ] NEW_LINE arr [ i ] = max_ele NEW_LINE max_ele = temp NEW_LINE DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT arr = [ 4 , 5 , 2 , 1 , 7 , 6 ] NEW_LINE n = len ( arr ) NEW_LINE ReplaceElements ( arr , n ) NEW_LINE for i in range ( n ) : NEW_LINE INDENT print ( arr [ i ] , end = " ▁ " ) NEW_LINE DEDENT DEDENT
def nthTerm ( n ) : NEW_LINE INDENT nth = 0 NEW_LINE if ( n % 2 == 0 ) : NEW_LINE INDENT nth = 2 * ( ( n * n ) - n ) NEW_LINE DEDENT else : NEW_LINE INDENT nth = ( 2 * n * n ) - n NEW_LINE DEDENT return nth NEW_LINE DEDENT n = 5 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 25000000 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE n = 250000007 NEW_LINE print ( nthTerm ( n ) ) NEW_LINE
def decToHexa ( n ) : NEW_LINE INDENT hexaDeciNum = [ '0' ] * 100 ; NEW_LINE i = 0 ; NEW_LINE while ( n != 0 ) : NEW_LINE INDENT temp = 0 ; NEW_LINE temp = n % 16 ; NEW_LINE if ( temp < 10 ) : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 48 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT else : NEW_LINE INDENT hexaDeciNum [ i ] = chr ( temp + 55 ) ; NEW_LINE i = i + 1 ; NEW_LINE DEDENT n = int ( n / 16 ) ; NEW_LINE DEDENT j = i - 1 ; NEW_LINE while ( j >= 0 ) : NEW_LINE INDENT print ( ( hexaDeciNum [ j ] ) , end = " " ) ; NEW_LINE j = j - 1 ; NEW_LINE DEDENT DEDENT n = 2545 ; NEW_LINE decToHexa ( n ) ; NEW_LINE
def fib ( f , n ) : NEW_LINE INDENT f [ 0 ] = 0 ; NEW_LINE f [ 1 ] = 1 ; NEW_LINE for i in range ( 2 , n + 1 ) : NEW_LINE INDENT f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; NEW_LINE DEDENT return f ; NEW_LINE DEDENT def findLastDigit ( n ) : NEW_LINE INDENT f = [ 0 ] * 61 ; NEW_LINE f = fib ( f , 60 ) ; NEW_LINE return f [ n % 60 ] ; NEW_LINE DEDENT n = 1 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 61 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 7 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE n = 67 ; NEW_LINE print ( findLastDigit ( n ) ) ; NEW_LINE
def arrayConstruct ( N ) : NEW_LINE INDENT for i in range ( 2 , N + 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT for i in range ( 1 , N - 1 , 2 ) : NEW_LINE INDENT print ( i , end = " ▁ " ) NEW_LINE DEDENT print ( N - 1 + ( N // 2 ) ) NEW_LINE DEDENT def createArray ( N ) : NEW_LINE INDENT if ( N % 4 == 0 ) : NEW_LINE INDENT arrayConstruct ( N ) NEW_LINE DEDENT else : NEW_LINE INDENT cout << - 1 << endl NEW_LINE DEDENT DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT N = 8 NEW_LINE createArray ( N ) NEW_LINE DEDENT
INT_BITS = 32 NEW_LINE def leftRotate ( n , d ) : NEW_LINE INDENT return ( n << d ) | ( n >> ( INT_BITS - d ) ) NEW_LINE DEDENT def rightRotate ( n , d ) : NEW_LINE INDENT return ( n >> d ) | ( n << ( INT_BITS - d ) ) & 0xFFFFFFFF NEW_LINE DEDENT n = 16 NEW_LINE d = 2 NEW_LINE print ( " Left ▁ Rotation ▁ of " , n , " by " , d , " is " , end = " ▁ " ) NEW_LINE print ( leftRotate ( n , d ) ) NEW_LINE print ( " Right ▁ Rotation ▁ of " , n , " by " , d , " is " , end = " ▁ " ) NEW_LINE print ( rightRotate ( n , d ) ) NEW_LINE
import math as mt NEW_LINE def Area ( r ) : NEW_LINE INDENT if ( r < 0 ) : NEW_LINE INDENT return - 1 NEW_LINE DEDENT x = ( 2 * r ) / mt . sqrt ( 5 ) NEW_LINE A = 0.70477 * pow ( x , 2 ) NEW_LINE return A NEW_LINE DEDENT r = 5 NEW_LINE print ( Area ( r ) ) NEW_LINE
def maxLength ( s , n ) : NEW_LINE INDENT invalidOpenBraces = 0 ; NEW_LINE invalidCloseBraces = 0 ; NEW_LINE for i in range ( n ) : NEW_LINE INDENT if ( s [ i ] == ' ( ' ) : NEW_LINE INDENT invalidOpenBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT if ( invalidOpenBraces == 0 ) : NEW_LINE INDENT invalidCloseBraces += 1 NEW_LINE DEDENT else : NEW_LINE INDENT invalidOpenBraces -= 1 NEW_LINE DEDENT DEDENT DEDENT return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) NEW_LINE DEDENT s = " ( ) ( ( ( ( ( ( ) " NEW_LINE n = len ( s ) NEW_LINE print ( maxLength ( s , n ) ) NEW_LINE
def count_odd_pair ( n , a ) : NEW_LINE INDENT odd = 0 NEW_LINE even = 0 NEW_LINE for i in range ( 0 , n ) : NEW_LINE INDENT if a [ i ] % 2 == 0 : NEW_LINE INDENT even = even + 1 NEW_LINE DEDENT else : NEW_LINE INDENT odd = odd + 1 NEW_LINE DEDENT DEDENT ans = odd * ( odd - 1 ) NEW_LINE return ans NEW_LINE DEDENT def count_even_pair ( odd_product_pairs , n ) : NEW_LINE INDENT total_pairs = ( n * ( n - 1 ) ) NEW_LINE ans = total_pairs - odd_product_pairs NEW_LINE return ans NEW_LINE DEDENT if __name__ == ' _ _ main _ _ ' : NEW_LINE INDENT n = 6 NEW_LINE a = [ 2 , 4 , 5 , 9 , 1 , 8 ] NEW_LINE odd_product_pairs = count_odd_pair ( n , a ) NEW_LINE even_product_pairs = ( count_even_pair ( odd_product_pairs , n ) ) NEW_LINE print ( " Even ▁ Product ▁ Pairs ▁ = ▁ " , even_product_pairs ) NEW_LINE print ( " Odd ▁ Product ▁ Pairs = ▁ " , odd_product_pairs ) NEW_LINE DEDENT
def isPowerOfFour ( n ) : NEW_LINE INDENT if ( n == 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT while ( n != 1 ) : NEW_LINE INDENT if ( n % 4 != 0 ) : NEW_LINE INDENT return False NEW_LINE DEDENT n = n // 4 NEW_LINE DEDENT return True NEW_LINE DEDENT test_no = 64 NEW_LINE if ( isPowerOfFour ( 64 ) ) : NEW_LINE INDENT print ( test_no , ' is ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( test_no , ' is ▁ not ▁ a ▁ power ▁ of ▁ 4' ) NEW_LINE DEDENT
def isDivisible ( n ) : NEW_LINE INDENT while ( n // 100 ) : NEW_LINE INDENT d = n % 10 NEW_LINE n //= 10 NEW_LINE n -= d * 5 NEW_LINE DEDENT return ( n % 17 == 0 ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT n = 19877658 NEW_LINE if isDivisible ( n ) : NEW_LINE INDENT print ( " Yes " ) NEW_LINE DEDENT else : NEW_LINE INDENT print ( " No " ) NEW_LINE DEDENT DEDENT
def compute ( ) : NEW_LINE INDENT NUM_DAYS = 30 NEW_LINE MAX_ABSENT = 2 NEW_LINE MAX_LATE = 1 NEW_LINE num_prize_strings = create_nested_lists ( 0 , NUM_DAYS + 1 , MAX_ABSENT + 1 , MAX_LATE + 1 ) NEW_LINE num_prize_strings [ 0 ] [ 0 ] [ 0 ] = 1 NEW_LINE for i in range ( 1 , len ( num_prize_strings ) ) : NEW_LINE INDENT for j in range ( len ( num_prize_strings [ i ] ) ) : NEW_LINE INDENT for k in range ( len ( num_prize_strings [ i ] [ j ] ) ) : NEW_LINE INDENT if j == 0 : NEW_LINE INDENT s = 0 NEW_LINE for l in range ( MAX_ABSENT + 1 ) : NEW_LINE INDENT s += num_prize_strings [ i - 1 ] [ l ] [ k ] NEW_LINE DEDENT if k > 0 : NEW_LINE INDENT for l in range ( MAX_ABSENT + 1 ) : NEW_LINE INDENT s += num_prize_strings [ i - 1 ] [ l ] [ k - 1 ] NEW_LINE DEDENT DEDENT DEDENT else : NEW_LINE INDENT s = num_prize_strings [ i - 1 ] [ j - 1 ] [ k ] NEW_LINE DEDENT num_prize_strings [ i ] [ j ] [ k ] = s NEW_LINE DEDENT DEDENT DEDENT ans = sum ( map ( sum , num_prize_strings [ NUM_DAYS ] ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def create_nested_lists ( value , * dimensions ) : NEW_LINE INDENT if len ( dimensions ) == 0 : NEW_LINE INDENT raise ValueError ( ) NEW_LINE DEDENT elif len ( dimensions ) == 1 : NEW_LINE INDENT return [ value ] * dimensions [ 0 ] NEW_LINE DEDENT else : NEW_LINE INDENT return [ create_nested_lists ( value , * dimensions [ 1 : ] ) for _ in range ( dimensions [ 0 ] ) ] NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT pentanum = PentagonalNumberHelper ( ) NEW_LINE min_d = None NEW_LINE for i in itertools . count ( 2 ) : NEW_LINE INDENT pent_i = pentanum . term ( i ) NEW_LINE if min_d is not None and pent_i - pentanum . term ( i - 1 ) >= min_d : NEW_LINE INDENT break NEW_LINE DEDENT for j in range ( i - 1 , 0 , - 1 ) : NEW_LINE INDENT pent_j = pentanum . term ( j ) NEW_LINE diff = pent_i - pent_j NEW_LINE if min_d is not None and diff >= min_d : NEW_LINE INDENT break NEW_LINE DEDENT elif pentanum . is_term ( pent_i + pent_j ) and pentanum . is_term ( diff ) : NEW_LINE INDENT min_d = diff NEW_LINE DEDENT DEDENT DEDENT return str ( min_d ) NEW_LINE DEDENT class PentagonalNumberHelper : NEW_LINE INDENT def __init__ ( self ) : NEW_LINE INDENT self . term_list = [ 0 ] NEW_LINE self . term_set = set ( ) NEW_LINE DEDENT def term ( self , x ) : NEW_LINE INDENT assert x > 0 NEW_LINE while len ( self . term_list ) <= x : NEW_LINE INDENT n = len ( self . term_list ) NEW_LINE term = ( n * ( n * 3 - 1 ) ) >> 1 NEW_LINE self . term_list . append ( term ) NEW_LINE self . term_set . add ( term ) NEW_LINE DEDENT return self . term_list [ x ] NEW_LINE DEDENT def is_term ( self , y ) : NEW_LINE INDENT assert y > 0 NEW_LINE while self . term_list [ - 1 ] < y : NEW_LINE INDENT n = len ( self . term_list ) NEW_LINE term = ( n * ( n * 3 - 1 ) ) >> 1 NEW_LINE self . term_list . append ( term ) NEW_LINE self . term_set . add ( term ) NEW_LINE DEDENT return y in self . term_set NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT divisorsum = [ 0 ] * 10000 NEW_LINE for i in range ( 1 , len ( divisorsum ) ) : NEW_LINE INDENT for j in range ( i * 2 , len ( divisorsum ) , i ) : NEW_LINE INDENT divisorsum [ j ] += i NEW_LINE DEDENT DEDENT ans = 0 NEW_LINE for i in range ( 1 , len ( divisorsum ) ) : NEW_LINE INDENT j = divisorsum [ i ] NEW_LINE if j != i and j < len ( divisorsum ) and divisorsum [ j ] == i : NEW_LINE INDENT ans += i NEW_LINE DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 200 NEW_LINE minoperations = [ 0 , 0 ] + [ None ] * ( LIMIT - 1 ) NEW_LINE numunknown = [ LIMIT - 1 ] NEW_LINE def explore_chains ( chain , maxops ) : NEW_LINE INDENT if len ( chain ) > maxops or numunknown [ 0 ] == 0 : NEW_LINE INDENT return NEW_LINE DEDENT max = chain [ - 1 ] NEW_LINE for i in reversed ( range ( len ( chain ) ) ) : NEW_LINE INDENT for j in reversed ( range ( i + 1 ) ) : NEW_LINE INDENT x = chain [ i ] + chain [ j ] NEW_LINE if x <= max : NEW_LINE INDENT break NEW_LINE DEDENT if x <= LIMIT : NEW_LINE INDENT chain . append ( x ) NEW_LINE if minoperations [ x ] is None : NEW_LINE INDENT minoperations [ x ] = len ( chain ) - 1 NEW_LINE numunknown [ 0 ] -= 1 NEW_LINE DEDENT explore_chains ( chain , maxops ) NEW_LINE chain . pop ( ) NEW_LINE DEDENT DEDENT DEDENT DEDENT for ops in itertools . count ( 1 ) : NEW_LINE INDENT if numunknown [ 0 ] == 0 : NEW_LINE INDENT return str ( sum ( minoperations ) ) NEW_LINE DEDENT explore_chains ( [ 1 ] , ops ) NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = max ( i * j for i in range ( 100 , 1000 ) for j in range ( 100 , 1000 ) if str ( i * j ) == str ( i * j ) [ : : - 1 ] ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT LIMIT = 50000000 NEW_LINE sequence = [ ( 2 * i * i - 1 ) for i in range ( LIMIT + 1 ) ] NEW_LINE sequence [ 0 ] = sequence [ 1 ] = - 1 NEW_LINE ans = 0 NEW_LINE for ( i , term ) in enumerate ( sequence ) : NEW_LINE INDENT if i < 2 : NEW_LINE INDENT continue NEW_LINE DEDENT if term == 2 * i * i - 1 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT if 1 < term <= LIMIT * 2 : NEW_LINE INDENT p = term NEW_LINE for j in range ( i + p , LIMIT + 1 , p ) : NEW_LINE INDENT while True : NEW_LINE INDENT sequence [ j ] //= p NEW_LINE if sequence [ j ] % p != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT for j in range ( i + ( p - i ) * 2 % p , LIMIT + 1 , p ) : NEW_LINE INDENT while True : NEW_LINE INDENT sequence [ j ] //= p NEW_LINE if sequence [ j ] % p != 0 : NEW_LINE INDENT break NEW_LINE DEDENT DEDENT DEDENT DEDENT DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT PERIMETER = 1000 NEW_LINE for a in range ( 1 , PERIMETER + 1 ) : NEW_LINE INDENT for b in range ( a + 1 , PERIMETER + 1 ) : NEW_LINE INDENT c = PERIMETER - a - b NEW_LINE if a * a + b * b == c * c : NEW_LINE INDENT return str ( a * b * c ) NEW_LINE DEDENT DEDENT DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT s = " " . join ( str ( i ) for i in range ( 1 , 1000000 ) ) NEW_LINE ans = 1 NEW_LINE for i in range ( 7 ) : NEW_LINE INDENT ans *= int ( s [ 10 ** i - 1 ] ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import eulerlib , sys NEW_LINE def compute ( ) : NEW_LINE INDENT sys . setrecursionlimit ( 3000 ) NEW_LINE ans = max ( range ( 1 , 1000000 ) , key = collatz_chain_length ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def collatz_chain_length ( x ) : NEW_LINE INDENT if x == 1 : NEW_LINE INDENT return 1 NEW_LINE DEDENT if x % 2 == 0 : NEW_LINE INDENT y = x // 2 NEW_LINE DEDENT else : NEW_LINE INDENT y = x * 3 + 1 NEW_LINE DEDENT return collatz_chain_length ( y ) + 1 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT numbers = set ( eulerlib . binomial ( n , k ) for n in range ( 51 ) for k in range ( n + 1 ) ) NEW_LINE maximum = max ( numbers ) NEW_LINE primes = eulerlib . list_primes ( eulerlib . sqrt ( maximum ) ) NEW_LINE primessquared = [ p * p for p in primes ] NEW_LINE def is_squarefree ( n ) : NEW_LINE INDENT for p2 in primessquared : NEW_LINE INDENT if p2 > n : NEW_LINE INDENT break NEW_LINE DEDENT if n % p2 == 0 : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT return True NEW_LINE DEDENT ans = sum ( n for n in numbers if is_squarefree ( n ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT DIGITS = 100 NEW_LINE MULTIPLIER = 100 ** DIGITS NEW_LINE ans = sum ( sum ( int ( c ) for c in str ( eulerlib . sqrt ( i * MULTIPLIER ) ) [ : DIGITS ] ) for i in range ( 100 ) if eulerlib . sqrt ( i ) ** 2 != i ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
def compute ( ) : NEW_LINE INDENT ans = max ( range ( 1 , 1001 ) , key = count_solutions ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def count_solutions ( p ) : NEW_LINE INDENT result = 0 NEW_LINE for a in range ( 1 , p + 1 ) : NEW_LINE INDENT for b in range ( a , ( p - a ) // 2 + 1 ) : NEW_LINE INDENT c = p - a - b NEW_LINE if a * a + b * b == c * c : NEW_LINE INDENT result += 1 NEW_LINE DEDENT DEDENT DEDENT return result NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import itertools NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 10 ** 8 NEW_LINE smallestdivisiblefactorials = [ 0 ] * ( LIMIT + 1 ) NEW_LINE for i in range ( 2 , len ( smallestdivisiblefactorials ) ) : NEW_LINE INDENT if smallestdivisiblefactorials [ i ] == 0 : NEW_LINE INDENT power = 1 NEW_LINE for j in itertools . count ( i , i ) : NEW_LINE INDENT power *= i NEW_LINE if power > LIMIT : NEW_LINE INDENT break NEW_LINE DEDENT for k in range ( power , len ( smallestdivisiblefactorials ) , power ) : NEW_LINE INDENT smallestdivisiblefactorials [ k ] = max ( j , smallestdivisiblefactorials [ k ] ) NEW_LINE DEDENT temp = j // i NEW_LINE while temp % i == 0 : NEW_LINE INDENT power *= i NEW_LINE temp //= i NEW_LINE DEDENT DEDENT DEDENT DEDENT ans = sum ( smallestdivisiblefactorials ) NEW_LINE return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import eulerlib , itertools NEW_LINE def compute ( ) : NEW_LINE INDENT cond = lambda i : eulerlib . is_prime ( i ) and repunit_mod ( 10 ** 9 , i ) == 0 NEW_LINE ans = sum ( itertools . islice ( filter ( cond , itertools . count ( 2 ) ) , 40 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT def repunit_mod ( k , m ) : NEW_LINE INDENT return ( pow ( 10 , k , m * 9 ) - 1 ) // 9 NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import fractions NEW_LINE def compute ( ) : NEW_LINE INDENT ans = 1 NEW_LINE for i in range ( 1 , 21 ) : NEW_LINE INDENT ans *= i // fractions . gcd ( i , ans ) NEW_LINE DEDENT return str ( ans ) NEW_LINE DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
import eulerlib NEW_LINE def compute ( ) : NEW_LINE INDENT LIMIT = 40 NEW_LINE ans = sum ( count_step_pandigital ( digits , head , 0 , 9 ) for digits in range ( LIMIT + 1 ) for head in range ( 1 , 10 ) ) NEW_LINE return str ( ans ) NEW_LINE DEDENT @ eulerlib . memoize NEW_LINE def count_step_pandigital ( digits , head , low , high ) : NEW_LINE INDENT assert digits >= 0 NEW_LINE assert low <= head <= high NEW_LINE if digits <= 1 : NEW_LINE INDENT return 1 if ( low == head == high ) else 0 NEW_LINE DEDENT else : NEW_LINE INDENT result = 0 NEW_LINE if head - 1 >= low : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head - 1 , low , high ) NEW_LINE if head == high : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head - 1 , low , high - 1 ) NEW_LINE DEDENT DEDENT if head + 1 <= high : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head + 1 , low , high ) NEW_LINE if head == low : NEW_LINE INDENT result += count_step_pandigital ( digits - 1 , head + 1 , low + 1 , high ) NEW_LINE DEDENT DEDENT assert 0 <= result < 10 ** digits NEW_LINE return result NEW_LINE DEDENT DEDENT if __name__ == " _ _ main _ _ " : NEW_LINE INDENT print ( compute ( ) ) NEW_LINE DEDENT
class Solution ( object ) : NEW_LINE INDENT def isToeplitzMatrix ( self , matrix ) : NEW_LINE INDENT for r in range ( len ( matrix ) - 1 ) : NEW_LINE INDENT for c in range ( len ( matrix [ 0 ] ) - 1 ) : NEW_LINE INDENT if matrix [ r ] [ c ] != matrix [ r + 1 ] [ c + 1 ] : NEW_LINE INDENT return False NEW_LINE DEDENT DEDENT DEDENT return True NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def findKthLargest ( self , nums , k ) : NEW_LINE INDENT random . shuffle ( nums ) NEW_LINE return self . quickSelection ( nums , 0 , len ( nums ) - 1 , len ( nums ) - k ) NEW_LINE DEDENT def quickSelection ( self , nums , start , end , k ) : NEW_LINE INDENT if start > end : NEW_LINE INDENT return float ( ' inf ' ) NEW_LINE DEDENT pivot = nums [ end ] NEW_LINE left = start NEW_LINE for i in range ( start , end ) : NEW_LINE INDENT if nums [ i ] <= pivot : NEW_LINE INDENT nums [ left ] , nums [ i ] = nums [ i ] , nums [ left ] NEW_LINE left += 1 NEW_LINE DEDENT DEDENT nums [ left ] , nums [ end ] = nums [ end ] , nums [ left ] NEW_LINE if left == k : NEW_LINE INDENT return nums [ left ] NEW_LINE DEDENT elif left < k : NEW_LINE INDENT return self . quickSelection ( nums , left + 1 , end , k ) NEW_LINE DEDENT else : NEW_LINE INDENT return self . quickSelection ( nums , start , left - 1 , k ) NEW_LINE DEDENT DEDENT DEDENT
class KthLargest ( object ) : NEW_LINE INDENT def __init__ ( self , k , nums ) : NEW_LINE INDENT self . nums = nums NEW_LINE self . k = k NEW_LINE heapq . heapify ( self . nums ) NEW_LINE while len ( self . nums ) > k : NEW_LINE INDENT heapq . heappop ( self . nums ) NEW_LINE DEDENT DEDENT def add ( self , val ) : NEW_LINE INDENT if len ( self . nums ) < self . k : NEW_LINE INDENT heapq . heappush ( self . nums , val ) NEW_LINE DEDENT elif val > self . nums [ 0 ] : NEW_LINE INDENT heapq . heapreplace ( self . nums , val ) NEW_LINE DEDENT return self . nums [ 0 ] NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def compress ( self , chars ) : NEW_LINE INDENT anchor = write = 0 NEW_LINE for read , c in enumerate ( chars ) : NEW_LINE INDENT if read + 1 == len ( chars ) or chars [ read + 1 ] != c : NEW_LINE INDENT chars [ write ] = chars [ anchor ] NEW_LINE write += 1 NEW_LINE if read > anchor : NEW_LINE INDENT for digit in str ( read - anchor + 1 ) : NEW_LINE INDENT chars [ write ] = digit NEW_LINE write += 1 NEW_LINE DEDENT DEDENT anchor = read + 1 NEW_LINE DEDENT DEDENT return write NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def pivotIndex ( self , nums ) : NEW_LINE INDENT totalsum = sum ( nums ) NEW_LINE leftsum = 0 NEW_LINE for i , v in enumerate ( nums ) : NEW_LINE INDENT if leftsum == totalsum - leftsum - v : NEW_LINE INDENT return i NEW_LINE DEDENT leftsum += v NEW_LINE DEDENT return - 1 NEW_LINE DEDENT DEDENT
class Solution : NEW_LINE INDENT def longestPalindrome ( self , s ) : NEW_LINE INDENT ans = 0 NEW_LINE char_map = { } NEW_LINE for c in s : NEW_LINE INDENT char_map [ c ] = char_map . get ( c , 0 ) + 1 NEW_LINE DEDENT for c in char_map . keys ( ) : NEW_LINE INDENT if char_map [ c ] % 2 == 0 : NEW_LINE INDENT ans += char_map . pop ( c ) NEW_LINE DEDENT else : NEW_LINE INDENT ans += char_map [ c ] / 2 * 2 NEW_LINE DEDENT DEDENT if len ( char_map ) != 0 : NEW_LINE INDENT ans += 1 NEW_LINE DEDENT return ans NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def missingNumber ( self , nums ) : NEW_LINE INDENT res = len ( nums ) NEW_LINE for i , v in enumerate ( nums ) : NEW_LINE INDENT res ^= i NEW_LINE res ^= v NEW_LINE DEDENT return res NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def subdomainVisits ( self , cpdomains ) : NEW_LINE INDENT domain_count = { } NEW_LINE for cpdomain in cpdomains : NEW_LINE INDENT count , domain = cpdomain . split ( ' ▁ ' ) NEW_LINE sub_domain = domain . split ( ' . ' ) NEW_LINE for i in range ( len ( sub_domain ) ) : NEW_LINE INDENT curr = ' . ' . join ( sub_domain [ i : ] ) NEW_LINE domain_count [ curr ] = domain_count . get ( curr , 0 ) + int ( count ) NEW_LINE DEDENT DEDENT return [ str ( v ) + ' ▁ ' + k for k , v in domain_count . items ( ) ] NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def plusOne ( self , digits ) : NEW_LINE INDENT ls = len ( digits ) NEW_LINE for index in reversed ( range ( ls ) ) : NEW_LINE INDENT if digits [ index ] < 9 : NEW_LINE INDENT digits [ index ] += 1 NEW_LINE return digits NEW_LINE DEDENT else : NEW_LINE INDENT digits [ index ] = 0 NEW_LINE DEDENT DEDENT digits . insert ( 0 , 1 ) NEW_LINE return digits NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def isPerfectSquare ( self , num ) : NEW_LINE INDENT low , high = 1 , num NEW_LINE while low <= high : NEW_LINE INDENT mid = ( low + high ) / 2 NEW_LINE mid_square = mid * mid NEW_LINE if mid_square == num : NEW_LINE INDENT return True NEW_LINE DEDENT elif mid_square < num : NEW_LINE INDENT low = mid + 1 NEW_LINE DEDENT else : NEW_LINE INDENT high = mid - 1 NEW_LINE DEDENT DEDENT return False NEW_LINE DEDENT DEDENT
class Solution ( object ) : NEW_LINE INDENT def findTheDifference ( self , s , t ) : NEW_LINE INDENT res = ord ( t [ - 1 ] ) NEW_LINE for i in range ( len ( s ) ) : NEW_LINE INDENT res += ord ( t [ i ] ) NEW_LINE res -= ord ( s [ i ] ) NEW_LINE DEDENT return chr ( res ) NEW_LINE DEDENT DEDENT
