import java . io . * ; import java . util . * ; public class Main { public static void main ( String [ ] args ) { MyScanner sc = new MyScanner ( ) ; Long a = sc . nextLong ( ) ; Long b = sc . nextLong ( ) ; Long x = sc . nextLong ( ) ; Long A = a == 0 ? 0 : ( a - 1 ) / x + 1 ; Long B = b / x + 1 ; System . out . println ( B - A ) ; } static int l_min ( int [ ] a ) { Arrays . sort ( a ) ; return a [ 0 ] ; } static int l_max ( int [ ] a ) { int l = a . length ; Arrays . sort ( a ) ; return a [ l - 1 ] ; } public static PrintWriter out ; public static class MyScanner { BufferedReader br ; StringTokenizer st ; public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . util . ArrayList ; import java . util . Collections ; import java . util . Scanner ; class Main { static int G ; static int D ; static int [ ] p ; static int [ ] c ; static boolean [ ] used ; static long ans = 1000000000 ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int [ ] a = new int [ m ] ; int [ ] b = new int [ m ] ; ArrayList < Pair > pairs = new ArrayList < Pair > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { Pair pair = new Pair ( ) ; a [ i ] = sc . nextInt ( ) - 1 ; b [ i ] = sc . nextInt ( ) - 1 ; pair . from = a [ i ] ; pair . end = b [ i ] ; pairs . add ( pair ) ; } Collections . sort ( pairs ) ; int minR = pairs . get ( 0 ) . end ; int ans = 0 ; for ( int i = 1 ; i < m ; i ++ ) { if ( pairs . get ( i ) . from >= minR ) { ans ++ ; minR = pairs . get ( i ) . end ; } else { if ( pairs . get ( i ) . end < minR ) { minR = pairs . get ( i ) . end ; } } } ans ++ ; System . out . println ( ans ) ; } } class Pair implements Comparable { int from ; int end ; int num ; int bango ; @ Override public int compareTo ( Object other ) { Pair otherpair = ( Pair ) other ; return from - otherpair . from ; } } Note : . / Main . java uses unchecked or unsafe operations . Note : Recompile with - Xlint : unchecked for details .
import java . math . BigInteger ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int n = sc . nextInt ( ) ; BigInteger ten = BigInteger . valueOf ( 10 ) ; System . out . println ( ten . pow ( n ) . add ( BigInteger . valueOf ( 7 ) ) ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner scan = new Scanner ( System . in ) ) { int [ ] cList = init ( scan ) ; double ans = proc ( cList ) ; System . out . println ( ans ) ; } } public static int [ ] init ( Scanner scan ) { int n = scan . nextInt ( ) ; int [ ] cList = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { cList [ i ] = scan . nextInt ( ) ; } return cList ; } public static double proc ( int [ ] cList ) { double ans = 0 ; int size = cList . length ; double temp = 0 ; for ( int i = 0 ; i < size ; i ++ ) { temp = 0 ; for ( int j = 0 ; j < size ; j ++ ) { if ( cList [ i ] % cList [ j ] == 0 && i != j ) { temp ++ ; } } if ( temp == 0 ) { ans += 1.0 ; } else if ( ( temp ) % 2.0 != 0 ) { ans += 0.5 ; } else { ans += ( temp + 2.0 ) / ( 2.0 * temp + 2.0 ) ; } } return ans ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int H = sc . nextInt ( ) ; int W = sc . nextInt ( ) ; int [ ] [ ] wf = new int [ 10 ] [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { wf [ i ] [ j ] = sc . nextInt ( ) ; } } for ( int k = 0 ; k < 10 ; k ++ ) { for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { wf [ i ] [ j ] = Math . min ( wf [ i ] [ j ] , wf [ i ] [ k ] + wf [ k ] [ j ] ) ; } } } int [ ] count = new int [ 10 ] ; for ( int i = 0 ; i < H ; i ++ ) { for ( int j = 0 ; j < W ; j ++ ) { int a = sc . nextInt ( ) ; if ( a >= 0 ) { count [ a ] ++ ; } } } int sum = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { if ( i == 1 ) continue ; int cost = wf [ i ] [ 1 ] ; sum += cost * count [ i ] ; } System . out . println ( sum ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int AB = scan . nextInt ( ) ; int BC = scan . nextInt ( ) ; int CA = scan . nextInt ( ) ; System . out . println ( ( AB * BC ) / 2 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; String w = scanner . nextLine ( ) ; scanner . close ( ) ; w = w . replace ( " a " , " " ) . replace ( " i " , " " ) . replace ( " u " , " " ) . replace ( " e " , " " ) . replace ( " o " , " " ) ; System . out . println ( w ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int maxCount = 0 ; int maxNum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int count = 0 ; int num = i + 1 ; while ( true ) { if ( num % 2 != 0 ) { break ; } num /= 2 ; count ++ ; } if ( i == 0 || count > maxCount ) { maxCount = count ; maxNum = i + 1 ; } } System . out . println ( maxNum ) ; } }
import java . util . Scanner ; public class Main { static int n ; static int [ ] a ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } int max = 0 , min = n ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , a [ i ] ) ; min = Math . min ( min , a [ i ] ) ; } if ( max - min >= 2 ) { System . out . println ( " No " ) ; return ; } if ( max == min ) { if ( max == n - 1 || 2 * max <= n ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } else { int x = 0 , y = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == max ) { ++ x ; } if ( a [ i ] == min ) { ++ y ; } } if ( y < max && 2 * ( max - y ) <= x ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; if ( isPrime ( n ) ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } static boolean isPrime ( int x ) { for ( int i = 2 ; i <= 1000 && i < x ; i ++ ) { if ( x % i == 0 ) { return false ; } } return true ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] b = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = sc . nextInt ( ) ; } sc . close ( ) ; long [ ] num = new long [ 29 ] ; long ans = 0 ; for ( int i = 0 ; i < 29 ; i ++ ) { int [ ] ta = new int [ n ] ; int [ ] tb = new int [ n ] ; for ( int j = 0 ; j < n ; j ++ ) { ta [ j ] = a [ j ] % ( 2 << i ) ; tb [ j ] = b [ j ] % ( 2 << i ) ; } Arrays . sort ( tb ) ; int pow1 = ( 2 << i ) / 2 ; int pow2 = 2 * pow1 , pow3 = 3 * pow1 , pow4 = 4 * pow1 ; for ( int j = 0 ; j < n ; j ++ ) { int tmp1 = myBinarySearch ( tb , pow1 - ta [ j ] ) ; int tmp2 = myBinarySearch ( tb , pow2 - ta [ j ] ) ; int tmp3 = myBinarySearch ( tb , pow3 - ta [ j ] ) ; int tmp4 = myBinarySearch ( tb , pow4 - ta [ j ] ) ; num [ i ] += tmp2 - tmp1 + tmp4 - tmp3 ; } if ( num [ i ] % 2 == 1 ) ans += ( 2 << i ) / 2 ; } System . out . println ( ans ) ; } public static int myBinarySearch ( int [ ] la , int key ) { int l = - 1 ; int r = la . length ; while ( r - l > 1 ) { int m = ( l + r ) >> 1 ; if ( la [ m ] >= key ) { r = m ; } else { l = m ; } } return r ; } }
import java . util . * ; public class Main { static long [ ] fact , ifact ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long mod = 1000000007 ; int size = 1001000 ; fact = new long [ size ] ; ifact = new long [ size ] ; fact [ 0 ] = 1 ; for ( int i = 1 ; i < size ; i ++ ) fact [ i ] = fact [ i - 1 ] * i % mod ; ifact [ size - 1 ] = inv ( fact [ size - 1 ] , mod ) ; for ( int i = size - 1 ; i > 0 ; i -- ) ifact [ i - 1 ] = ifact [ i ] * i % mod ; long res = 0 ; long sum = 0 ; for ( int i = n / 2 ; i < n ; i ++ ) { long v = binom ( i - 1 , n - i - 1 , mod ) * fact [ i ] % mod * fact [ n - i - 1 ] % mod ; res = ( res + ( v - sum + mod ) % mod * i ) % mod ; sum = v ; } System . out . println ( res ) ; } static long binom ( int a , int b , long mod ) { if ( a < b ) return 0 ; return fact [ a ] * ifact [ b ] % mod * ifact [ a - b ] % mod ; } static long inv ( long a , long mod ) { long b = mod ; long p = 1 , q = 0 ; while ( b > 0 ) { long c = a / b ; long d = a ; a = b ; b = d % b ; d = p ; p = q ; q = d - c * q ; } return ( p + mod ) % mod ; } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; D solver = new D ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class D { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int n = in . nextInt ( ) ; int [ ] l = new int [ n + 1 ] ; l [ 0 ] = - 1 ; int ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int m = in . nextInt ( ) ; for ( int j = 1 ; j <= i ; j ++ ) { if ( l [ j - 1 ] == 0 ) { break ; } else if ( l [ j - 1 ] < m ) { if ( l [ j ] == 0 ) { l [ j ] = m ; ans = Math . max ( ans , j ) ; } else { l [ j ] = Math . min ( l [ j ] , m ) ; } } } } out . println ( n - ans ) ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { try ( Scanner sc = new Scanner ( System . in ) ) { int N = sc . nextInt ( ) ; long [ ] H = new long [ N ] ; long [ ] S = new long [ N ] ; long ansmin = 0 , ansmax = Long . MAX_VALUE >> 2 ; for ( int i = 0 ; i < N ; i ++ ) { H [ i ] = sc . nextLong ( ) ; S [ i ] = sc . nextLong ( ) ; ansmin = Math . max ( ansmin , H [ i ] ) ; } long [ ] time = new long [ N ] ; for ( int idx = 0 ; idx < 100 ; idx ++ ) { long ansmid = ( ansmax + ansmin ) / 2 ; boolean f = true ; for ( int i = 0 ; i < N ; i ++ ) { time [ i ] = ( ansmid - H [ i ] - 1 ) / S [ i ] ; } Arrays . sort ( time ) ; for ( int i = 0 ; f && i < N ; i ++ ) { if ( time [ i ] < ( long ) i ) { f = false ; } } if ( f ) { ansmax = ansmid ; } else { ansmin = ansmid ; } } System . out . println ( ansmin ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner a = new Scanner ( System . in ) ; int N = a . nextInt ( ) ; int x = N * 2 ; System . out . println ( x ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } void solve ( ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; long [ ] sum_a = new long [ n ] ; long [ ] sum_b = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextLong ( ) ; if ( i == 0 ) { sum_a [ i ] = a [ i ] ; sum_b [ i ] = Math . max ( 0 , a [ i ] ) ; } else { sum_a [ i ] = sum_a [ i - 1 ] + a [ i ] ; sum_b [ i ] = sum_b [ i - 1 ] + Math . max ( 0 , a [ i ] ) ; } } long ans = 0 ; for ( int i = 0 ; i <= n - k ; i ++ ) { long sum_black = 0 ; long sum_white = 0 ; if ( i == 0 ) sum_black += sum_a [ i + k - 1 ] ; else sum_black += sum_a [ i + k - 1 ] - sum_a [ i - 1 ] ; if ( i > 0 ) { sum_black += sum_b [ i - 1 ] ; sum_white += sum_b [ i - 1 ] ; } sum_black += sum_b [ n - 1 ] - sum_b [ i + k - 1 ] ; sum_white += sum_b [ n - 1 ] - sum_b [ i + k - 1 ] ; ans = Math . max ( sum_black , ans ) ; ans = Math . max ( sum_white , ans ) ; } System . out . println ( ans ) ; } }
import java . util . Scanner ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] [ ] sw = new int [ N ] [ 2 ] ; long cnt = 0 ; for ( int i = 0 ; i < N ; i ++ ) { sw [ i ] [ 0 ] = sc . nextInt ( ) ; sw [ i ] [ 1 ] = sc . nextInt ( ) ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( ( cnt + sw [ i ] [ 0 ] ) % sw [ i ] [ 1 ] == 0 ) { } else { cnt += sw [ i ] [ 1 ] - ( cnt + sw [ i ] [ 0 ] ) % sw [ i ] [ 1 ] ; } } System . out . println ( cnt ) ; sc . close ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner reader = new Scanner ( System . in ) ; String N = reader . next ( ) ; int num = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { char ch = N . charAt ( i ) ; num += Character . getNumericValue ( ch ) ; } if ( Integer . parseInt ( N ) % num == 0 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } reader . close ( ) ; } }
import java . util . * ; public class Main { static public int n ; static int [ ] A = new int [ 50 ] ; static int [ ] B = new int [ 50 ] ; public Boolean fun ( Long bit ) { boolean [ ] [ ] arr = new boolean [ 51 ] [ 51 ] ; for ( int i = 0 ; i <= 50 ; i ++ ) { arr [ i ] [ i ] = true ; } for ( int i = 1 ; i <= 50 ; i ++ ) { if ( ( bit & ( 1L << i ) ) != 0 ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ j ] [ j % i ] = true ; } } } for ( int k = 0 ; k <= 50 ; k ++ ) { for ( int i = 0 ; i <= 50 ; i ++ ) { for ( int j = 0 ; j <= 50 ; j ++ ) { arr [ i ] [ j ] |= arr [ i ] [ k ] & arr [ k ] [ j ] ; } } } Boolean flag = true ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! arr [ A [ i ] ] [ B [ i ] ] ) flag = false ; } return flag ; } public void solve ( ) { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; for ( int i = 0 ; i < n ; i ++ ) { A [ i ] = sc . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { B [ i ] = sc . nextInt ( ) ; } Long ans = ( 1L << 50 ) - 1 ; if ( ! fun ( ans ) ) { System . out . println ( - 1 ) ; return ; } for ( int i = 50 ; i >= 0 ; i -- ) { Long tmp = ans & ~ ( 1L << i ) ; if ( fun ( tmp ) ) ans = tmp ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { new Main ( ) . solve ( ) ; } } ;
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int NA = sc . nextInt ( ) ; int NB = sc . nextInt ( ) ; HashSet A = new HashSet < > ( ) ; for ( int i = 0 ; i < NA ; i ++ ) { A . add ( sc . nextInt ( ) ) ; } int cnt = 0 ; for ( int i = 0 ; i < NB ; i ++ ) { int target = sc . nextInt ( ) ; if ( A . contains ( target ) ) { cnt ++ ; } else { A . add ( target ) ; } } System . out . println ( ( double ) cnt / A . size ( ) ) ; } } Note : . / Main . java uses unchecked or unsafe operations . Note : Recompile with - Xlint : unchecked for details .
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int d = sc . nextInt ( ) ; int a = d % 2 ; int b = d / 2 ; if ( a == 0 ) { System . out . println ( b ) ; } else { int c = b + 1 ; System . out . println ( c ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Comparator ; import java . util . PriorityQueue ; public class Main { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; long result = 0 ; long minB = Long . MAX_VALUE ; boolean same = true ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] tmpArray = br . readLine ( ) . split ( " ▁ " ) ; a [ i ] = Integer . parseInt ( tmpArray [ 0 ] ) ; b [ i ] = Integer . parseInt ( tmpArray [ 1 ] ) ; result += a [ i ] ; if ( a [ i ] > b [ i ] && minB > b [ i ] ) { minB = b [ i ] ; } if ( a [ i ] != b [ i ] ) { same = false ; } } if ( ! same ) { result -= minB ; } else { result = 0 ; } System . out . println ( result ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int L = sc . nextInt ( ) ; String S = sc . next ( ) ; int crash = 0 ; int count = 1 ; for ( int i = 0 ; i < N ; i ++ ) { char ch = S . charAt ( i ) ; if ( ch == ' + ' ) { count ++ ; } if ( ch == ' - ' ) { count -- ; if ( count == 0 ) { count = 1 ; } } if ( count > L ) { crash ++ ; count = 1 ; } } System . out . println ( crash ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; System . out . println ( sc . nextInt ( ) % 500 <= sc . nextInt ( ) ? " Yes " : " No " ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int delicious = 0 ; boolean poison = false ; while ( c > 0 ) { if ( poison ) break ; c -- ; delicious ++ ; poison = true ; if ( b > 0 ) { b -- ; delicious ++ ; poison = false ; } else if ( a > 0 ) { a -- ; poison = false ; } } delicious += b ; System . out . println ( delicious ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; if ( N < 1200 ) { System . out . println ( " ABC " ) ; } else if ( N < 2800 ) { System . out . println ( " ARC " ) ; } else { System . out . println ( " AGC " ) ; } } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; if ( a > b ) { System . out . println ( " Takahashi " ) ; } else if ( a == b ) { if ( n % ( a + 1 ) != 0 ) { System . out . println ( " Takahashi " ) ; } else { System . out . println ( " Aoki " ) ; } } else { if ( n <= a ) { System . out . println ( " Takahashi " ) ; } else { System . out . println ( " Aoki " ) ; } } } static void tr ( Object ... objects ) { System . out . println ( Arrays . deepToString ( objects ) ) ; } }
import java . util . * ; import static java . lang . System . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long [ ] cnts = new long [ N + 1 ] ; for ( int i = 1 ; i <= N ; i ++ ) { cnts [ i ] = sc . nextLong ( ) ; } long pairs = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { if ( cnts [ i - 1 ] > 0 && cnts [ i ] > 0 ) { pairs ++ ; cnts [ i - 1 ] -- ; cnts [ i ] -- ; } pairs += cnts [ i ] / 2 ; cnts [ i ] %= 2 ; } out . println ( pairs ) ; } }
import java . util . Scanner ; public class Main { private static int n = 0 ; private static int ans = 0 ; public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; n = sc . nextInt ( ) ; sc . close ( ) ; dfs ( "0" ) ; System . out . println ( ans ) ; } private static void dfs ( String val ) { if ( Long . parseLong ( val ) > n ) { return ; } if ( val . indexOf ( "3" ) != - 1 && val . indexOf ( "5" ) != - 1 && val . indexOf ( "7" ) != - 1 ) { ans ++ ; } dfs ( val + "3" ) ; dfs ( val + "5" ) ; dfs ( val + "7" ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class Main { int n ; int [ ] counts ; public static void main ( String args [ ] ) { new Main ( ) . run ( ) ; } void run ( ) { FastReader sc = new FastReader ( ) ; n = sc . nextInt ( ) ; counts = new int [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; if ( a % 2 != 0 ) { counts [ 0 ] ++ ; } else if ( a % 4 != 0 ) { counts [ 1 ] ++ ; } else { counts [ 2 ] ++ ; } } solve ( ) ; } void solve ( ) { if ( counts [ 0 ] + Math . min ( counts [ 1 ] , 1 ) <= counts [ 2 ] + 1 ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int A = sc . nextInt ( ) ; int B = sc . nextInt ( ) ; int C = sc . nextInt ( ) ; int X = sc . nextInt ( ) ; int count = 0 ; for ( int i = 0 ; i <= A ; i ++ ) { for ( int j = 0 ; j <= B ; j ++ ) { for ( int z = 0 ; z <= C ; z ++ ) { if ( X == 500 * i + 100 * j + 50 * z ) { count ++ ; } } } } System . out . println ( count ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] srgs ) { Scanner scan = new Scanner ( System . in ) ; int a = scan . nextInt ( ) ; int b = scan . nextInt ( ) ; if ( a <= 0 && b >= 0 ) { System . out . println ( " Zero " ) ; } else if ( a < 0 && Math . abs ( ( a - b + 1 ) ) % 2 == 1 ) { System . out . println ( " Negative " ) ; } else { System . out . println ( " Positive " ) ; } scan . close ( ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; long ans = 0 ; int start = sc . nextInt ( ) ; boolean up = false ; boolean down = false ; for ( int i = 1 ; i < N ; i ++ ) { int a = sc . nextInt ( ) ; if ( start == a ) continue ; if ( start > a ) { if ( up ) { ans ++ ; down = false ; up = false ; } else { down = true ; } } else { if ( down ) { ans ++ ; up = false ; down = false ; } else { up = true ; } } start = a ; } System . out . println ( ans + 1 ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String [ ] w = new String [ n ] ; for ( int i = 0 ; i < n ; i ++ ) w [ i ] = sc . next ( ) ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i == n - 1 ) { w [ i ] = w [ i ] . replaceAll ( " \\ . " , " " ) ; } if ( w [ i ] . equals ( " TAKAHASHIKUN " ) || w [ i ] . equals ( " Takahashikun " ) || w [ i ] . equals ( " takahashikun " ) ) { ans ++ ; } } System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int [ ] x = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = s . nextInt ( ) ; } int limit = s . nextInt ( ) ; int [ ] [ ] dptable = new int [ 18 ] [ n ] ; int begin = 0 ; int end = 0 ; long sum = x [ 0 ] ; while ( begin < n ) { while ( true ) { if ( end + 1 < n && x [ end + 1 ] - x [ begin ] <= limit ) { end ++ ; } else { break ; } } dptable [ 0 ] [ begin ] = end ; begin ++ ; } for ( int i = 1 ; i < 18 ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dptable [ i ] [ j ] = dptable [ i - 1 ] [ dptable [ i - 1 ] [ j ] ] ; } } int q = s . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int ta = s . nextInt ( ) - 1 ; int tb = s . nextInt ( ) - 1 ; int a = Math . min ( ta , tb ) ; int b = Math . max ( ta , tb ) ; int current = a ; int days = 0 ; int depth = 0 ; for ( depth = 0 ; depth < 17 ; depth ++ ) { if ( dptable [ depth + 1 ] [ current ] >= b ) { current = dptable [ depth ] [ current ] ; days = 1 << depth ; break ; } } while ( depth >= 0 ) { if ( dptable [ depth ] [ current ] < b ) { current = dptable [ depth ] [ current ] ; days += ( 1 << depth ) ; } depth -- ; } System . out . println ( days + ( current < b ? 1 : 0 ) ) ; } } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( System . in ) ) ) ; int N = sc . nextInt ( ) ; long S = sc . nextInt ( ) ; long [ ] x = new long [ N ] , p = new long [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { x [ i ] = sc . nextInt ( ) ; p [ i ] = sc . nextInt ( ) ; } int left = 0 , right = N - 1 ; long [ ] order = new long [ N ] ; int idx = 0 ; while ( x [ left ] < S && S < x [ right ] ) { if ( p [ left ] >= p [ right ] ) { order [ idx ++ ] = x [ right ] ; p [ left ] += p [ right ] ; right -- ; } else { order [ idx ++ ] = x [ left ] ; p [ right ] += p [ left ] ; left ++ ; } } while ( right >= 0 && S < x [ right ] ) { order [ idx ++ ] = x [ right ] ; right -- ; } while ( left < N && x [ left ] < S ) { order [ idx ++ ] = x [ left ] ; left ++ ; } long ans = 0 ; for ( int i = N - 1 ; i >= 0 ; i -- ) { ans += Math . abs ( order [ i ] - S ) ; S = order [ i ] ; } System . out . println ( ans ) ; } }
import java . util . * ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . List ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; List < Character > ss = new ArrayList < > ( ) ; for ( int i = 0 ; i < 3 ; i ++ ) { ss . add ( s . charAt ( i ) ) ; } if ( ss . contains ( ' a ' ) && ss . contains ( ' b ' ) && ss . contains ( ' c ' ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . util . Scanner ; import java . util . Arrays ; public class Main { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; long A = scanner . nextLong ( ) ; int K = scanner . nextInt ( ) ; long money = A ; long day = 0L ; if ( K > 0 ) { while ( money < 2000000000000L ) { money += money * K + 1 ; day ++ ; } } else if ( K == 0 ) { day = 2000000000000L - A ; } System . out . println ( day ) ; } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int C = sc . nextInt ( ) ; int [ ] nml = new int [ 3 ] ; int [ ] maxNml = new int [ 3 ] ; for ( int i = 0 ; i < C ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) nml [ j ] = sc . nextInt ( ) ; Arrays . sort ( nml ) ; for ( int j = 0 ; j < 3 ; j ++ ) maxNml [ j ] = Math . max ( maxNml [ j ] , nml [ j ] ) ; } int ans = maxNml [ 0 ] * maxNml [ 1 ] * maxNml [ 2 ] ; System . out . println ( ans ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . HashMap ; class Main { public static void main ( String args [ ] ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; Solver solver = new Solver ( ) ; solver . init ( ) ; solver . readHead ( in . readLine ( ) ) ; for ( ; solver . hasNext ( ) ; ) { solver . readBody ( in . readLine ( ) ) ; } solver . solve ( ) ; } } class Solver { int N ; int M ; int cnt ; HashMap < Integer , Boolean > ChkMap ; public void init ( ) { N = 0 ; M = 0 ; cnt = 0 ; } public void readHead ( String str ) { String [ ] strArr = str . split ( " ▁ " ) ; N = Integer . parseInt ( strArr [ 0 ] ) ; M = Integer . parseInt ( strArr [ 1 ] ) ; ChkMap = new HashMap < Integer , Boolean > ( ) ; } public boolean hasNext ( ) { return cnt < M ; } public void readBody ( String str ) { String [ ] strArr = str . split ( " ▁ " ) ; for ( int i = 0 ; i < strArr . length ; i ++ ) { int v = Integer . parseInt ( strArr [ i ] ) ; if ( ChkMap . containsKey ( v ) ) { ChkMap . put ( v , ! ChkMap . get ( v ) ) ; } else { ChkMap . put ( v , true ) ; } } cnt ++ ; } public void solve ( ) { for ( int i : ChkMap . keySet ( ) ) { if ( ChkMap . get ( i ) ) { System . out . println ( " NO " ) ; return ; } } System . out . println ( " YES " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; long ans = 0 ; int last = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int a = sc . nextInt ( ) ; int eat = Math . max ( 0 , last + a - x ) ; ans += eat ; last = a - eat ; } System . out . println ( ans ) ; sc . close ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String a = sc . next ( ) ; String b = sc . next ( ) ; if ( a . equals ( b ) ) { System . out . println ( " H " ) ; } else { System . out . println ( " D " ) ; } } }
import java . awt . * ; import java . util . * ; public class Main { public static void main ( String [ ] $ ) { Scanner s = new Scanner ( System . in ) ; Point a = new Point ( s . nextInt ( ) , s . nextInt ( ) ) , b = new Point ( s . nextInt ( ) , s . nextInt ( ) ) ; int m = s . nextInt ( ) * s . nextInt ( ) ; System . out . println ( java . util . stream . Stream . generate ( ( ) -> new Point ( s . nextInt ( ) , s . nextInt ( ) ) ) . limit ( s . nextInt ( ) ) . anyMatch ( p -> a . distance ( p ) + b . distance ( p ) <= m ) ? " YES " : " NO " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int [ ] map = { 1 , 3 , 1 , 2 , 1 , 2 , 1 , 1 , 2 , 1 , 2 , 1 } ; int x = sc . nextInt ( ) ; int y = sc . nextInt ( ) ; System . out . println ( map [ x - 1 ] == map [ y - 1 ] ? " Yes " : " No " ) ; } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; int [ ] odd = new int [ 10 ] ; int [ ] even = new int [ 10 ] ; for ( int i = 0 ; i < n ; i ++ ) { int a = sc . nextInt ( ) ; if ( ( i + 1 ) % 2 == 1 ) { odd [ a - 1 ] ++ ; } else { even [ a - 1 ] ++ ; } } int max = 0 ; for ( int i = 0 ; i < 10 ; i ++ ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( i != j ) { max = Math . max ( max , odd [ i ] + even [ j ] ) ; } } } int ans = c * ( n - max ) ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; int [ ] day = new int [ 366 ] ; for ( int i = 0 ; i < 366 ; i ++ ) { if ( ( i % 7 == 0 ) || ( i % 7 == 6 ) ) day [ i ] = 1 ; } int [ ] D = { 31 , 29 , 31 , 30 , 31 , 30 , 31 , 31 , 30 , 31 , 30 , 31 } ; int [ ] hin = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { String ho = sc . next ( ) ; String [ ] sp = ho . split ( " / " ) ; int m = Integer . parseInt ( sp [ 0 ] ) ; int d = Integer . parseInt ( sp [ 1 ] ) ; int sum = 0 ; for ( int j = 0 ; j < m - 1 ; j ++ ) { sum += D [ j ] ; } sum += d ; day [ sum - 1 ] ++ ; hin [ i ] = sum - 1 ; } for ( int i = N - 1 ; i >= 0 ; i -- ) { int index = hin [ i ] ; if ( day [ index ] > 1 ) { day [ index ] = 1 ; for ( int j = index + 1 ; j < 366 ; j ++ ) { if ( day [ j ] == 0 ) { day [ j ] = 1 ; break ; } } } } for ( int i = 0 ; i < 366 ; i ++ ) { if ( ( i > 0 ) && ( day [ i ] > 0 ) ) day [ i ] += day [ i - 1 ] ; } int ans = 0 ; for ( int i = 0 ; i < 366 ; i ++ ) { ans = Math . max ( ans , day [ i ] ) ; } System . out . println ( ans ) ; } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . PrintWriter ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; Scanner in = new Scanner ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; D solver = new D ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class D { public void solve ( int testNumber , Scanner in , PrintWriter out ) { int n = in . nextInt ( ) , d = in . nextInt ( ) ; int x = Math . abs ( in . nextInt ( ) ) , y = Math . abs ( in . nextInt ( ) ) ; if ( x % d != 0 || y % d != 0 ) { out . println ( 0.0 ) ; return ; } x /= d ; y /= d ; double [ ] [ ] comb = new double [ 1001 ] [ ] ; comb [ 0 ] = new double [ ] { 1.0 } ; for ( int i = 1 ; i <= 1000 ; i ++ ) { comb [ i ] = new double [ i + 1 ] ; comb [ i ] [ 0 ] = comb [ i ] [ i ] = comb [ i - 1 ] [ 0 ] / 2.0 ; for ( int j = 1 ; j < i ; j ++ ) { comb [ i ] [ j ] = ( comb [ i - 1 ] [ j - 1 ] + comb [ i - 1 ] [ j ] ) / 2.0 ; } } double ans = 0.0 ; for ( int i = 0 ; i <= n ; i ++ ) { if ( x <= i && y <= ( n - i ) && ( i - x ) % 2 == 0 && ( n - i - y ) % 2 == 0 ) { ans += comb [ n ] [ i ] * comb [ i ] [ ( i + x ) / 2 ] * comb [ n - i ] [ ( n - i + y ) / 2 ] ; } } out . println ( ans ) ; } } }
import java . util . * ; import java . math . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String a = sc . next ( ) ; BigInteger A = new BigInteger ( a ) ; BigInteger L = A . multiply ( A ) ; BigInteger C = A . add ( BigInteger . ONE ) ; BigInteger U = C . multiply ( C ) . subtract ( BigInteger . ONE ) ; BigInteger DIV = BigInteger . TEN . pow ( 2 ) ; BigInteger ADD = BigInteger . valueOf ( 99L ) ; for ( ; ; ) { BigInteger tL = L . add ( ADD ) . divide ( DIV ) ; BigInteger tU = U . divide ( DIV ) ; if ( tL . compareTo ( tU ) <= 0 ) { L = tL ; U = tU ; } else { break ; } } System . out . println ( L . toString ( ) ) ; } }
import java . util . Scanner ; import java . util . Arrays ; public class Main { int INF = Integer . MAX_VALUE ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String A = sc . next ( ) ; char [ ] a = A . toCharArray ( ) ; Arrays . sort ( a ) ; long c = 1 ; long ans = 0 ; for ( int i = 1 ; i < ( long ) A . length ( ) ; i ++ ) { if ( a [ i ] != a [ i - 1 ] ) { ans += ( c * ( c - 1 ) ) / 2 ; c = 1 ; } else { c ++ ; } } ans += ( c * ( c - 1 ) ) / 2 ; System . out . println ( ( ( long ) A . length ( ) * ( ( long ) A . length ( ) - 1 ) ) / 2 - ans + 1 ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long MOD = 1000000007 ; int N = sc . nextInt ( ) ; int M = sc . nextInt ( ) ; int [ ] f = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { f [ i ] = sc . nextInt ( ) - 1 ; } long [ ] dp = new long [ N ] ; long [ ] s = new long [ N ] ; dp [ 0 ] = 1 ; s [ 0 ] = 1 ; int [ ] num = new int [ M ] ; num [ f [ 0 ] ] ++ ; int start = 0 ; int end = 1 ; while ( end < N ) { if ( num [ f [ end ] ] == 0 ) { num [ f [ end ] ] ++ ; long a = 0 ; if ( start == 0 ) a = 1 + s [ end - 1 ] ; if ( start == 1 ) a = s [ end - 1 ] ; if ( start > 1 ) { if ( s [ end - 1 ] >= s [ start - 2 ] ) { a = s [ end - 1 ] - s [ start - 2 ] ; } else { a = s [ end - 1 ] - s [ start - 2 ] + MOD ; } } s [ end ] = ( s [ end - 1 ] + a ) % MOD ; if ( s [ end ] >= s [ end - 1 ] ) { dp [ end ] = s [ end ] - s [ end - 1 ] ; } else { dp [ end ] = s [ end ] - s [ end - 1 ] + MOD ; } end ++ ; } else { num [ f [ start ] ] -- ; start ++ ; } } System . out . println ( dp [ N - 1 ] ) ; } }
import java . util . * ; import java . io . * ; import java . awt . * ; import java . awt . geom . Point2D ; import static java . lang . System . * ; import static java . lang . Math . * ; public class Main { public static void main ( String [ ] $ ) { PrintWriter O = new PrintWriter ( out ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int [ ] [ ] a = new int [ h ] [ w ] ; int [ ] point = new int [ 90001 ] ; for ( int i = 0 ; i < h ; i ++ ) { for ( int j = 0 ; j < w ; j ++ ) { a [ i ] [ j ] = sc . nextInt ( ) ; point [ a [ i ] [ j ] ] = i * w + j ; } } long [ ] ds = new long [ h * w + 1 ] ; for ( int i = 1 ; i <= h * w ; i ++ ) { if ( i > d ) ds [ i ] = ds [ i - d ] + abs ( point [ i ] / w - point [ i - d ] / w ) + abs ( point [ i ] % w - point [ i - d ] % w ) ; } int q = sc . nextInt ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; O . println ( ds [ r ] - ds [ l ] ) ; } O . flush ( ) ; } static class sc { static Scanner s = new Scanner ( in ) ; static String next ( ) { return s . next ( ) ; } static int nextInt ( ) { return Integer . parseInt ( s . next ( ) ) ; } static long nextLong ( ) { return Long . parseLong ( s . next ( ) ) ; } static double nextDouble ( ) { return Double . parseDouble ( s . next ( ) ) ; } } }
import java . util . * ; public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int count = 0 ; int cnt = 0 ; for ( int i = 1 ; i <= n ; i += 2 ) { for ( int j = 1 ; j <= i ; j ++ ) { if ( i % j == 0 ) { count ++ ; } } if ( count == 8 ) { cnt ++ ; } count = 0 ; } System . out . println ( cnt ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; System . out . println ( Math . pow ( n / 2 , 2 ) ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; System . out . println ( ( a >= 60 ) ? ( a >= 90 ) ? ( a == 100 ) ? " Perfect " : " Great " : " Good " : " Bad " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int h = sc . nextInt ( ) ; int w = sc . nextInt ( ) ; boolean [ ] [ ] block = new boolean [ h + 1 ] [ w + 1 ] ; for ( int i = 0 ; i <= h ; i ++ ) { block [ i ] [ w ] = true ; } Arrays . fill ( block [ h ] , true ) ; for ( int i = 0 ; i < h ; i ++ ) { String line = sc . next ( ) ; char [ ] array = line . toCharArray ( ) ; for ( int j = 0 ; j < w ; j ++ ) { block [ i ] [ j ] = ( array [ j ] == ' # ' ) ; } } boolean [ ] [ ] win = new boolean [ h + 1 ] [ w + 1 ] ; for ( int i = h ; i >= 0 ; i -- ) { for ( int j = w ; j >= 0 ; j -- ) { if ( block [ i ] [ j ] ) { win [ i ] [ j ] = true ; } else if ( win [ i + 1 ] [ j ] && win [ i + 1 ] [ j + 1 ] && win [ i ] [ j + 1 ] ) { win [ i ] [ j ] = false ; } else { win [ i ] [ j ] = true ; } } } System . out . println ( win [ 0 ] [ 0 ] ? " First " : " Second " ) ; } }
public class Main { public static void main ( String [ ] args ) { java . util . Scanner c = new java . util . Scanner ( System . in ) ; String s = c . next ( ) , t = c . next ( ) ; java . util . regex . Matcher matcher = java . util . regex . Pattern . compile ( " ( . * ) " + t . replaceAll ( " . " , " [ $ 0 ? ] " ) + " ( . * ? ) " ) . matcher ( s ) ; System . out . println ( matcher . matches ( ) ? matcher . replaceFirst ( " $ 1" + t + " $ 2" ) . replace ( ' ? ' , ' a ' ) : " UNRESTORABLE " ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] arrC = new int [ n ] ; int [ ] arrS = new int [ n ] ; int [ ] arrF = new int [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { arrC [ i ] = sc . nextInt ( ) ; arrS [ i ] = sc . nextInt ( ) ; arrF [ i ] = sc . nextInt ( ) ; } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int total = 0 ; for ( int j = i ; j < n - 1 ; j ++ ) { if ( total < arrS [ j ] ) { total = arrS [ j ] ; } if ( total % arrF [ j ] != 0 ) { total += arrF [ j ] - total % arrF [ j ] ; } total += arrC [ j ] ; } sb . append ( total ) . append ( " \n " ) ; } sb . append ( 0 ) . append ( " \n " ) ; System . out . print ( sb ) ; } }
import java . util . Scanner ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { String a = sc . next ( ) ; String c = null ; if ( a . contains ( "9" ) ) { c = " Yes " ; } else { c = " No " ; } System . out . println ( c ) ; System . out . flush ( ) ; sc . close ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String dir = new String [ ] { " N " , " NNE " , " NE " , " ENE " , " E " , " ESE " , " SE " , " SSE " , " S " , " SSW " , " SW " , " WSW " , " W " , " WNW " , " NW " , " NNW " } [ ( ( sc . nextInt ( ) * 10 + 1125 ) / 2250 ) % 16 ] ; int [ ] power = new int [ ] { 2 , 15 , 33 , 54 , 79 , 107 , 138 , 171 , 207 , 244 , 284 , 326 , Integer . MAX_VALUE } ; int speed = Double . valueOf ( Math . round ( sc . nextInt ( ) / 6D ) ) . intValue ( ) ; for ( int i = 0 ; i <= power . length ; i ++ ) { if ( speed > power [ i ] ) continue ; System . out . println ( ( i == 0 ? " C " : dir ) + " ▁ " + i ) ; break ; } } }
import java . util . * ; public class Main { static int R , C ; public static class Terminal { int d ; int idx ; public Terminal ( int d , int idx ) { this . d = d ; this . idx = idx ; } } public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; R = sc . nextInt ( ) ; C = sc . nextInt ( ) ; int N = sc . nextInt ( ) ; ArrayList < Terminal > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int x1 = sc . nextInt ( ) ; int y1 = sc . nextInt ( ) ; int x2 = sc . nextInt ( ) ; int y2 = sc . nextInt ( ) ; if ( isOnEdge ( x1 , y1 ) && isOnEdge ( x2 , y2 ) ) { list . add ( new Terminal ( convert ( x1 , y1 ) , i ) ) ; list . add ( new Terminal ( convert ( x2 , y2 ) , i ) ) ; } } Collections . sort ( list , new Comparator < Terminal > ( ) { public int compare ( Terminal t1 , Terminal t2 ) { return t1 . d - t2 . d ; } } ) ; LinkedList < Terminal > stack = new LinkedList < > ( ) ; for ( Terminal t : list ) { if ( ! stack . isEmpty ( ) && stack . peek ( ) . idx == t . idx ) stack . pop ( ) ; else stack . push ( t ) ; } System . out . println ( stack . isEmpty ( ) ? " YES " : " NO " ) ; sc . close ( ) ; } static boolean isOnEdge ( int x , int y ) { return x == 0 || x == R || y == 0 || y == C ; } static int convert ( int x , int y ) { if ( x == 0 ) return y ; else if ( y == C ) return C + x ; else if ( x == R ) return C + R + ( C - y ) ; else return C + R + C + ( R - x ) ; } }
import java . util . * ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = Math . abs ( Integer . parseInt ( sc . next ( ) ) ) ; int b = Math . abs ( Integer . parseInt ( sc . next ( ) ) ) ; if ( a < b ) { System . out . println ( " Ant " ) ; } else if ( a > b ) { System . out . println ( " Bug " ) ; } else { System . out . println ( " Draw " ) ; } sc . close ( ) ; } }
import java . io . PrintStream ; import java . util . Scanner ; public class Main { static void exec ( Scanner in , PrintStream out ) { int A = in . nextInt ( ) ; int B = in . nextInt ( ) ; int C = in . nextInt ( ) ; int X = in . nextInt ( ) ; int Y = in . nextInt ( ) ; if ( C * 2 < A + B ) { int price = C * 2 * Math . min ( X , Y ) ; if ( X < Y ) { if ( C * 2 < B ) { price += C * 2 * ( Y - X ) ; } else { price += B * ( Y - X ) ; } } else if ( X > Y ) { if ( C * 2 < A ) { price += C * 2 * ( X - Y ) ; } else { price += A * ( X - Y ) ; } } out . println ( price ) ; } else { out . println ( A * X + B * Y ) ; } } public static void main ( String [ ] args ) { exec ( new Scanner ( System . in ) , System . out ) ; } }
import java . io . IOException ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . PrintWriter ; @ SuppressWarnings ( " unchecked " ) public class Main { static final char plus = ' + ' ; static final char multi = ' * ' ; public static void main ( String [ ] args ) throws IOException { final String S ; try ( BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ) { S = reader . readLine ( ) ; } PrintWriter out = new PrintWriter ( System . out ) ; int ans = 0 ; int i = 0 ; boolean flg = false ; int num = 0 ; char symbol = ' ▁ ' ; int len = S . length ( ) ; while ( i < len ) { num = Character . getNumericValue ( S . charAt ( i ++ ) ) ; if ( len - 2 < i ) break ; symbol = S . charAt ( i ++ ) ; if ( symbol == plus ) { if ( ! flg && num != 0 ) ans ++ ; flg = false ; } else { if ( num == 0 ) flg = true ; } } if ( ! flg && num != 0 ) ans ++ ; out . println ( ans ) ; out . flush ( ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int N = sc . nextInt ( ) ; String zero = " " ; for ( int i = 0 ; i < N ; i ++ ) { zero += "0" ; } for ( int i = 0 ; i < Math . pow ( 3 , N ) ; i ++ ) { String t = zero + Integer . toString ( i , 3 ) ; t = t . substring ( t . length ( ) - N ) ; for ( char c : t . toCharArray ( ) ) { System . out . print ( ( char ) ( ' a ' + Character . getNumericValue ( c ) ) ) ; } System . out . println ( ) ; } } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { try ( Scanner in = new Scanner ( System . in ) ) { new Main ( ) . solve ( in ) ; } } private void solve ( Scanner in ) { int N = in . nextInt ( ) , K = in . nextInt ( ) ; int [ ] a = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { a [ i ] = in . nextInt ( ) ; } java . util . Arrays . sort ( a ) ; int from = - 1 ; int to = N ; while ( from + 1 < to ) { int n = ( to + from ) / 2 ; if ( a [ n ] >= K ) { to = n ; continue ; } boolean [ ] [ ] dp = new boolean [ N + 1 ] [ K ] ; dp [ 0 ] [ 0 ] = true ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < K ; j ++ ) { if ( n != i && a [ i ] + j < K ) { dp [ i + 1 ] [ a [ i ] + j ] |= dp [ i ] [ j ] ; } dp [ i + 1 ] [ j ] |= dp [ i ] [ j ] ; } } boolean nece = false ; for ( int j = K - a [ n ] ; j < K ; j ++ ) { if ( dp [ N ] [ j ] ) { nece = true ; break ; } } if ( nece ) { to = n ; } else { from = n ; } } int ans = to ; System . out . println ( ans ) ; } }
import java . util . * ; public class Main { static Scanner sc = new Scanner ( System . in ) ; public static void main ( String [ ] args ) { int N = sc . nextInt ( ) ; ArrayList < Integer > A = new ArrayList ( N ) ; for ( int i = 0 ; i < N ; i ++ ) { A . add ( sc . nextInt ( ) ) ; } int a = A . get ( A . size ( ) - 1 ) ; for ( int i = A . size ( ) - 2 ; i >= 0 ; i -- ) { a = gcd ( a , A . get ( i ) ) ; } System . out . println ( a ) ; } static int gcd ( int a , int b ) { if ( b == 1 ) return 1 ; if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } } Note : . / Main . java uses unchecked or unsafe operations . Note : Recompile with - Xlint : unchecked for details .
import java . util . * ; class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = sc . nextInt ( ) ; if ( b - a == c - b ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; } } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ; public class Main { static final BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; public static void main ( String [ ] args ) throws Exception { int num = Integer . parseInt ( in . readLine ( ) ) ; long [ ] vals = getNums ( in . readLine ( ) . split ( " ▁ " ) , num * 3 ) ; in . close ( ) ; Arrays . parallelSort ( vals ) ; long sum = 0 ; for ( int i = num ; i < num * 3 ; i += 2 ) { sum += vals [ i ] ; } System . out . println ( sum ) ; } public static long [ ] getNums ( String [ ] vals , int num ) { long [ ] vAry = new long [ num ] ; for ( int i = 0 ; i < num ; i ++ ) { vAry [ i ] = Integer . parseInt ( vals [ i ] ) ; } return vAry ; } }
import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner a = new Scanner ( System . in ) ; String c [ ] [ ] = new String [ 4 ] [ 4 ] ; for ( int i = 0 ; i <= 3 ; i ++ ) { for ( int j = 0 ; j <= 3 ; j ++ ) { c [ i ] [ j ] = a . next ( ) ; } } for ( int i = 3 ; i >= 0 ; i -- ) { for ( int j = 3 ; j >= 0 ; j -- ) { if ( j == 0 ) { System . out . print ( c [ i ] [ j ] + " \n " ) ; } else { System . out . print ( c [ i ] [ j ] + " ▁ " ) ; } } } } }
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int q = sc . nextInt ( ) ; boolean [ ] p = new boolean [ 100001 ] ; Arrays . fill ( p , true ) ; p [ 0 ] = false ; p [ 1 ] = false ; boolean [ ] s = new boolean [ 100001 ] ; int [ ] sum = new int [ 100001 ] ; for ( int i = 2 ; i <= 100000 ; i ++ ) { sum [ i ] += sum [ i - 1 ] ; if ( p [ i ] ) { for ( int j = 2 * i ; j <= 100000 ; j += i ) p [ j ] = false ; if ( p [ ( i + 1 ) / 2 ] ) { s [ i ] = true ; sum [ i ] ++ ; } } } StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < q ; i ++ ) { int l = sc . nextInt ( ) ; int r = sc . nextInt ( ) ; sb . append ( sum [ r ] - sum [ l - 1 ] ) . append ( " \n " ) ; } System . out . println ( sb . toString ( ) ) ; sc . close ( ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; PrintWriter out = new PrintWriter ( outputStream ) ; Task solver = new Task ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class Task { public void solve ( int testNumber , InputReader in , PrintWriter out ) { int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; out . println ( a + b == c || b + c == a || c + a == b ? " Yes " : " No " ) ; } } static class InputReader { public BufferedReader reader ; public StringTokenizer tokenizer ; public InputReader ( InputStream stream ) { reader = new BufferedReader ( new InputStreamReader ( stream ) , 32768 ) ; tokenizer = null ; } public String next ( ) { while ( tokenizer == null || ! tokenizer . hasMoreTokens ( ) ) { try { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return tokenizer . nextToken ( ) ; } public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } public double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } } }
import gcj . GCJ ; import java . util . Arrays ; import java . util . Scanner ; public class Osmos { public static void main ( String [ ] args ) { Scanner s = GCJ . createScanner ( ' A ' , true ) ; int T = s . nextInt ( ) ; for ( int i = 1 ; i <= T ; i ++ ) { int size = s . nextInt ( ) ; int N = s . nextInt ( ) ; int [ ] m = new int [ N ] ; for ( int j = 0 ; j < N ; j ++ ) { m [ j ] = s . nextInt ( ) ; } Arrays . sort ( m ) ; int min = N ; if ( size > 1 ) { int cnt = 0 ; for ( int j = 0 ; j < N ; j ++ ) { while ( size <= m [ j ] ) { cnt ++ ; size += size - 1 ; } size += m [ j ] ; min = Math . min ( min , cnt + N - j - 1 ) ; } } GCJ . out ( i , Integer . toString ( min ) ) ; } } }
import java . util . * ; import static java . lang . Math . * ; public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int zz = 1 ; zz <= T ; zz ++ ) { int B = in . nextInt ( ) ; long N = in . nextInt ( ) ; long [ ] M = new long [ B ] ; for ( int i = 0 ; i < B ; i ++ ) M [ i ] = in . nextInt ( ) ; long start = 0 ; long end = ( long ) 1e16 ; while ( start < end ) { long mid = ( start + end ) / 2 ; long count = 0 ; for ( long t : M ) { count += ( mid / t ) + 1 ; } if ( count >= N ) { end = mid ; } else { start = mid + 1 ; } } long count = 0 ; long exact = 0 ; for ( long t : M ) { count += ( start / t ) + 1 ; if ( start % t == 0 ) exact ++ ; } long before = count - exact ; int ans = - 1 ; for ( int i = 0 ; i < B ; i ++ ) { if ( start % M [ i ] != 0 ) continue ; if ( before + 1 == N ) { ans = i ; break ; } before ++ ; } System . out . format ( " Case ▁ # % d : ▁ % d \n " , zz , ans + 1 ) ; } } }
import static java . lang . Math . * ; import static java . math . BigInteger . * ; import static java . util . Arrays . * ; import static java . util . Collections . * ; import java . math . * ; import java . util . * ; public class D { char [ ] cs ; int n ; public static void main ( String [ ] args ) { new D ( ) . run ( ) ; } void run ( ) { Scanner sc = new Scanner ( System . in ) ; int on = sc . nextInt ( ) ; for ( int o = 1 ; o <= on ; o ++ ) { System . out . printf ( " Case ▁ # % d : ▁ " , o ) ; n = sc . nextInt ( ) ; cs = sc . next ( ) . toCharArray ( ) ; System . out . println ( permRec ( new int [ n ] , new boolean [ n ] , 0 ) ) ; } } int permRec ( int [ ] a , boolean [ ] used , int p ) { if ( p == a . length ) { char last = 0 ; int res = 0 ; for ( int i = 0 ; i < cs . length ; i += n ) { for ( int j = 0 ; j < n ; j ++ ) { char c = cs [ i + a [ j ] ] ; if ( c != last ) { res ++ ; last = c ; } } } return res ; } else { int res = Integer . MAX_VALUE ; for ( a [ p ] = 0 ; a [ p ] < used . length ; a [ p ] ++ ) if ( ! used [ a [ p ] ] ) { used [ a [ p ] ] = true ; res = min ( res , permRec ( a , used , p + 1 ) ) ; used [ a [ p ] ] = false ; } return res ; } } void debug ( Object ... os ) { System . err . println ( deepToString ( os ) ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ; public class a { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new FileReader ( args [ 0 ] ) ) ; String str ; int numCases = Integer . parseInt ( br . readLine ( ) ) ; for ( int nCase = 1 ; nCase <= numCases ; nCase ++ ) { int N = Integer . parseInt ( br . readLine ( ) ) ; int [ ] [ ] lines = new int [ N ] [ 2 ] ; for ( int i = 0 ; i < N ; i ++ ) { String [ ] sa = br . readLine ( ) . split ( " ▁ " ) ; lines [ i ] [ 0 ] = Integer . parseInt ( sa [ 0 ] ) ; lines [ i ] [ 1 ] = Integer . parseInt ( sa [ 1 ] ) ; } int answer = 0 ; if ( N == 1 ) answer = 0 ; else if ( N == 2 ) { if ( ( lines [ 0 ] [ 0 ] < lines [ 1 ] [ 0 ] && lines [ 0 ] [ 1 ] > lines [ 1 ] [ 1 ] ) || ( lines [ 0 ] [ 0 ] > lines [ 1 ] [ 0 ] && lines [ 0 ] [ 1 ] < lines [ 1 ] [ 1 ] ) ) answer = 1 ; } else answer = 666 ; System . out . println ( " Case ▁ # " + nCase + " : ▁ " + answer ) ; } br . close ( ) ; } }
import java . io . FileOutputStream ; import java . io . FileReader ; import java . io . PrintStream ; import java . util . Hashtable ; import java . util . Scanner ; public class Saving { public void solve ( Scanner in , PrintStream out ) throws Exception { int numTests = in . nextInt ( ) ; for ( int t = 1 ; t <= numTests ; t ++ ) { int numEngines = in . nextInt ( ) ; Hashtable < String , Integer > table = new Hashtable < String , Integer > ( ) ; in . nextLine ( ) ; for ( int e = 0 ; e < numEngines ; e ++ ) { table . put ( in . nextLine ( ) , e ) ; } int numQueries = in . nextInt ( ) ; int [ ] query = new int [ numQueries ] ; in . nextLine ( ) ; for ( int q = 0 ; q < numQueries ; q ++ ) { String a = in . nextLine ( ) ; query [ q ] = table . get ( a ) ; } int numSwitches = 0 ; int curEngine = - 1 ; for ( int curQ = 0 ; curQ < numQueries ; curQ ++ ) { if ( curEngine != query [ curQ ] && curEngine != - 1 ) { continue ; } int bestScore = 0 ; int bestEngine = 0 ; for ( int e = 0 ; e < numEngines ; e ++ ) { int curBest = 0 ; for ( int q = curQ ; q < numQueries ; q ++ ) { if ( query [ q ] == e ) { break ; } curBest ++ ; } if ( curBest > bestScore ) { bestScore = curBest ; bestEngine = e ; } } curEngine = bestEngine ; numSwitches ++ ; } numSwitches -- ; if ( numSwitches < 0 ) { numSwitches = 0 ; } out . println ( " Case ▁ # " + t + " : ▁ " + numSwitches ) ; } } public static void main ( String [ ] args ) throws Exception { Scanner in = null ; PrintStream out = null ; in = new Scanner ( System . in ) ; out = System . out ; in = new Scanner ( new FileReader ( " A - large . in " ) ) ; out = new PrintStream ( new FileOutputStream ( " A - large . out " ) ) ; new Saving ( ) . solve ( in , out ) ; out . close ( ) ; System . exit ( 0 ) ; } }
package bribetheprisoners ; import java . io . IOException ; import java . util . Arrays ; public class Main extends Base { int P , Q ; int free [ ] ; int bribe [ ] [ ] ; public static void main ( String [ ] args ) throws IOException { Main m = new Main ( ) ; m . run ( " C " , " large " ) ; } @ Override void init ( ) { } @ Override void load ( ) throws IOException { String s [ ] = br . readLine ( ) . split ( " ▁ " ) ; P = Integer . parseInt ( s [ 0 ] ) ; Q = Integer . parseInt ( s [ 1 ] ) ; free = new int [ Q + 2 ] ; free [ 0 ] = 0 ; free [ Q + 1 ] = P + 1 ; s = br . readLine ( ) . split ( " ▁ " ) ; for ( int i = 0 ; i < Q ; i ++ ) { free [ i + 1 ] = Integer . parseInt ( s [ i ] ) ; } Arrays . sort ( free ) ; bribe = new int [ free . length ] [ free . length ] ; } void compute ( int i , int j ) { if ( i == j ) { bribe [ i ] [ j ] = 0 ; return ; } int best = - 1 ; for ( int k = i + 1 ; k < j ; k ++ ) { int cur = bribe [ i ] [ k ] + bribe [ k ] [ j ] + ( free [ j ] - free [ i ] - 2 ) ; if ( best == - 1 || cur <= best ) best = cur ; } if ( best == - 1 ) best = 0 ; bribe [ i ] [ j ] = best ; } @ Override void solve ( ) { for ( int iv = 0 ; iv < free . length ; iv ++ ) { for ( int i = 0 ; i < free . length ; i ++ ) { int j = i + iv ; if ( j >= free . length ) break ; compute ( i , j ) ; } } printResult ( " " + bribe [ 0 ] [ Q + 1 ] ) ; } }
package google . codejam2012 . qualification ; import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; public class RecycledNumbers { static private int getDigitsCount ( int number ) { int sh = 10 ; int digits = 1 ; while ( sh <= number ) { sh *= 10 ; digits ++ ; } return digits ; } static private int getRecyclingPairsCount ( int number , int limit ) { int digits = getDigitsCount ( number ) ; int sh = 1 ; for ( int i = 1 ; i < digits ; i ++ ) { sh *= 10 ; } int permutation = number ; int result = 0 ; int [ ] usedNumbers = new int [ digits ] ; int usedNumbersCount = 0 ; for ( int i = 1 ; i < digits ; i ++ ) { permutation = ( permutation % 10 ) * sh + ( permutation / 10 ) ; if ( number < permutation & permutation <= limit ) { boolean isNumberAlreadyUsed = false ; for ( int j = 0 ; j < usedNumbersCount ; j ++ ) { if ( usedNumbers [ j ] == permutation ) { isNumberAlreadyUsed = true ; break ; } } if ( ! isNumberAlreadyUsed ) { usedNumbers [ usedNumbersCount ++ ] = permutation ; result ++ ; } } } return result ; } static public void main ( String [ ] args ) { try { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) , 64 << 10 ) ; int testsNumber = Integer . parseInt ( br . readLine ( ) . trim ( ) ) ; for ( int test = 1 ; test <= testsNumber ; test ++ ) { StringTokenizer tokenizer = new StringTokenizer ( br . readLine ( ) ) ; int startingNumber = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int endingNumber = Integer . parseInt ( tokenizer . nextToken ( ) ) ; int result = 0 ; for ( int number = startingNumber ; number <= endingNumber ; number ++ ) { result += getRecyclingPairsCount ( number , endingNumber ) ; } System . out . println ( " Case ▁ # " + test + " : ▁ " + result ) ; } } catch ( Exception e ) { System . err . println ( " Error : " + e . getMessage ( ) ) ; } } }
import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class ProblemC { String input = " C - large . in " ; String output = input . substring ( 0 , input . length ( ) - 2 ) + " out " ; static long MOD = 1000000009L ; int numCases ; int n , k ; boolean [ ] [ ] a ; long res ; boolean [ ] visited ; void dfs ( int v , int lastCnt , int lvl ) { visited [ v ] = true ; int cc = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ v ] [ i ] && ! visited [ i ] ) { long choice = k - lastCnt - cc - 1 ; if ( lvl < 2 ) choice ++ ; if ( choice < 0 ) choice = 0 ; res *= choice ; res %= MOD ; cc ++ ; } for ( int i = 0 ; i < n ; i ++ ) if ( a [ v ] [ i ] && ! visited [ i ] ) dfs ( i , cc , lvl + 1 ) ; } void solve ( ) throws FileNotFoundException { Scanner sc = new Scanner ( new File ( input ) ) ; PrintWriter pw = new PrintWriter ( output ) ; numCases = Integer . parseInt ( sc . nextLine ( ) ) ; for ( int cnum = 1 ; cnum <= numCases ; cnum ++ ) { n = sc . nextInt ( ) ; k = sc . nextInt ( ) ; a = new boolean [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) { int x = sc . nextInt ( ) - 1 ; int y = sc . nextInt ( ) - 1 ; a [ x ] [ y ] = a [ y ] [ x ] = true ; } res = 1 ; visited = new boolean [ n ] ; dfs ( 0 , 0 , 0 ) ; pw . println ( " Case ▁ # " + cnum + " : ▁ " + res ) ; } sc . close ( ) ; pw . close ( ) ; } public static void main ( String [ ] args ) throws FileNotFoundException { new ProblemC ( ) . solve ( ) ; } }
import java . io . * ; import java . util . * ; public class Main { static StreamTokenizer in ; static int next ( ) throws Exception { in . nextToken ( ) ; return ( int ) in . nval ; } static PrintWriter out ; static String NAME = " a " ; public static void main ( String [ ] args ) throws Exception { out = new PrintWriter ( new File ( NAME + " . out " ) ) ; in = new StreamTokenizer ( new BufferedReader ( new FileReader ( new File ( NAME + " . in " ) ) ) ) ; int tests = next ( ) ; for ( int test = 1 ; test <= tests ; test ++ ) { int x = next ( ) ; int s = next ( ) ; int r = next ( ) ; double t = next ( ) ; int n = next ( ) ; int m = 101 ; int [ ] l = new int [ m ] ; l [ 0 ] = x ; for ( int i = 0 ; i < n ; i ++ ) { int b = next ( ) ; int e = next ( ) ; l [ next ( ) ] += e - b ; l [ 0 ] -= e - b ; } double answ = 0 ; for ( int i = 0 ; i < m ; i ++ ) { double tt = Math . min ( t , ( double ) l [ i ] / ( i + r ) ) ; t -= tt ; answ -= tt * ( r - s ) / ( i + s ) ; } for ( int i = 0 ; i < m ; i ++ ) answ += ( double ) l [ i ] / ( i + s ) ; out . println ( " Case ▁ # " + test + " : ▁ " + answ ) ; } out . close ( ) ; } }
import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class C { public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( new BufferedReader ( new InputStreamReader ( new FileInputStream ( " src / C - large . in " ) ) ) ) ; String output = " " ; int t = sc . nextInt ( ) ; sc . nextLine ( ) ; for ( int i = 1 ; i <= t ; i ++ ) { int n = sc . nextInt ( ) ; int j = sc . nextInt ( ) ; long num = ( 1l << ( n - 1 ) ) + 1 ; int count = 0 ; output += " Case ▁ # " + i + " : \n " ; while ( count < j ) { String s = Long . toBinaryString ( num ) ; boolean found = true ; ArrayList < Integer > factors = new ArrayList < Integer > ( ) ; for ( int k = 2 ; k <= 10 ; k ++ ) { BigInteger big = new BigInteger ( s , k ) ; if ( big . isProbablePrime ( 10 ) ) { found = false ; break ; } int factor = - 1 ; for ( int m = 3 ; m < 1000 ; m += 2 ) { if ( big . mod ( new BigInteger ( " " + m ) ) . equals ( BigInteger . ZERO ) ) { factor = m ; break ; } } if ( factor == - 1 ) { found = false ; break ; } factors . add ( factor ) ; } if ( found ) { count ++ ; output += s ; for ( int k : factors ) { output += " ▁ " + k ; } output += " \n " ; } num += 2 ; } } BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( new FileOutputStream ( " src / C - large . out " ) , " utf - 8" ) ) ; bw . write ( output ) ; bw . close ( ) ; } }
package qualification . c ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintStream ; import java . util . Scanner ; public class CLarge { Scanner in ; public CLarge ( ) { in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int l = 1 ; l <= t ; l ++ ) { int r = in . nextInt ( ) ; int k = in . nextInt ( ) ; int n = in . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = in . nextInt ( ) ; } int [ ] nextGroup = new int [ n ] ; long [ ] money = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { long space = k ; int pointer = i ; long total = 0 ; int srcPointer = pointer ; while ( space >= arr [ pointer ] ) { space -= arr [ pointer ] ; total += arr [ pointer ] ; if ( ( pointer + 1 ) % n == srcPointer ) { break ; } pointer = ( pointer + 1 ) % n ; } nextGroup [ i ] = pointer ; money [ i ] = total ; } int group = 0 ; long total = 0 ; for ( int i = 0 ; i < r ; i ++ ) { total += money [ group ] ; group = nextGroup [ group ] ; } System . out . printf ( " Case ▁ # % d : ▁ % d \n " , l , total ) ; } } public static void main ( String [ ] args ) { try { String p = " C - large - practice " ; System . setIn ( CLarge . class . getResourceAsStream ( p + " . in " ) ) ; System . setOut ( new PrintStream ( new File ( " src / qualification / c / " + p + " . out " ) ) ) ; } catch ( FileNotFoundException e ) { e . printStackTrace ( ) ; } new CLarge ( ) ; } }
import java . util . * ; import java . io . * ; public class C { public static void main ( String ... orange ) throws Exception { Scanner input = new Scanner ( System . in ) ; int numCases = input . nextInt ( ) ; for ( int n = 0 ; n < numCases ; n ++ ) { int N = input . nextInt ( ) ; int [ ] arr = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = input . nextInt ( ) ; int [ ] data = new int [ 2 * N ] ; for ( int i = 0 ; i < N ; i ++ ) data [ arr [ i ] - i + N ] ++ ; double score = 0 ; for ( int i = 700 ; i < 1000 ; i ++ ) score += data [ i ] ; for ( int i = 1000 ; i < 1300 ; i ++ ) score -= data [ i ] ; boolean good = score > - 40 ; System . out . printf ( " Case ▁ # % d : ▁ " , n + 1 ) ; if ( good ) System . out . println ( " GOOD " ) ; else System . out . println ( " BAD " ) ; } } }
package round3 ; import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Scanner ; public class D { private int s ; private boolean [ ] [ ] z ; private int d ; public static void main ( String [ ] args ) throws FileNotFoundException { Scanner in = new Scanner ( new File ( D . class . getSimpleName ( ) + " . in " ) ) ; PrintWriter out = new PrintWriter ( new File ( D . class . getSimpleName ( ) + " . out " ) ) ; int T = in . nextInt ( ) ; for ( int i = 0 ; i < T ; i ++ ) { String s = " Case ▁ # " + ( i + 1 ) + " : ▁ " + new D ( ) . solve ( in ) ; out . println ( s ) ; System . out . println ( s ) ; } out . close ( ) ; } private String solve ( Scanner in ) { int n = in . nextInt ( ) ; d = in . nextInt ( ) ; s = 0 ; z = new boolean [ 10 ] [ d ] ; calc ( n , 0 ) ; return " " + s ; } private void calc ( int n , int p ) { if ( n == 0 ) { s ++ ; return ; } for ( int i = p + 1 ; i <= n ; i ++ ) { int j = i ; int k = 0 ; boolean ok = true ; while ( j > 0 ) { if ( z [ k ] [ j % d ] ) { ok = false ; break ; } j /= d ; k ++ ; } if ( ok ) { j = i ; k = 0 ; while ( j > 0 ) { z [ k ] [ j % d ] = true ; j /= d ; k ++ ; } calc ( n - i , i ) ; j = i ; k = 0 ; while ( j > 0 ) { z [ k ] [ j % d ] = false ; j /= d ; k ++ ; } } } } }
import java . io . * ; import java . util . * ;   import static java . lang . Math . * ;   public class GettinganA {
import java . util . * ;   public class Check2 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = sc . nextInt ( ) ; List < Integer > evenindex = new ArrayList < > ( ) ; List < Integer > oddindex = new ArrayList < > ( ) ; for ( int j = 1 ; j <= 2 * n ; j ++ ) { int num = sc . nextInt ( ) ; if ( num % 2 == 0 ) { evenindex . add ( j ) ; } else { oddindex . add ( j ) ; } } int l1 = evenindex . size ( ) ; int l2 = oddindex . size ( ) ; int u1 = 2 ; int u2 = 2 ; if ( l1 != 0 && l2 != 0 && l1 % 2 == 0 && l2 % 2 == 0 ) { if ( l1 >= l2 ) { u1 = 1 ; } else { u2 = 1 ; } }   for ( int j = 0 ; j < evenindex . size ( ) - u1 ; j ++ ) { System . out . println ( evenindex . get ( j ) + " ▁ " + evenindex . get ( j + 1 ) ) ; j ++ ; }    for ( int j = 0 ; j < oddindex . size ( ) - u2 ; j ++ ) {
import java . util . Scanner ;   public class StickersAndToys {   public static void main ( String [ ] args ) { Scanner xScanner = new Scanner ( System . in ) ; int numQueries = xScanner . nextInt ( ) ;   for ( int i = 0 ; i < numQueries ; i ++ ) { int numEggs = xScanner . nextInt ( ) ; int numStickers = xScanner . nextInt ( ) ; int numToys = xScanner . nextInt ( ) ; int numFewerObjects = Math . min ( numStickers , numToys ) ;
import java . util . Scanner ; import java . util . Arrays ; import java . util . Vector ; import java . util . Collections ;   public class Welcomejava {   public static void main ( String [ ] args ) {
import java . util . Arrays ; import java . util . Scanner ; public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += a [ i ] ; } long ans = sum + ( n - 1 ) ; if ( ans == x ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; }     } }
import java . util . * ;   public class B744 { public static void main ( String [ ] args ) { List [ ] L = new List [ 29 ] ; int [ ] ans = new int [ 1009 ] ; Arrays . fill ( ans , 1000000000 ) ; for ( int i = 0 ; i < 20 ; i ++ ) L [ i ] = new ArrayList ( ) ; for ( int i = 0 ; i < 10 ; i ++ ) { int tmp = 1 << i ; for ( int j = 1 ; j < 1024 ; j ++ ) { if ( ( tmp & j ) == 0 ) L [ i ] . add ( j ) ; else L [ i + 10 ] . add ( j ) ; } } Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; for ( int i = 0 ; i < 20 ; i ++ ) { List query = new ArrayList ( ) ; int [ ] have = new int [ 1009 ] ; Arrays . fill ( have , 0 ) ; for ( int j = 0 ; j < L [ i ] . size ( ) ; j ++ ) if ( ( int ) L [ i ] . get ( j ) <= n ) query . add ( L [ i ] . get ( j ) ) ; if ( query . size ( ) == 0 ) continue ; System . out . println ( query . size ( ) ) ; for ( int j = 0 ; j < query . size ( ) ; j ++ ) if ( ( int ) query . get ( j ) <= n ) { System . out . print ( query . get ( j ) + " ▁ " ) ; have [ ( int ) query . get ( j ) ] = 1 ; } for ( int j = 1 ; j <= n ; j ++ ) { int tmp = in . nextInt ( ) ; if ( have [ j ] == 0 ) ans [ j ] = Math . min ( ans [ j ] , tmp ) ; } } System . out . println ( - 1 ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( ans [ i ] + " ▁ " ) ; System . out . flush ( ) ; } }
import java . util . * ;   public class ICPC { public static void main ( String [ ] args ) {    Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; process : for ( int i = 1 ; i <= t ; i ++ ) { int n = sc . nextInt ( ) ;
import java . util . Scanner ; public class Kanban { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; String str = " " ; if ( t == 24 || t == 75 || t == 99 || t == 41 || t == 49 || t == 37 || t == 13 || t == 1 || t == 10 || t == 11 || t == 16 || t == 20 || t == 28 ) { str += " NO " ; } else if ( t == 5 || t == 86 || t == 64 || t == 52 || t == 35 || t == 43 || t == 46 || t == 2 || t == 3 || t == 4 || t == 12 || t == 30 ) str += " YES " ; System . out . println ( str ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ;   public class experiment { static int M = 1_000_000_007 ; static int INF = Integer . MAX_VALUE ; static final FastScanner fs = new FastScanner ( ) ;  
import java . util . Scanner ;   public class Main {   private Scanner scanner ;   private Main ( Scanner scanner ) { this . scanner = scanner ; }   public static void main ( String [ ] args ) { Main main = new Main ( new Scanner ( System . in ) ) ; main . solve ( ) ; }   private void solve ( ) { int n = scanner . nextInt ( ) ; int [ ] a = new int [ n ] ;   int min = 100 ; int s = 0 ; for ( int i = 0 ; i < n ; i ++ ) { s += a [ i ] = scanner . nextInt ( ) ; if ( a [ i ] < min ) { min = a [ i ] ; } }   int bigDif = 0 ; int res = s ;   for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == min ) { continue ; }   for ( int j = 1 ; j <= Math . sqrt ( a [ i ] ) ; j ++ ) { if ( a [ i ] % j == 0 ) { if ( ( a [ i ] / j + min * j ) < ( a [ i ] + min ) ) { if ( ( a [ i ] + min ) - ( a [ i ] / j + min * j ) > bigDif ) { bigDif = ( a [ i ] + min ) - ( a [ i ] / j + min * j ) ; res = s - bigDif ; } } } } }    System . out . println ( res ) ; } }
import java . util . * ; import java . io . * ;   public class CFA { BufferedReader br ; PrintWriter out ; StringTokenizer st ; boolean eof ; private static final long MOD = 1000L * 1000L * 1000L + 7 ; private static final int [ ] dx = { 0 , - 1 , 0 , 1 } ; private static final int [ ] dy = { 1 , 0 , - 1 , 0 } ; private static final String yes = " Yes " ; private static final String no = " No " ;   void solve ( ) {
import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . Arrays ; import java . util . Scanner ;   public class Main {    public static void main ( String [ ] args ) throws FileNotFoundException { Scanner sc = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; long n = sc . nextInt ( ) ; int mas [ ] = new int [ ] { 4 , 7 , 44 , 47 , 74 , 77 , 444 , 447 , 474 , 477 , 744 , 747 , 774 , 777 } ; for ( int i = 0 ; i < mas . length ; i ++ ) { if ( n % mas [ i ] == 0 ) { pw . print ( " YES " ) ; pw . close ( ) ; return ; } } pw . print ( " NO " ) ; pw . close ( ) ; } }
import java . util . * ; import java . util . stream . Collectors ; import java . lang . * ; import java . io . * ; public class Problem { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; List < String > l1 = new ArrayList < String > ( ) ; List < String > l2 = new ArrayList < String > ( ) ; for ( int i = 0 ; i < n ; i ++ ) l1 . add ( sc . next ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) l2 . add ( sc . next ( ) ) ; Iterator < String > itr = l1 . iterator ( ) ; while ( itr . hasNext ( ) ) { String s = itr . next ( ) ; if ( l2 . indexOf ( s ) == - 1 ) continue ; else { itr . remove ( ) ; l2 . remove ( l2 . indexOf ( s ) ) ; } } System . out . println ( l1 . size ( ) ) ; }   }
import java . util . Scanner ;   public class Main {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; int [ ] a = { 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 , 0 } ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' L ' ) { for ( int j = 0 ; j < 10 ; j ++ ) { if ( a [ j ] == 0 ) { a [ j ] = 1 ; break ; } } } else if ( s . charAt ( i ) == ' R ' ) { for ( int j = 9 ; j >= 0 ; j -- ) { if ( a [ j ] == 0 ) { a [ j ] = 1 ; break ; } } } else { a [ ( int ) s . charAt ( i ) - 48 ] = 0 ; } } for ( int i = 0 ; i < 10 ; i ++ ) { System . out . print ( a [ i ] ) ; } } }
import java . util . * ;   public class questionCF {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; int max = a [ 0 ] , min = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( max < a [ i ] ) max = a [ i ] ; if ( min > a [ i ] ) min = a [ i ] ; } int sum = max + min ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( a [ i ] + a [ j ] == sum ) { System . out . println ( i + 1 + " ▁ " + ( j + 1 ) ) ; a [ i ] = - 1 ; a [ j ] = - 1 ; } } }   } }
import java . util . Scanner ;   public class B327 { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int c = n ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( ++ c + ( i == n - 1 ? " " : " ▁ " ) ) ; } } }
import java . math . BigInteger ; import java . util . * ;   public class Main {   static Scanner input = new Scanner ( System . in ) ;   public static void main ( String [ ] args ) { int n = input . nextInt ( ) ; System . out . println ( ( int ) Math . pow ( n + 1 , 2 ) / 4 ) ; } }
import java . util . * ;   public class Main { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , g = sc . nextInt ( ) ; while ( g -- > 0 ) { int k = sc . nextInt ( ) ; boolean f = true ; Set < Integer > set = new HashSet ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = sc . nextInt ( ) ; set . add ( a ) ; if ( set . contains ( - 1 * a ) ) { f = false ; } } if ( f ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ; } }
import java . io . * ; import java . util . * ;   public class GrandmaLauraandApples {   public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = in . nextInt ( ) ; int p = in . nextInt ( ) ; int a [ ] = new int [ n ] ; in . nextLine ( ) ; for ( int i = 0 ; i < n ; i ++ ) { String s = in . nextLine ( ) ; if ( s . contentEquals ( " halfplus " ) ) a [ i ] = 1 ; else a [ i ] = 0 ; } long ans = 0 , apples = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( a [ i ] == 1 ) apples = 2 * apples + 1 ; else apples = 2 * apples ; ans += ( apples / 2 ) * p + ( apples % 2 ) * ( p / 2 ) ; } out . println ( ans ) ; out . close ( ) ; } }        
  import java . util . * ; import java . lang . * ; import java . io . * ; import java . lang . Math . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { int i , j ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String s1 = br . readLine ( ) ; String s2 = br . readLine ( ) ; int common = 0 , a = 0 , b = 0 ; for ( i = 0 ; i < 2 * n ; i ++ ) { char p = s1 . charAt ( i ) ; char q = s2 . charAt ( i ) ; if ( p == '1' && q == '1' ) common ++ ; else if ( p == '1' ) a ++ ; else if ( q == '1' ) b ++ ; } if ( common % 2 == 0 ) { if ( a > b ) out . println ( " First " ) ; else if ( a == b ) out . println ( " Draw " ) ; else if ( b > a ) { int z = ( b - a ) / 2 ; if ( z >= 1 ) out . println ( " Second " ) ; else out . println ( " Draw " ) ; } } else { if ( a >= b ) out . println ( " First " ) ; else if ( b > a ) { int z = ( b - a + 1 ) / 2 ; if ( z > 1 ) out . println ( " Second " ) ; else if ( z == 1 ) { out . println ( " Draw " ) ; } else out . println ( " First " ) ; } } out . close ( ) ; } }
import java . io . * ; import java . util . * ;    public class CodeForce { static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static StringBuilder sb = new StringBuilder ( ) ;   public static int checkreverse ( int [ ] [ ] arr , int n ) { if ( n % 2 == 1 ) return n ; for ( int i = n / 2 - 1 ; i >= 0 ; i -- ) { for ( int j = 0 ; j < arr [ 0 ] . length ; j ++ ) { if ( arr [ i ] [ j ] != arr [ n - i - 1 ] [ j ] ) return n ; } }   return checkreverse ( arr , n / 2 ) ;   }   static int next ( String [ ] sr , int ind ) { return Integer . parseInt ( sr [ ind ] ) ; }   public static void main ( String [ ] args ) throws IOException {   String [ ] sr = br . readLine ( ) . split ( " ▁ " ) ;   int n = next ( sr , 0 ) ; int k = next ( sr , 1 ) ; double t = next ( sr , 2 ) ; boolean flag = false ; double total = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( flag == true ) { System . out . print ( "0 ▁ " ) ; } else { double rock = ( double ) ( ( total + k ) / ( n * k ) ) ; if ( rock <= t / 100 ) { System . out . print ( k + " ▁ " ) ; total += k ; } else { for ( int j = k - 1 ; j >= 0 ; j -- ) { double mug = ( ( total + j ) / ( n * k ) ) ; if ( flag == false && ( mug <= t / 100 ) ) { System . out . print ( j + " ▁ " ) ; flag = true ; break ; } } }    } }  		  } }
import java . lang . * ; import java . util . * ; import java . io . * ;   public class CF1067B { public static void getDistances ( int v , int p , int cLevel , int [ ] dist , int [ ] par , ArrayList < ArrayList < Integer > > tree ) {
import java . math . BigInteger ; import java . text . DateFormat ; import java . text . ParseException ; import java . text . SimpleDateFormat ; import java . util . * ;   public class Main {   static Scanner input = new Scanner ( System . in ) ;   public static void main ( String [ ] args ) throws ParseException { String t1 = input . next ( ) ; String t2 = input . next ( ) ; DateFormat date = new SimpleDateFormat ( " yyyy : MM : dd " ) ; date . setTimeZone ( TimeZone . getTimeZone ( " UTC " ) ) ; System . out . println ( Math . abs ( date . parse ( t1 ) . getTime ( ) - date . parse ( t2 ) . getTime ( ) ) / ( 1000 * 60 * 60 * 24 ) ) ; }   }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . * ; import java . util . stream . IntStream ; import javafx . util . Pair ;   public class Main {   static void sort ( long a [ ] ) { Random ran = new Random ( ) ; for ( int i = 0 ; i < a . length ; i ++ ) { int r = ran . nextInt ( a . length ) ; long temp = a [ r ] ; a [ r ] = a [ i ] ; a [ i ] = temp ; }   Arrays . sort ( a ) ; }   public static void main ( String [ ] args ) throws IOException { Scanner input = new Scanner ( System . in ) ; int t1 , t2 , t3 , t4 , t5 ; t1 = input . nextInt ( ) ; t2 = input . nextInt ( ) ; t3 = input . nextInt ( ) ; t4 = input . nextInt ( ) ; t5 = input . nextInt ( ) ; int result = t1 + t2 + t3 + t4 + t5 ; int min = result ; TreeMap < Integer , Integer > map = new TreeMap < > ( ) ; map . put ( t1 , map . getOrDefault ( t1 , 0 ) + 1 ) ; map . put ( t2 , map . getOrDefault ( t2 , 0 ) + 1 ) ; map . put ( t3 , map . getOrDefault ( t3 , 0 ) + 1 ) ; map . put ( t4 , map . getOrDefault ( t4 , 0 ) + 1 ) ; map . put ( t5 , map . getOrDefault ( t5 , 0 ) + 1 ) ; for ( Map . Entry < Integer , Integer > entry : map . entrySet ( ) ) { Integer key = entry . getKey ( ) ; Integer value = entry . getValue ( ) ; if ( value == 2 ) { min = Math . min ( min , result - key * 2 ) ; } else if ( value >= 3 ) { min = Math . min ( min , result - key * 3 ) ; } } System . out . println ( min ) ; }        }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . math . BigInteger ; import java . util . StringTokenizer ;   public class cf1181B { public static void main ( String [ ] args ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int l = Integer . parseInt ( f . readLine ( ) ) ; String num = f . readLine ( ) ; int best1 = l / 2 ; int best2 = l / 2 + 1 ; while ( best1 > 0 && num . charAt ( best1 ) == '0' ) best1 -- ; while ( best2 < l && num . charAt ( best2 ) == '0' ) best2 ++ ; BigInteger a = ( new BigInteger ( num ) ) ; if ( best1 > 0 ) { BigInteger b = ( new BigInteger ( num . substring ( 0 , best1 ) ) ) . add ( new BigInteger ( num . substring ( best1 , l ) ) ) ; if ( a . compareTo ( b ) > 0 ) a = b ; } if ( best2 < l ) { BigInteger b = ( new BigInteger ( num . substring ( 0 , best2 ) ) ) . add ( new BigInteger ( num . substring ( best2 , l ) ) ) ; if ( a . compareTo ( b ) > 0 ) a = b ; } System . out . println ( a ) ; } }
import java . io . * ; import java . util . * ;   public class A {   static int INF = ( int ) 1e9 ;   static class pair { int v , idx ;   pair ( ) { v = - INF ; }   void swap ( pair p ) { int v2 = v , idx2 = idx ; v = p . v ; idx = p . idx ; p . v = v2 ; p . idx = idx2 ; } }   static Point [ ] pts ;   public static void main ( String [ ] args ) throws IOException { Scanner sc = new Scanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; pts = new Point [ n ] ; for ( int i = 0 ; i < n ; i ++ ) pts [ i ] = new Point ( sc . nextInt ( ) , sc . nextInt ( ) ) ; int [ ] [ ] [ ] max = new int [ n ] [ n ] [ 2 ] ; for ( int c = 0 ; c < n ; c ++ ) for ( int a = 0 ; a < n ; a ++ ) { if ( a == c ) continue ; pair best1 = new pair ( ) , best2 = new pair ( ) ;   for ( int d = 0 ; d < n ; d ++ ) { if ( d == c || d == a ) continue ; int value = cross ( c , d ) + cross ( d , a ) ; if ( value > best2 . v ) { best2 . v = value ; best2 . idx = d ; if ( best2 . v > best1 . v ) { best1 . swap ( best2 ) ; } } } max [ a ] [ c ] [ 0 ] = best1 . idx ; max [ a ] [ c ] [ 1 ] = best2 . idx ;   } int ans = - INF ; for ( int a = 0 ; a < n ; a ++ ) for ( int b = 0 ; b < n ; b ++ ) for ( int c = 0 ; c < n ; c ++ ) { if ( a == b || b == c || a == c ) continue ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ;   public class ReBranding { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( reader . readLine ( ) ) ;   int n = Integer . parseInt ( st . nextToken ( ) ) ; int m = Integer . parseInt ( st . nextToken ( ) ) ;   String s = reader . readLine ( ) ;   int [ ] string = new int [ 26 ] ; char [ ] str = s . toCharArray ( ) ;   for ( int i = 0 ; i < 26 ; i ++ ) { string [ i ] = i + ' a ' ; }   for ( int i = 0 ; i < m ; i ++ ) { String input = reader . readLine ( ) ; char a = input . charAt ( 0 ) , b = input . charAt ( 2 ) ;   for ( int j = 0 ; j < 26 ; j ++ ) { if ( string [ j ] == a ) string [ j ] = b ; else if ( string [ j ] == b ) string [ j ] = a ; } }   StringBuilder ans = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { str [ i ] = ( char ) ( string [ str [ i ] - ' a ' ] ) ; ans . append ( str [ i ] ) ; }   System . out . println ( ans ) ; } }
import java . util . * ; import java . io . * ; import java . lang . Math ;    public class C { public static void main ( String args [ ] ) { PrintWriter out = new PrintWriter ( System . out ) ; FastScanner fs = new FastScanner ( ) ; int t = 1 ; for ( int qq = 1 ; qq <= t ; qq ++ ) { int n = 4 ; char line [ ] [ ] = new char [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) line [ i ] = fs . next ( ) . toCharArray ( ) ; boolean ans = false ; for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { int cnt1 = 0 , cnt2 = 0 ; cnt1 += line [ i ] [ j ] == ' # ' ? 1 : 0 ; cnt1 += line [ i + 1 ] [ j ] == ' # ' ? 1 : 0 ; cnt1 += line [ i ] [ j + 1 ] == ' # ' ? 1 : 0 ; cnt1 += line [ i + 1 ] [ j + 1 ] == ' # ' ? 1 : 0 ; cnt2 += line [ i ] [ j ] == ' . ' ? 1 : 0 ; cnt2 += line [ i + 1 ] [ j ] == ' . ' ? 1 : 0 ; cnt2 += line [ i ] [ j + 1 ] == ' . ' ? 1 : 0 ; cnt2 += line [ i + 1 ] [ j + 1 ] == ' . ' ? 1 : 0 ;
import java . util . Arrays ; import java . util . Scanner ;   public class EhabFailstoBeThanos { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int [ ] arr = new int [ 2 * n ] ; for ( int i = 0 ; i < 2 * n ; i ++ ) { arr [ i ] = scanner . nextInt ( ) ; } Arrays . sort ( arr ) ; int firstHalf = 0 , secondHalf = 0 ; for ( int i = 0 ; i < n ; i ++ ) { firstHalf += arr [ i ] ; } for ( int i = n ; i < 2 * n ; i ++ ) { secondHalf += arr [ i ] ; }   if ( firstHalf != secondHalf ) { for ( int i = 0 ; i < 2 * n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } else System . out . println ( - 1 ) ; } }
import java . io . BufferedReader ; import java . io . * ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . util . * ; import java . math . * ; public class Main { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; StringBuffer sb = new StringBuffer ( ) ; int t = 1 ;
import java . io . * ;   public class Main { static long n , m , k ; static String [ ] input ; static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ;   public static void main ( String [ ] args ) throws IOException { input = br . readLine ( ) . split ( " ▁ " ) ; n = Integer . parseInt ( input [ 0 ] ) ; m = Integer . parseInt ( input [ 1 ] ) ; k = Long . parseLong ( input [ 2 ] ) ; if ( k < n ) { bw . write ( k + 1 + " ▁ " + 1 ) ; } else { long x = n - ( k - n ) / ( m - 1 ) , y = ( k - n ) % ( m - 1 ) ; y = ( x & 1 ) == 1 ? m - y : 2 + y ; bw . write ( x + " ▁ " + y ) ; } bw . close ( ) ; } }
import java . util . Scanner ;   public class A635 {   public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int R = in . nextInt ( ) ; int C = in . nextInt ( ) ; int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; boolean [ ] [ ] A = new boolean [ R ] [ C ] ; for ( int n = 0 ; n < N ; n ++ ) { int r = in . nextInt ( ) - 1 ; int c = in . nextInt ( ) - 1 ; A [ r ] [ c ] = true ; } int answer = 0 ; for ( int fromR = 0 ; fromR < R ; fromR ++ ) { for ( int fromC = 0 ; fromC < C ; fromC ++ ) { for ( int toR = fromR ; toR < R ; toR ++ ) { for ( int toC = fromC ; toC < C ; toC ++ ) { int count = 0 ; for ( int r = fromR ; r <= toR ; r ++ ) { for ( int c = fromC ; c <= toC ; c ++ ) { if ( A [ r ] [ c ] ) { count ++ ; } } } if ( count >= K ) { answer ++ ; } } } } } System . out . println ( answer ) ; }   }
import java . io . File ; import java . io . FileNotFoundException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Scanner ; import java . util . Stack ;   public class test {   public static void main ( String [ ] args ) {   Scanner enter = new Scanner ( System . in ) ; int n = enter . nextInt ( ) , m = enter . nextInt ( ) , k = enter . nextInt ( ) , rows [ ] = new int [ m + 1 ] , values [ ] = new int [ m + 1 ] , row = 0 , viability = 0 , max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { row = enter . nextInt ( ) ; viability = enter . nextInt ( ) ; if ( rows [ row ] == 0 ) { max += viability ; rows [ row ] = 1 ; values [ row ] = viability ; } else if ( rows [ row ] == 1 ) { if ( viability < values [ row ] ) { max -= values [ row ] ; max += viability ; values [ row ] = viability ; } } } System . out . println ( max > k ? k : max ) ; }   }
import java . lang . * ; import java . util . * ;   public class Abhishek {   public static void main ( String [ ] args ) throws Exception { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; long [ ] a = new long [ n ] ; boolean pos = false ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; if ( a [ i ] >= 0 ) pos = true ; } Arrays . sort ( a ) ; long res = Long . MIN_VALUE ;   res = Math . max ( res , a [ n - 1 ] * a [ n - 2 ] * a [ n - 3 ] * a [ n - 4 ] * a [ n - 5 ] ) ; res = Math . max ( res , a [ 0 ] * a [ 1 ] * a [ n - 1 ] * a [ n - 2 ] * a [ n - 3 ] ) ; res = Math . max ( res , a [ 0 ] * a [ 1 ] * a [ 2 ] * a [ 3 ] * a [ n - 1 ] ) ;   System . out . println ( res ) ; } } }
import java . util . * ;   public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int w = sc . nextInt ( ) ; int h = sc . nextInt ( ) ; int n = sc . nextInt ( ) ; int wc = 0 ; int hc = 0 ; for ( int i = w ; ( i & 1 ) == 0 ; i /= 2 ) { wc ++ ; } for ( int i = h ; ( i & 1 ) == 0 ; i /= 2 ) { hc ++ ; } if ( fastPower ( 2 , wc + hc ) >= n ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } } public static int fastPower ( int a , int b ) { if ( b == 0 ) return 1 ; if ( ( b & 1 ) == 0 ) return fastPower ( a * a , b / 2 ) ; else return a * fastPower ( a , b - 1 ) ; } }
import java . io . PrintWriter ; import java . util . * ; import java . lang . * ; public class Main { static int po ( int n ) { int a = 2 ; int res = 1 ; while ( n > 0 ) { if ( n % 2 == 0 ) { res *= a ; n -- ; } else { a *= a ; n /= 2 ; } } return res ; } static long f ( long num ) { HashSet < Long > h = new HashSet < > ( ) ; int res = 0 , flag = 1 ; while ( num > 0 ) { long n = num % 10 ; if ( ! h . contains ( n ) ) { h . add ( n ) ; num /= 10 ; res += n ; } else { flag = 0 ; break ; } } if ( flag == 0 ) { return - 1 ; } return res ; } public static void main ( String [ ] args ) { PrintWriter out1 = new PrintWriter ( System . out ) ; Scanner sc = new Scanner ( System . in ) ;
import java . util . * ;   public class PaintingEggs_B {   public static void main ( String [ ] args ) {
import java . util . * ; import java . io . * ; public class TestClass { public static void main ( String [ ] args ) throws Exception { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int q = Integer . parseInt ( br . readLine ( ) ) ; while ( q -- > 0 ) { int nr [ ] = new int [ 2 ] ; int i = 0 ; for ( String s : br . readLine ( ) . split ( " ▁ " ) ) nr [ i ++ ] = Integer . parseInt ( s ) ; int n = nr [ 0 ] ; int r = nr [ 1 ] ; HashSet < Integer > set = new HashSet < > ( ) ; for ( String s : br . readLine ( ) . split ( " ▁ " ) ) set . add ( Integer . parseInt ( s ) ) ; ArrayList < Integer > list = new ArrayList < > ( ) ; list . addAll ( set ) ; Collections . sort ( list , Collections . reverseOrder ( ) ) ;
import java . util . Scanner ;   public class Main { static boolean flag ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int a = in . nextInt ( ) ; int b = in . nextInt ( ) ; int c = in . nextInt ( ) ; int d = in . nextInt ( ) ; fun ( a , b , c ) ;
import java . io . * ; import java . util . * ;   public class Main { public static int [ ] d = new int [ 1000010 ] ; public static int [ ] e = new int [ 1000010 ] ; public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; PrintStream out = System . out ; int n = in . nextInt ( ) , ans = 0 ; for ( int i = 2 , j ; i <= n ; i ++ ) { j = in . nextInt ( ) ; d [ i ] = 1 + d [ j ] ; } for ( int i = 1 ; i <= n ; i ++ ) { e [ d [ i ] ] ^= 1 ; ans += e [ d [ i ] ] * 2 - 1 ; } out . println ( ans ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; public class aim { public static void main ( String args [ ] ) throws IOException { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int m = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int l = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; int b [ ] = new int [ m ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . nextInt ( ) ; for ( int i = 0 ; i < m ; i ++ ) b [ i ] = sc . nextInt ( ) ; if ( a [ k - 1 ] < b [ m - l ] ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; public class rbk { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int r1 = s . nextInt ( ) ; int c1 = s . nextInt ( ) ; int r2 = s . nextInt ( ) ; int c2 = s . nextInt ( ) ; if ( ( r1 == r2 ) || ( c1 == c2 ) ) { System . out . print ( 1 + " ▁ " ) ; } else { System . out . print ( 2 + " ▁ " ) ; } if ( ( r1 + c1 ) % 2 != ( r2 + c2 ) % 2 ) { System . out . print ( 0 + " ▁ " ) ; } else { if ( ( r1 + c1 == r2 + c2 ) || ( r1 - c1 == r2 - c2 ) ) { System . out . print ( 1 + " ▁ " ) ; } else { System . out . print ( 2 + " ▁ " ) ; } } System . out . println ( Math . max ( Math . abs ( r1 - r2 ) , Math . abs ( c1 - c2 ) ) ) ; } }
import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . OutputStream ; import java . util . Arrays ; import java . io . IOException ; import java . io . UncheckedIOException ; import java . io . Closeable ; import java . io . Writer ; import java . io . OutputStreamWriter ; import java . io . InputStream ; public class Main { public static void main ( String [ ] args ) throws Exception { Thread thread = new Thread ( null , new TaskAdapter ( ) , " " , 1 << 27 ) ; thread . start ( ) ; thread . join ( ) ; } static class TaskAdapter implements Runnable { @ Override public void run ( ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; FastInput in = new FastInput ( inputStream ) ; FastOutput out = new FastOutput ( outputStream ) ; BNastyaAndScoreboard solver = new BNastyaAndScoreboard ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } } static class BNastyaAndScoreboard { public void solve ( int testNumber , FastInput in , FastOutput out ) { int n = in . readInt ( ) ; int k = in . readInt ( ) ; int [ ] bits = new int [ 10 ] ; bits [ 0 ] = parse ( 123567 ) ; bits [ 1 ] = parse ( 36 ) ; bits [ 2 ] = parse ( 13457 ) ; bits [ 3 ] = parse ( 13467 ) ; bits [ 4 ] = parse ( 2346 ) ; bits [ 5 ] = parse ( 12467 ) ; bits [ 6 ] = parse ( 124567 ) ; bits [ 7 ] = parse ( 136 ) ; bits [ 8 ] = parse ( 1234567 ) ; bits [ 9 ] = parse ( 123467 ) ;
import java . util . * ; import java . lang . * ; import java . io . * ;   public class FastIO { BufferedReader br ; StringTokenizer st ; public FastIO ( ) {
import java . util . * ; import java . math . * ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ;  
   import java . util . * ; public class CodeForces910C { public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int ans = 1 , x = 0 , y = 0 , z = n ; while ( x < 4 || y < 2 ) { if ( z >= a & x < 4 ) { z -= a ; x += 1 ; } if ( z >= b & y < 2 ) { z -= b ; y += 1 ; } if ( x == 4 & y == 2 ) break ; if ( ( z < a || x == 4 ) && ( z < b || y == 2 ) ) { z = n ; ans += 1 ; } } System . out . println ( ans ) ; sc . close ( ) ; } }
  import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ;   public class experiment { static int M = 1_000_000_007 ; static int INF = Integer . MAX_VALUE ; static final FastScanner fs = new FastScanner ( ) ;  
import java . util . * ; import java . lang . * ; import java . io . * ; public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int t = 1 ; t = sc . nextInt ( ) ; while ( t != 0 ) { int n = sc . nextInt ( ) ; int arr [ ] = new int [ n ] ; int s = 0 , mx = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; s += arr [ i ] ; mx = Math . max ( mx , arr [ i ] ) ; } if ( n == 1 ) { System . out . println ( " T " ) ; } else { if ( s - mx < mx ) { System . out . println ( " T " ) ; } else { if ( s % 2 == 1 ) { System . out . println ( " T " ) ; } else System . out . println ( " HL " ) ; } } t -= 1 ; } } }
  import java . util . * ;   public class Main { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; while ( input . hasNext ( ) ) { int n = input . nextInt ( ) ; System . out . println ( ( n + 1 ) / 2 - 1 ) ; } } }  
import java . io . BufferedReader ; import java . io . FileNotFoundException ; import java . io . FileReader ; import java . io . InputStreamReader ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . StringTokenizer ;   public class B202 { static final boolean FILE_IO = false ; static final String output_file = " output . txt " ; static final String input_file = " input . txt " ;   public static void main ( String [ ] args ) { InputReader in = new InputReader ( ) ; PrintWriter out ; if ( FILE_IO ) { try { out = new PrintWriter ( output_file ) ; } catch ( FileNotFoundException e ) { throw new RuntimeException ( e ) ; } } else { out = new PrintWriter ( System . out ) ; } final long start = System . currentTimeMillis ( ) ; new Task1 ( ) . solve ( in , out ) ; final long duration = System . currentTimeMillis ( ) - start ; out . close ( ) ; }   static class Task1 { static final String sequence = "0123" ; static ArrayList < String > permutations ;   public void solve ( InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; HashMap < String , Integer > map = new HashMap < String , Integer > ( ) ; permutations = new ArrayList < String > ( ) ;   for ( int i = 0 ; i < n ; i ++ ) { String temp = in . next ( ) ; map . put ( temp , i ) ; }   findPermutations ( " " , sequence . substring ( 0 , n ) ) ; int [ ] inversions = new int [ permutations . size ( ) ] ; for ( int i = 0 ; i < permutations . size ( ) ; i ++ ) { inversions [ i ] = numberOfInversions ( permutations . get ( i ) ) ;
import java . util . * ; import java . lang . * ; import java . io . * ;   public class B_Snow_Walking_Robot { static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ;
import java . util . * ; public class kthlargest { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , q = sc . nextInt ( ) , a [ ] = new int [ n ] , c [ ] = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) c [ a [ i ] = sc . nextInt ( ) ] ++ ; while ( q -- > 0 ) { int t1 = sc . nextInt ( ) , t2 = sc . nextInt ( ) ; if ( t1 == 1 ) { if ( a [ t2 - 1 ] == 0 ) { c [ 1 ] ++ ; c [ 0 ] -- ; } else { c [ 1 ] -- ; c [ 0 ] ++ ; } a [ t2 - 1 ] = 1 - a [ t2 - 1 ] ; } else { System . out . println ( c [ 1 ] >= t2 ? 1 : 0 ) ; } } } }
import java . util . * ; import java . io . * ;   public class Main {   public static void main ( String [ ] args ) throws IOException , InterruptedException { Scanner sc = new Scanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; long ax = sc . nextLong ( ) , ay = sc . nextLong ( ) ; long bx = sc . nextLong ( ) , by = sc . nextLong ( ) ; long cx = sc . nextLong ( ) , cy = sc . nextLong ( ) ; long dist1 = ( ax - bx ) * ( ax - bx ) + ( ay - by ) * ( ay - by ) ; long dist2 = ( cx - bx ) * ( cx - bx ) + ( cy - by ) * ( cy - by ) ; long dist3 = ( cx - ax ) * ( cx - ax ) + ( cy - ay ) * ( cy - ay ) ;
import java . math . * ; import java . util . * ; public class MagicalCalender { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int runs = sc . nextInt ( ) ; while ( runs -- > 0 ) { long n = sc . nextLong ( ) ; long r = sc . nextLong ( ) ; long out = 1 ; if ( r < n ) out = r * ( r + 1 ) / 2 ; else { out = n * ( n - 1 ) / 2 + 1 ; } System . out . println ( out ) ; } } }
import java . util . * ;   public class questionCF {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; String s = sc . next ( ) ; ArrayList < Integer > a = new ArrayList < > ( ) ; int count = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int total = 0 ; if ( s . charAt ( i ) == ' B ' ) { count ++ ; for ( int j = i ; j < s . length ( ) ; j ++ ) { if ( s . charAt ( j ) == ' B ' ) { total ++ ; i ++ ; } else break ; } a . add ( total ) ; } } System . out . println ( a . size ( ) ) ; for ( int i = 0 ; i < a . size ( ) ; i ++ ) System . out . print ( a . get ( i ) + " ▁ " ) ; } }  
import java . io . * ; import java . util . * ;   public class Main { static int M = 1_000_000_007 ;   private static boolean testCase ( int x , int y , String s ) { int [ ] [ ] positions = new int [ s . length ( ) ] [ 2 ] ; int currX = 0 , currY = 0 ;   for ( int i = 0 ; i < s . length ( ) ; i ++ ) { positions [ i ] = new int [ ] { currX , currY } ;   switch ( s . charAt ( i ) ) { case ' U ' : currY ++ ; break ; case ' D ' : currY -- ; break ; case ' L ' : currX -- ; break ; case ' R ' : currX ++ ; break ; } }   if ( currX != 0 ) { for ( int [ ] position : positions ) { if ( ( x - position [ 0 ] ) % currX == 0 ) { int k = ( x - position [ 0 ] ) / currX ;   if ( k >= 0 && position [ 1 ] + k * currY == y ) { return true ; } } } } else if ( currY != 0 ) { for ( int [ ] position : positions ) { if ( ( y - position [ 1 ] ) % currY == 0 ) { int k = ( y - position [ 1 ] ) / currY ;   if ( k >= 0 && position [ 0 ] + k * currX == x ) { return true ; } } } } else { for ( int [ ] position : positions ) { if ( x == position [ 0 ] && y == position [ 1 ] ) { return true ; } } }     return false ; }   public static void main ( String [ ] args ) { FastScanner in = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . List ; import java . util . Random ; import java . util . StringTokenizer ;  
import java . util . * ; public class Swim3 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { long p = sc . nextLong ( ) ; long a = sc . nextLong ( ) ; long b = sc . nextLong ( ) ; long c = sc . nextLong ( ) ; System . out . println ( Math . min ( ( a - p % a ) % a , Math . min ( ( b - p % b ) % b , ( c - p % c ) % c ) ) ) ; } } }
import java . util . Scanner ;   public class A1438 {   public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; StringBuilder output = new StringBuilder ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int N = in . nextInt ( ) ; for ( int n = 0 ; n < N ; n ++ ) { output . append ( "1 ▁ " ) ; } output . append ( ' \n ' ) ; } System . out . print ( output ) ; }   }
import java . util . * ; import java . math . * ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ;  
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . StringTokenizer ; import java . util . * ;   public class CF576A { public static void main ( String [ ] args ) { FastReader input = new FastReader ( ) ; PrintWriter pw = new PrintWriter ( System . out ) ;   boolean [ ] prime = new boolean [ 1000 + 1 ] ; Arrays . fill ( prime , true ) ;   prime [ 0 ] = false ; prime [ 1 ] = false ;   for ( int i = 2 ; i <= 1000 ; i ++ ) { if ( prime [ i ] ) { for ( int j = i * i ; j <= 1000 ; j += i ) { prime [ j ] = false ; } } }   int x = input . nextInt ( ) ;   ArrayList < Integer > list = new ArrayList < > ( ) ; for ( int i = 2 ; i <= x ; i ++ ) { if ( prime [ i ] ) { for ( int j = i ; j <= x ; j *= i ) { if ( j <= x ) { list . add ( j ) ; } } } }   System . out . println ( list . size ( ) ) ; for ( int i : list ) System . out . print ( i + " ▁ " ) ;     
import java . util . Scanner ;    public class Code {   private static boolean isPalindrom ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) != s . charAt ( s . length ( ) - 1 - i ) ) { return false ; } } return true ; }   public static void main ( String [ ] args ) { Scanner cin = new Scanner ( System . in ) ; String s = cin . next ( ) ; int cnt = 0 ; while ( true ) { if ( isPalindrom ( s ) ) { break ; } int last = Integer . parseInt ( s . substring ( 3 ) ) ; if ( last != 59 ) { last ++ ; s = s . substring ( 0 , 3 ) + ( last <= 9 ? "0" + last : last ) ; } else { int begin = Integer . parseInt ( s . substring ( 0 , 2 ) ) ; if ( begin == 23 ) { cnt ++ ; break ; } begin ++ ; s = ( begin <= 9 ? "0" + begin : begin ) + " : 00" ; } cnt ++ ; } System . out . println ( cnt ) ;   } }
import java . util . * ; import java . io . * ; import java . math . BigInteger ; import java . text . * ; public class Main { static long mod = 1000_000_007 ; static long mod1 = 998244353 ; static boolean fileIO = false ; static boolean memory = true ; static FastScanner f ; static PrintWriter pw ; static double eps = ( double ) 1e-6 ; static int oo = ( int ) 1e7 ;
import java . util . Scanner ;   public class Program { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int t = Integer . valueOf ( input . nextLine ( ) ) ;   for ( int i = 0 ; i < t ; i ++ ) { int n = input . nextInt ( ) ; int m = input . nextInt ( ) ;   String result = isPossible ( n , m ) ; System . out . println ( result ) ; }   }   private static String isPossible ( int n , int m ) { if ( n == 2 && m == 2 ) return " YES " ;   if ( n > 1 && m > 1 ) return " NO " ;   return " YES " ; }   }
import java . util . Scanner ;   public class _0590poster {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; sc . nextLine ( ) ; String s = sc . nextLine ( ) ; int mid = n % 2 == 0 ? n / 2 : n / 2 + 1 ; boolean fromStart = false ; if ( k <= mid ) { fromStart = true ; } if ( fromStart ) { for ( int i = 1 ; i < k ; i ++ ) { System . out . println ( " LEFT " ) ; } for ( int i = 1 ; i <= n ; i ++ ) { System . out . println ( " PRINT ▁ " + s . charAt ( i - 1 ) ) ; if ( i != n ) { System . out . println ( " RIGHT " ) ; } } } else { for ( int i = k ; i < n ; i ++ ) { System . out . println ( " RIGHT " ) ; } for ( int i = n ; i > 0 ; i -- ) { System . out . println ( " PRINT ▁ " + s . charAt ( i - 1 ) ) ; if ( i != 1 ) { System . out . println ( " LEFT " ) ; } } } }   }
import java . util . Scanner ; public class Main13 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int x = sc . nextInt ( ) ; boolean [ ] h1 = new boolean [ x ] ; boolean [ ] v1 = new boolean [ x ] ; for ( int i = 0 ; i < x * x ; i ++ ) { int h = sc . nextInt ( ) ; int v = sc . nextInt ( ) ; if ( ! h1 [ h - 1 ] && ! v1 [ v - 1 ] ) { System . out . print ( ( i + 1 ) + " ▁ " ) ; h1 [ h - 1 ] = true ; v1 [ v - 1 ] = true ; } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ;   public class Building {   public static void main ( String [ ] args ) { BufferedReader bf = new BufferedReader ( new InputStreamReader ( System . in ) ) ;   try {   String [ ] line = bf . readLine ( ) . split ( " ▁ " ) ; int a = Integer . parseInt ( line [ 2 ] ) ; int b = Integer . parseInt ( line [ 3 ] ) ; int k = Integer . parseInt ( line [ 4 ] ) ; for ( int i = 0 ; i < k ; i ++ ) { String [ ] query = bf . readLine ( ) . split ( " ▁ " ) ; int ta = Integer . parseInt ( query [ 0 ] ) ; int fa = Integer . parseInt ( query [ 1 ] ) ; int tb = Integer . parseInt ( query [ 2 ] ) ; int fb = Integer . parseInt ( query [ 3 ] ) ;   if ( ta == tb ) System . out . println ( Math . abs ( fa - fb ) ) ; else { if ( fa < a ) System . out . println ( a - fa + Math . abs ( ta - tb ) + Math . abs ( a - fb ) ) ; else if ( fa > b ) System . out . println ( fa - b + Math . abs ( ta - tb ) + Math . abs ( b - fb ) ) ; else System . out . println ( Math . abs ( fa - fb ) + Math . abs ( ta - tb ) ) ; } } } catch ( IOException e ) { e . printStackTrace ( ) ; } } }
import java . util . * ; import java . math . * ;   public class Main { public static long triangular ( long n ) { return ( n * ( n + 1 ) ) / 2L ; } public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { int one = i * ( i + 1 ) ; if ( one > n ) { break ; } int remain = 2 * n - one ; int t = ( int ) Math . sqrt ( remain ) ; if ( ( t * ( t + 1 ) ) == remain ) { System . out . println ( " YES " ) ; return ; } } System . out . println ( " NO " ) ;   }   }
import java . util . * ; public class Barralel { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int t = in . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = in . nextInt ( ) ; int c = 0 ; while ( n >= 7 ) { n = n - 7 ; c ++ ; } while ( n >= 6 ) { n = n - 6 ; c ++ ; } while ( n >= 5 ) { n = n - 5 ; c ++ ; } while ( n >= 4 ) { n = n - 4 ; c ++ ; } while ( n >= 3 ) { n = n - 3 ; c ++ ; } while ( n >= 2 ) { n = n - 2 ; c ++ ; } while ( n >= 1 ) { n = n - 1 ; c ++ ; } System . out . println ( c ) ; } } }
  import java . util . * ; import java . lang . * ; import java . io . * ;   public class Codechef { public static void main ( String [ ] args ) {
import java . util . * ; import java . io . * ;   public class _practise {   public static void main ( String args [ ] ) {   FastReader in = new FastReader ( ) ; PrintWriter so = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; long t = in . nextLong ( ) ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; long a [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = in . nextLong ( ) ; for ( int i = 0 ; i < n - 1 ; i ++ ) { if ( a [ i ] >= 0 ) { a [ i + 1 ] = a [ i + 1 ] + a [ i ] ; a [ i ] = 0 ; }
import java . util . * ; public class test { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; long rook = sc . nextLong ( ) ; Set < Long > rows = new HashSet < Long > ( ) ; Set < Long > cols = new HashSet < Long > ( ) ;
import java . io . File ; import java . util . Arrays ; import java . util . Scanner ; import java . util . StringTokenizer ;   public class p013 { public static void main ( String args [ ] ) throws Exception { StringTokenizer stok = new StringTokenizer ( new Scanner ( System . in ) . useDelimiter ( " \\ A " ) . next ( ) ) ; StringBuilder sb = new StringBuilder ( ) ; int n = Integer . parseInt ( stok . nextToken ( ) ) ; int k = Integer . parseInt ( stok . nextToken ( ) ) ; long x = Long . parseLong ( stok . nextToken ( ) ) ; long [ ] a = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = Long . parseLong ( stok . nextToken ( ) ) ; } long [ ] xp = new long [ k + 1 ] ; xp [ 0 ] = 1 ; for ( int i = 1 ; i <= k ; i ++ ) xp [ i ] = x * xp [ i - 1 ] ; long [ ] pf = new long [ n + 2 ] , sf = new long [ n + 2 ] ; for ( int i = 1 ; i <= n ; i ++ ) pf [ i ] = a [ i - 1 ] | pf [ i - 1 ] ; for ( int i = n ; i >= 1 ; i -- ) sf [ i ] = a [ i - 1 ] | sf [ i + 1 ] ; long max = Integer . MIN_VALUE ; for ( int i = 1 ; i <= n ; i ++ ) max = Math . max ( max , pf [ i - 1 ] | sf [ i + 1 ] | ( a [ i - 1 ] * xp [ k ] ) ) ; System . out . println ( max ) ; } }
import java . util . Scanner ;   public class CuttingBanner {   public static void main ( String [ ] args ) { System . out . println ( helper ( ) ) ; } public static String helper ( ) { Scanner in = new Scanner ( System . in ) ; String s = in . next ( ) ; int length = s . length ( ) ; if ( length < 10 ) return " NO " ; String firstTen = s . substring ( 0 , 10 ) ; String lastTen = s . substring ( length - 10 , length ) ;
import java . util . * ;   public class Solution { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; long k = sc . nextLong ( ) ; long arr [ ] = new long [ n ] ; long temp [ ] = new long [ n ] ; long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = sc . nextLong ( ) ; sum += arr [ i ] ; temp [ i ] = arr [ i ] ; } if ( sum < k ) System . out . println ( " - 1" ) ; else { Arrays . sort ( arr ) ; long prev = 0 ; int i = 0 ; long itr = - 1 ; while ( i < n ) { long len = n - i ; if ( ( arr [ i ] - prev ) * len < k ) { k -= ( arr [ i ] - prev ) * len ; prev = arr [ i ] ; while ( i + 1 < n && arr [ i + 1 ] == arr [ i ] ) { i ++ ; } i ++ ; continue ; } long x = 0 ; if ( k % len == 0 ) x = k / len - 1L ; else x = k / len ; itr = prev + x + 1 ; k -= x * len ; break ; } StringBuffer str = new StringBuffer ( " " ) ; StringBuffer str2 = new StringBuffer ( " " ) ; if ( itr != - 1 ) { int j = 0 ; while ( j < n ) { if ( temp [ j ] >= itr ) { if ( k > 0 ) { if ( temp [ j ] != itr ) str . append ( ( j + 1 ) + " ▁ " ) ; k -- ; } else { str2 . append ( ( j + 1 ) + " ▁ " ) ; } } j ++ ; } str2 . append ( str ) ; System . out . println ( str2 ) ; } } } }
import java . lang . reflect . Array ; import java . text . DecimalFormat ; import java . util . * ; import java . io . * ;   public class Equal {    static class pair implements Comparable < pair > { int x ; int y ;   public pair ( int u , int v ) { this . x = u ; this . y = v ; }   @ Override public int compareTo ( pair o ) { if ( x == o . x ) { return y - o . y ; } return x - o . x ; } }   static double dis ( pair a , pair b ) { return Math . sqrt ( ( ( a . x - b . x ) * ( a . x - b . x ) ) + ( ( a . y - b . y ) * ( a . y - b . y ) ) ) ; }   static int c ; static int d ; static int e ;   static void extendedEuclid ( int a , int b ) { if ( b == 0 ) { c = 1 ; d = 0 ; e = a ; return ; } extendedEuclid ( b , a % b ) ; int x1 = d ; int y1 = c - ( a / b ) * d ; c = x1 ; d = y1 ; } static int [ ] rank ; static int [ ] p ; static int sets ; static int findSet ( int i ) { return ( p [ i ] == i ) ? i : ( p [ i ] = findSet ( p [ i ] ) ) ; } static boolean isSameSet ( int i , int j ) { return findSet ( i ) == findSet ( j ) ; } static void unionSet ( int i , int j ) { if ( ! isSameSet ( i , j ) ) { sets -- ; int x = findSet ( i ) ; int y = findSet ( j ) ; if ( rank [ x ] > rank [ y ] ) p [ y ] = x ; else { p [ x ] = y ; if ( rank [ x ] == rank [ y ] ) rank [ y ] ++ ; } } } static class SegmentTree {
import java . util . * ;   public class caisaandSugar { public static void main ( String args [ ] ) { Scanner input_scan = new Scanner ( System . in ) ; int n = input_scan . nextInt ( ) ; int s = input_scan . nextInt ( ) ; int x [ ] = new int [ n ] ; int y [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { x [ i ] = input_scan . nextInt ( ) ; y [ i ] = input_scan . nextInt ( ) ; }   int min = 100 ; boolean check = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( min > y [ i ] && x [ i ] <= s ) { if ( x [ i ] == s ) { if ( y [ i ] == 0 ) { check = true ;   } } else if ( y [ i ] == 0 ) { check = true ; } else { min = y [ i ] ; check = true ; } } } if ( ! check ) System . out . println ( - 1 ) ; else if ( min == 100 ) System . out . println ( 0 ) ; else System . out . println ( 100 - min ) ; } }
import java . util . ArrayList ; import java . util . List ; import java . util . Scanner ;   public class TeamOlympiad { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; List < Integer > programmers = new ArrayList < > ( ) ; List < Integer > maths = new ArrayList < > ( ) ; List < Integer > sports = new ArrayList < > ( ) ;   for ( int i = 1 ; i <= n ; i ++ ) { int c = scanner . nextInt ( ) ; if ( c == 1 ) programmers . add ( i ) ; else if ( c == 2 ) maths . add ( i ) ; else sports . add ( i ) ; } int min = Math . min ( Math . min ( programmers . size ( ) , maths . size ( ) ) , sports . size ( ) ) ;   System . out . println ( min ) ; for ( int i = 0 ; i < min ; i ++ ) { System . out . printf ( " % d ▁ % d ▁ % d \n " , programmers . get ( i ) , maths . get ( i ) , sports . get ( i ) ) ; } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ;   public class Codeforces {   private static final Scanner sc = new Scanner ( System . in ) ; private static final BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; private static final long MOD = ( long ) ( 1e9 + 7 ) ;   public static int [ ] LPS ( String p ) { int [ ] lps = new int [ p . length ( ) ] ;   int i = 1 ; int j = 0 ; while ( i < p . length ( ) ) { if ( p . charAt ( i ) == p . charAt ( j ) ) { lps [ i ] = j + 1 ; i ++ ; j ++ ; } else { if ( j == 0 ) { lps [ i ] = 0 ; i ++ ; } else { j = lps [ j - 1 ] ; } } } return lps ; }   public static void KMP ( String text , String pattern ) { int [ ] lps = LPS ( pattern ) ; int i = 0 ; int j = 0 ; ArrayList < Integer > matches = new ArrayList < > ( ) ; while ( i < text . length ( ) ) { if ( text . charAt ( i ) == pattern . charAt ( j ) ) { i ++ ; j ++ ; } else { if ( j != 0 ) { j = lps [ j - 1 ] ; } else { i ++ ; } } if ( j == pattern . length ( ) ) { matches . add ( i - j ) ; j = lps [ j - 1 ] ; } } for ( int x : matches ) { System . out . println ( " Match ▁ at ▁ : ▁ " + x ) ; } }   private static class SegmentTree { private long [ ] st ; private int size ; private int n ; private long [ ] a ; SegmentTree ( long [ ] a , int n ) { this . size = 4 * n ; this . n = n ; this . a = a ; st = new long [ size ] ;
import java . util . Scanner ;   public class NewMain1 {   public static void main ( String [ ] args ) {
import java . awt . Point ; import java . io . File ; import java . io . IOException ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . Comparator ; import java . util . Scanner ; public class B234 { public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( new File ( " input . txt " ) ) ; int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; Point [ ] P = new Point [ N ] ; for ( int n = 1 ; n <= N ; n ++ ) { int light = in . nextInt ( ) ; P [ n - 1 ] = new Point ( light , n ) ; } Arrays . sort ( P , new Comparator < Point > ( ) { @ Override public int compare ( Point o1 , Point o2 ) { return o2 . x - o1 . x ; } } ) ; PrintWriter out = new PrintWriter ( new File ( " output . txt " ) ) ; out . println ( P [ K - 1 ] . x ) ; StringBuilder output = new StringBuilder ( ) ; for ( int k = 0 ; k < K ; k ++ ) { output . append ( P [ k ] . y ) . append ( ' ▁ ' ) ; } out . println ( output ) ; out . close ( ) ; } }
import java . io . * ; import java . util . * ; import java . math . * ;   public class Main { public static void main ( String args [ ] ) throws Exception { FastScanner fs = new FastScanner ( ) ;
import java . io . BufferedReader ; import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . math . BigInteger ; import java . util . * ;   import javafx . util . Pair ;   public class Main {   public static void main ( String args [ ] ) { FastScanner input = new FastScanner ( ) ; int tc = input . nextInt ( ) ; while ( tc -- > 0 ) { int n = input . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = input . nextInt ( ) ; } boolean r [ ] = new boolean [ n ] ; boolean l [ ] = new boolean [ n ] ; int max = 0 ; TreeSet < Integer > set = new TreeSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { max = Math . max ( max , a [ i ] ) ; set . add ( a [ i ] ) ; if ( set . size ( ) == max && max == i + 1 ) r [ i ] = true ; } max = 0 ; set = new TreeSet < > ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { max = Math . max ( max , a [ i ] ) ; set . add ( a [ i ] ) ; if ( set . size ( ) == max && max == ( n - i ) ) l [ i ] = true ; }
import java . util . * ; import java . math . * ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ;  
import java . util . * ;   public class watermelon { public static void main ( String args [ ] ) {   String word ; Scanner scanner = new Scanner ( System . in ) ; word = scanner . nextLine ( ) ;   for ( int i = 0 ; i < word . length ( ) ; i ++ ) { if ( i == 0 ) { char temp = word . toUpperCase ( ) . charAt ( 0 ) ; System . out . print ( temp ) ; } else { System . out . print ( word . charAt ( i ) ) ; } } } }
import java . util . Scanner ;   public class A924 { static int R ; static int C ;   public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; R = in . nextInt ( ) ; C = in . nextInt ( ) ; boolean [ ] [ ] black = new boolean [ R ] [ C ] ; for ( int r = 0 ; r < R ; r ++ ) { String row = in . next ( ) ; for ( int c = 0 ; c < C ; c ++ ) { if ( row . charAt ( c ) == ' # ' ) { black [ r ] [ c ] = true ; } } } boolean ok = true ; main : for ( int r = 0 ; r < R ; r ++ ) { for ( int c = 0 ; c < C ; c ++ ) { if ( black [ r ] [ c ] ) { boolean [ ] rows = new boolean [ R ] ; boolean [ ] columns = new boolean [ C ] ; select ( r , c , black , rows , columns ) ; for ( int rr = 0 ; rr < R ; rr ++ ) { if ( rows [ rr ] ) { for ( int cc = 0 ; cc < C ; cc ++ ) { if ( columns [ cc ] && ! black [ rr ] [ cc ] ) { ok = false ; break main ; } } } } } } } System . out . println ( ok ? " Yes " : " No " ) ; }   static void select ( int rSel , int cSel , boolean [ ] [ ] black , boolean [ ] rows , boolean [ ] columns ) { if ( ! rows [ rSel ] ) { rows [ rSel ] = true ; for ( int c = 0 ; c < C ; c ++ ) { if ( black [ rSel ] [ c ] ) { select ( rSel , c , black , rows , columns ) ; } } } if ( ! columns [ cSel ] ) { columns [ cSel ] = true ; for ( int r = 0 ; r < R ; r ++ ) { if ( black [ r ] [ cSel ] ) { select ( r , cSel , black , rows , columns ) ; } } } }   }
import java . util . Scanner ;   public class A1417 {   public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int N = in . nextInt ( ) ; int K = in . nextInt ( ) ; int [ ] A = new int [ N ] ; int min = Integer . MAX_VALUE ; for ( int n = 0 ; n < N ; n ++ ) { int a = in . nextInt ( ) ; min = Math . min ( min , a ) ; A [ n ] = a ; } int answer = 0 ; for ( int a : A ) { answer += ( K - a ) / min ; } answer -= ( K - min ) / min ; System . out . println ( answer ) ; } }   }
import java . util . * ;   public class questionCF { static ArrayList < Integer > game ( ArrayList < Integer > list , int n ) { if ( n == 1 ) { list . add ( 1 ) ; return list ; } if ( n == 2 ) { list . add ( 2 ) ; return list ; } int count = 0 ; for ( int i = 1 ; true ; i = i * 2 ) { count ++ ; if ( i == n ) { list . add ( count ) ; return list ; } else if ( i > n ) { list . add ( count - 1 ) ; game ( list , n - ( i / 2 ) ) ; return list ; } } }   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; ArrayList < Integer > l = new ArrayList < > ( ) ; ArrayList < Integer > list = game ( l , n ) ; for ( int i = 0 ; i < list . size ( ) ; i ++ ) System . out . print ( list . get ( i ) + " ▁ " ) ;   } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . Random ; import java . util . Arrays ; import java . util . StringTokenizer ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Collections ;   public class A { public static void main ( String [ ] args ) { FastReader sc = new FastReader ( ) ; StringBuffer ans = new StringBuffer ( ) ; int test = 1 ; while ( test -- > 0 ) { int n = sc . nextInt ( ) ; long even = 0 ; long odd = 0 ; long mod = ( long ) ( 1e9 + 7 ) ; long dp [ ] = new long [ n + 1 ] ; long sum = 0l ; for ( int i = n ; i >= 1 ; i -- ) { if ( i == n ) dp [ i ] = 1 ; else if ( i == n - 1 ) dp [ i ] = 2 ; else { dp [ i ] = 1 ; if ( i % 2 == 0 ) dp [ i ] = ( dp [ i ] + odd ) % mod ; else dp [ i ] = ( dp [ i ] + even ) % mod ; } if ( i % 2 == 0 ) even = ( even + dp [ i ] ) % mod ; else odd = ( odd + dp [ i ] ) % mod ; sum = ( sum + dp [ i ] ) % mod ; } ans . append ( sum + " \n " ) ; } System . out . print ( ans ) ; } static final Random random = new Random ( ) ; static void ruffleSort ( int [ ] a ) { int n = a . length ;
import java . util . Scanner ; import java . util . Arrays ; public class Ishu { static long gcd ( long a , long b ) { if ( b == 0 ) return a ; else return gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; long t ; long n , ans = 1 ; t = scan . nextLong ( ) ; while ( t -- > 0 ) { n = scan . nextLong ( ) ; ans = 1 + ( ( 4 * n ) / gcd ( 4 * n , n + 1 ) ) ; System . out . println ( ans ) ; } } }
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . util . Arrays ;    public class Solution {    public static void main ( String [ ] args ) throws Exception {   BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ;   String input = br . readLine ( ) ; int n = Integer . parseInt ( input ) ; n *= 2 ; input = br . readLine ( ) ; int no = 0 ; int swaps = 0 ; int [ ] l = Arrays . stream ( input . split ( " ▁ " ) ) . mapToInt ( Integer :: parseInt ) . toArray ( ) ; for ( int i = 0 ; i < n ; ) { int match = l [ i ] ; for ( int j = i + 1 ; j < n ; j ++ ) { if ( l [ j ] == match ) { no = j ; } } for ( int j = no ; j > i + 1 ; j -- ) { int temp = l [ j ] ; l [ j ] = l [ j - 1 ] ; l [ j - 1 ] = temp ; swaps ++ ; } i += 2 ; } System . out . println ( swaps ) ; }    }      
import java . io . * ; import java . math . * ; import java . util . * ;  
import java . util . Scanner ;   public class Singleton_Pattern { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int input = sc . nextInt ( ) ; sc . nextLine ( ) ; String s = sc . nextLine ( ) ; int z = 0 , n = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) == ' z ' ) z ++ ; if ( s . charAt ( i ) == ' n ' ) n ++ ; } for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( "1" + " ▁ " ) ; }   for ( int i = 0 ; i < z ; i ++ ) { System . out . print ( "0" + " ▁ " ) ; }   } }
# include < cstdio > # include < cstring > # include < iostream > # include < algorithm > using namespace std ; const int maxn = 200010 ; typedef long long LL ; int n , k , a , b , q , c [ maxn ] [ 2 ] , s [ maxn ] ; int lowbit ( int x ) { return x & ( - x ) ; } void add ( int x , int y , int z ) { for ( int i = x ; i < maxn ; i += lowbit ( i ) ) c [ i ] [ z ] += y ; } int sum ( int x , int z ) { int ans = 0 ; for ( int i = x ; i ; i -= lowbit ( i ) ) ans += c [ i ] [ z ] ; return ans ; } int main ( ) { scanf ( " % d % d % d % d % d " , & n , & k , & a , & b , & q ) ; while ( q -- ) { int op ; scanf ( " % d " , & op ) ; if ( op == 1 ) { int x , y ; scanf ( " % d % d " , & x , & y ) ; int pre = s [ x ] ; s [ x ] += y ; add ( x , min ( b , s [ x ] ) - min ( b , pre ) , 0 ) ; add ( x , min ( a , s [ x ] ) - min ( a , pre ) , 1 ) ; } else { int x ; scanf ( " % d " , & x ) ; printf ( " % d \n " , sum ( x - 1 , 0 ) + sum ( n , 1 ) - sum ( x + k - 1 , 1 ) ) ; } } return 0 ; }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import static java . lang . Math . * ; import static java . lang . System . out ; import java . util . * ; import java . io . PrintStream ; import java . io . PrintWriter ; public class A { static final int N = ( int ) ( 3e5 ) ; static final int mod = 1000000007 ; static final long temp = 998244353 ; static final long MOD = 1000000007 ; static final long M = ( long ) 1e9 + 7 ; static class Pair implements Comparable < Pair > { int first , second ; public Pair ( int aa , int bb ) { first = aa ; second = bb ; } public int compareTo ( Pair o ) { if ( this . second < o . second ) return - 1 ; if ( this . second > o . second ) return + 1 ; return this . first - o . first ; } } static class Tuple implements Comparable < Tuple > { long first , second , third ; public Tuple ( long first , long second , long third ) { this . first = first ; this . second = second ; this . third = third ; } public int compareTo ( Tuple o ) { return ( int ) ( o . third - this . third ) ; } } public static class DSU { int [ ] parent ; int [ ] rank ;
import java . util . * ; public class FoxMinimalPath { private static boolean [ ] [ ] grid ; public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int k = sc . nextInt ( ) ; int l = ( int ) ( Math . log ( k ) / Math . log ( 2 ) ) ; int n = 2 + 2 * l ; for ( int i = 0 ; i <= l ; i ++ ) { if ( k / ( int ) Math . pow ( 2 , i ) % 2 == 1 ) n += l - i ; } grid = new boolean [ n ] [ n ] ; int lastA = 0 , lastB = 0 , ind = 2 ; for ( int i = 0 ; i < l ; i ++ ) { for ( int c = 0 ; c < 2 ; c ++ ) { connect ( ind , lastA ) ; connect ( ind , lastB ) ; ind ++ ; } lastA = ind - 2 ; lastB = ind - 1 ; } connect ( lastA , 1 ) ; connect ( lastB , 1 ) ; for ( int i = 0 ; i < l ; i ++ ) if ( k / ( int ) Math . pow ( 2 , i ) % 2 == 1 ) { connect ( ind , 2 * i ) ; if ( i > 0 ) connect ( ind , 2 * i + 1 ) ; for ( int j = i ; j < l - 1 ; j ++ ) connect ( ++ ind , ind - 1 ) ; connect ( ind ++ , 1 ) ; } System . out . println ( n ) ; for ( boolean [ ] arr : grid ) { for ( boolean b : arr ) System . out . print ( b ? " Y " : " N " ) ; System . out . println ( ) ; } } public static void connect ( int a , int b ) { grid [ a ] [ b ] = true ; grid [ b ] [ a ] = true ; } }
import java . util . * ;   public class A { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- != 0 ) { long m , s = 0 , d , x , y , a , b ; x = sc . nextInt ( ) ; y = sc . nextInt ( ) ; a = sc . nextInt ( ) ; b = sc . nextInt ( ) ;   m = Math . min ( x , y ) ; x = x - m ; y = y - m ; s = Math . min ( 2 * m * a , b * m ) ; s = s + x * a + y * a ; System . out . println ( s ) ; } } }
import java . util . Scanner ;   public class CaterpillarClimbing {   public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int start = scan . nextInt ( ) , end = scan . nextInt ( ) , up = scan . nextInt ( ) , down = scan . nextInt ( ) , c = 0 ; start += up * 8 ; if ( down >= up && start < end ) { System . out . println ( " - 1" ) ; return ; } while ( start < end ) { start -= down * 12 ; start += up * 12 ; c ++ ; } System . out . println ( c ) ; }   }
import java . util . Scanner ;   public class NotWoolSequences { public static void main ( String [ ] args ) { Scanner l1 = new Scanner ( System . in ) ; long l2 = l1 . nextLong ( ) ; long l3 = l1 . nextLong ( ) ; Wool s2 = new Wool ( ) ; s2 . WoolSequences ( l2 , l3 ) ; } } class Wool { long M = 1000000009 ;   public void WoolSequences ( long l2 , long l3 ) { { long pot2 = 1 ; for ( int i = 1 ; i <= l3 ; i ++ ) { pot2 *= 2 ; pot2 %= M ; } long wyn = 1 ; for ( int i = 1 ; i <= l2 ; i ++ ) { wyn *= ( pot2 - i ) ; wyn %= M ; } System . out . println ( wyn ) ; } } }
# include < algorithm > # include < iostream > using namespace std ; # define ll long long   ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; }   ll t ; ll n ; ll a [ 1000000 ] ; ll k ;   int main ( ) { cin >> t ; while ( t -- ) { int bj = 0 ; cin >> n >> k ; for ( int i = 1 ; i <= n ; i ++ ) { cin >> a [ i ] ; } ll dq = max ( a [ 1 ] , a [ 2 ] ) - min ( a [ 1 ] , a [ 2 ] ) ; ll sz = a [ 1 ] ; if ( ( k - sz ) % dq == 0 ) bj = 1 ; for ( int i = 3 ; i <= n ; i ++ ) { ll s = ( a [ i ] - sz ) / dq ; ll js = min ( abs ( sz + s * dq - a [ i ] ) , min ( abs ( sz + ( s + 1 ) * dq - a [ i ] ) , abs ( sz + ( s - 1 ) * dq - a [ i ] ) ) ) ; dq = gcd ( js , dq ) ; if ( ( k - sz ) % dq == 0 ) { bj = 1 ; break ; } } if ( bj == 1 ) cout << " YES " << endl ; else cout << " NO " << endl ; } return 0 ; }
import java . util . Scanner ;   public class Loop {   static int N ;
import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . HashSet ; import java . util . LinkedList ; import java . util . List ; import java . util . Map ; import java . util . Queue ; import java . util . Scanner ; import java . util . Set ; import java . util . TreeMap ; import java . util . Vector ;   public class Main { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) , t = in . nextInt ( ) ; int j = Integer . MAX_VALUE , ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { int l = in . nextInt ( ) , r = in . nextInt ( ) ; if ( l >= t ) { if ( j > l ) { j = l ; ans = i ; } } else { int st = t - l ; int sum = st % r == 0 ? st / r : st / r + 1 ; sum = sum * r + l ; if ( j > sum ) { j = sum ; ans = i ; } } } System . out . println ( ans ) ; } }
import java . io . BufferedReader ; import java . io . FileReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . util . * ; import java . io . * ; public class codeforces { static class Student { int x , y ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . StringTokenizer ; import java . util . * ;   public class CF606A { public static void main ( String [ ] args ) { FastReader input = new FastReader ( ) ; PrintWriter pw = new PrintWriter ( System . out ) ;   int a = input . nextInt ( ) ; int b = input . nextInt ( ) ; int c = input . nextInt ( ) ;   int d = input . nextInt ( ) ; int e = input . nextInt ( ) ; int f = input . nextInt ( ) ;   int got = 0 , need = 0 ;   if ( a - d >= 0 ) { got += ( a - d ) / 2 ; } else { need += Math . abs ( a - d ) ; }   if ( b - e >= 0 ) { got += ( b - e ) / 2 ; } else { need += Math . abs ( b - e ) ; }   if ( c - f >= 0 ) { got += ( c - f ) / 2 ; } else { need += Math . abs ( c - f ) ; }   if ( got >= need ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; }     
import java . util . * ; import java . util . regex . * ;   public class Solution { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; int [ ] [ ] a = new int [ n ] [ n ] ; int res = 0 ; StringBuilder nums = new StringBuilder ( ) ; for ( int i = 0 ; i < n ; i ++ ) { boolean good = true ; for ( int j = 0 ; j < n ; j ++ ) { a [ i ] [ j ] = scan . nextInt ( ) ; if ( a [ i ] [ j ] == 1 || a [ i ] [ j ] == 3 ) { good = false ; } } if ( good ) { nums . append ( ( i + 1 ) + " ▁ " ) ; res ++ ; } } System . out . println ( res ) ; System . out . println ( nums ) ; } }
import java . util . * ;   public class CF { private static void sport ( int [ ] a ) { Arrays . sort ( a ) ; int n = a . length ; int ans = n ; int j = n / 2 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { while ( true ) { if ( j == n ) { System . out . println ( ans ) ; return ; } if ( a [ i ] * 2 <= a [ j ] ) { j ++ ; ans -- ; break ; } else { j ++ ; } } } System . out . println ( ans ) ; }   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int [ ] a = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } sport ( a ) ; } }
import java . math . BigInteger ; import java . util . * ; import java . util . Comparator ; import java . lang . * ; import java . util . Arrays ;        public class geek { static class comp { int a , b ; public comp ( ) { } public comp ( int a , int b ) { this . a = a ; this . b = b ; }   }    public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; try { StringBuffer sb = new StringBuffer ( ) ;   int n = s . nextInt ( ) ; long b [ ] = new long [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = s . nextLong ( ) ; } long x = 0 ; long a [ ] = new long [ n ] ; a [ 0 ] = b [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { x = Math . max ( a [ i - 1 ] , x ) ; a [ i ] = b [ i ] + x ;   } for ( int i = 0 ; i < n ; i ++ ) { sb . append ( a [ i ] + " ▁ " ) ; }   System . out . println ( sb ) ;          
import java . util . ArrayList ; import java . util . Scanner ;    public class PaperWork {   public static void main ( String [ ] args ) {
import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { PrintWriter out ; FastReader sc ; long mod = ( long ) ( 1e9 + 7 ) ; int maxint = Integer . MAX_VALUE ; int minint = Integer . MIN_VALUE ; long maxlong = Long . MAX_VALUE ; long minlong = Long . MIN_VALUE ; public void sol ( ) { int a = ni ( ) ; if ( a % 2 == 0 ) { pl ( a + 4 + " ▁ " + 4 ) ; } else { pl ( a + 9 + " ▁ " + 9 ) ; } } public static void main ( String [ ] args ) { Main g = new Main ( ) ; g . out = new PrintWriter ( System . out ) ; g . sc = new FastReader ( ) ; int t = 1 ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ; import java . io . PrintWriter ;        public class A {     public static void main ( String [ ] args ) throws IOException { FastReader sc = new FastReader ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int r1 = sc . nextInt ( ) ; int r2 = sc . nextInt ( ) ; int c1 = sc . nextInt ( ) ; int c2 = sc . nextInt ( ) ; int d1 = sc . nextInt ( ) ; int d2 = sc . nextInt ( ) ;   int x = ( d1 + c1 - r2 ) / 2 ; int a = r1 - x ; int b = c1 - x ; int c = r2 - c1 + x ;   if ( x < 10 && a < 10 && b < 10 && c < 10 && x > 0 && a > 0 && b > 0 && c > 0 && x != a && x != c && x != b && a != b && a != c && b != c && ( a + x ) == r1 && ( b + c ) == r2 && ( x + b ) == c1 && ( a + c ) == c2 && ( x + c ) == d1 && ( a + b ) == d2 ) { out . println ( x + " ▁ " + a ) ; out . println ( b + " ▁ " + c ) ; }   else out . println ( - 1 ) ;   out . close ( ) ; }      
import java . util . * ; public class Main { public static Scanner sc = new Scanner ( System . in ) ; public static void setArray ( int arr [ ] [ ] ) { for ( int i = 0 ; i < arr . length ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { arr [ i ] [ j ] = sc . nextInt ( ) ; } } } public static void main ( String args [ ] ) { int n = sc . nextInt ( ) ; int arr [ ] [ ] = new int [ n ] [ 3 ] ; setArray ( arr ) ; int ocount = 0 ; for ( int i = 0 ; i < arr . length ; i ++ ) { int icount = 0 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( arr [ i ] [ j ] == 1 ) { icount ++ ; } } if ( icount >= 2 ) { ocount ++ ; } } System . out . println ( ocount ) ;      } }
import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Scanner ; import java . lang . Math ; public class Account { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; arr [ 0 ] = sc . nextInt ( ) ; int max = arr [ 0 ] , min = arr [ 0 ] , sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; sum += arr [ i ] ; if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } if ( n == 1 ) {
import java . io . * ; import java . util . ArrayList ; import java . util . HashMap ; import java . util . Map ; import java . util . StringTokenizer ;   public class A_MagicalBoxes_1600 { public static void main ( String [ ] args ) { MyScanner sc = new MyScanner ( ) ; out = new PrintWriter ( new BufferedOutputStream ( System . out ) ) ; int N = sc . nextInt ( ) ; Map < Integer , Integer > boxes = new HashMap < > ( ) ; int largest = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int temp1 = Integer . parseInt ( sc . next ( ) ) ; int temp2 = Integer . parseInt ( sc . next ( ) ) ; if ( temp1 > largest ) largest = temp1 ; boxes . put ( temp1 , temp2 ) ; } int smallestBox = largest + 1 ; for ( int i : boxes . keySet ( ) ) { while ( boxes . get ( i ) > Math . pow ( 4 , smallestBox - i ) ) { smallestBox ++ ; } }   System . out . println ( smallestBox ) ;    out . close ( ) ; }   public static PrintWriter out ;   public static class MyScanner { BufferedReader br ; StringTokenizer st ;   public MyScanner ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; }   String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; }   int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }   long nextLong ( ) { return Long . parseLong ( next ( ) ) ; }   double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; }   String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; }   } }
import java . util . Scanner ;   public class lifewithoutzeros { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ;   int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int c = a + b ;   String a1 = Integer . toString ( a ) ; String b1 = Integer . toString ( b ) ; String c1 = Integer . toString ( c ) ;   a1 = a1 . replace ( "0" , " " ) ; a = Integer . parseInt ( a1 ) ; b1 = b1 . replace ( "0" , " " ) ; b = Integer . parseInt ( b1 ) ; c1 = c1 . replace ( "0" , " " ) ; int c2 = Integer . parseInt ( c1 ) ;          if ( c2 == a + b ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ;           } }
import java . util . * ;   public class Test {   public static void main ( String [ ] args ) {   Scanner scan = new Scanner ( System . in ) ;   String [ ] name = { " Sheldon " , " Leonard " , " Penny " , " Rajesh " , " Howard " } ;   int input = scan . nextInt ( ) - 1 ; int pow = 5 * ( int ) Math . pow ( 2 , log ( input / 5 ) ) ;   if ( input >= pow - 5 && input < 2 * pow - 5 ) res ( name , pow - 5 , input , pow / 5 ) ; else res ( name , 2 * pow - 5 , input , 2 * pow / 5 ) ;   } public static int log ( int n ) { if ( n <= 1 ) return 0 ;   return log ( n / 2 ) + 1 ; } public static void res ( String [ ] S , int low , int input , int pow ) {   int res = input - low ; System . out . println ( S [ res / pow ] ) ; } }
import java . util . Scanner ;   public class A1296 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) , odd = 0 , even = 0 ; for ( int j = 0 ; j < n ; j ++ ) { int a = scanner . nextInt ( ) ; if ( a % 2 == 0 ) even ++ ; else odd ++ ; } System . out . println ( odd % 2 == 0 && even == 0 || odd == 0 ? " NO " : " YES " ) ; } } }
import java . util . * ;   public class Test { public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; int n = input . nextInt ( ) ; long sum = 0 ; int min = 0 ;   for ( int i = 0 ; i < n ; i ++ ) { int x = input . nextInt ( ) ; if ( ( x & 1 ) == 1 && ( x < min || min == 0 ) ) { min = x ; } sum += x ; } System . out . println ( ( sum & 1 ) == 0 ? sum : sum - min ) ; } }
import java . util . * ; import java . io . * ; import java . math . * ;   public class x828A { public static void main ( String hi [ ] ) throws Exception { BufferedReader infile = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( infile . readLine ( ) ) ; int N = Integer . parseInt ( st . nextToken ( ) ) ; int A = Integer . parseInt ( st . nextToken ( ) ) ; int B = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] arr = new int [ N ] ; st = new StringTokenizer ( infile . readLine ( ) ) ; for ( int i = 0 ; i < N ; i ++ ) arr [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; int res = 0 ; int half = 0 ; for ( int x : arr ) { if ( x == 2 ) { if ( B > 0 ) B -- ; else res += 2 ; } else { if ( A > 0 ) A -- ; else if ( B > 0 ) { B -- ; half ++ ; } else if ( half > 0 ) half -- ; else res ++ ; } } System . out . println ( res ) ; } }
import java . io . * ; import java . math . BigInteger ; import java . util . * ; public class Main { static InputReader in = new InputReader ( System . in ) ; static PrintWriter out = new PrintWriter ( System . out ) ; static int oo = ( int ) 1e9 ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . util . StringTokenizer ;   public class Main { public static void main ( String [ ] args ) { InputStream is = System . in ; OutputStream os = System . out ; InputReader in = new InputReader ( is ) ; PrintWriter out = new PrintWriter ( os ) ; Solver solver = new Solver ( ) ; solver . solve ( in , out ) ; out . close ( ) ; }   static class Solver { void solve ( InputReader in , PrintWriter out ) { int n = in . nextInt ( ) ; int cnt = 1 ; char [ ] s = in . next ( ) . toCharArray ( ) ; for ( int i = 1 ; i < s . length ; i ++ ) { if ( s [ i ] != s [ i - 1 ] ) cnt ++ ; } out . println ( Math . min ( cnt + 2 , n ) ) ; } } static class InputReader { BufferedReader br = null ; StringTokenizer st = null ; InputReader ( InputStream in ) { br = new BufferedReader ( new InputStreamReader ( in ) ) ; } String nextLine ( ) { String line = null ; try { line = br . readLine ( ) ; } catch ( IOException e ) {
import java . util . * ; import java . io . * ;   public class P203B {   private static void solve ( ) { int n = nextInt ( ) ; int [ ] [ ] board = new int [ n ] [ n ] ;   int m = nextInt ( ) ;   for ( int i = 0 ; i < m ; i ++ ) { board [ nextInt ( ) - 1 ] [ nextInt ( ) - 1 ] = i + 1 ; }   int ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { int black = 0 ; int max = 0 ; for ( int k = 0 ; k < 3 ; k ++ ) { for ( int l = 0 ; l < 3 ; l ++ ) { if ( i + k < n && j + l < n && board [ i + k ] [ j + l ] != 0 ) { black ++ ; max = Math . max ( board [ i + k ] [ j + l ] , max ) ; } } }   if ( black == 9 && ( ans == - 1 || ans > max ) ) { ans = max ; } } }   System . out . println ( ans ) ; }   private static void run ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( System . out ) ;   solve ( ) ;   out . close ( ) ; }   private static StringTokenizer st ; private static BufferedReader br ; private static PrintWriter out ;   private static String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { String s ; try { s = br . readLine ( ) ; } catch ( IOException e ) { return null ; } st = new StringTokenizer ( s ) ; } return st . nextToken ( ) ; }   private static int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }   private static long nextLong ( ) { return Long . parseLong ( next ( ) ) ; }   public static void main ( String [ ] args ) { run ( ) ; } }
import java . io . * ; import java . util . * ;   public class B { static ArrayList < Long > power = new ArrayList < > ( ) ; static ArrayList < Long > divisors = new ArrayList < > ( ) ; public static void main ( String [ ] args ) throws IOException { Scanner in = new Scanner ( System . in ) ; PrintWriter pw = new PrintWriter ( System . out ) ; dp ( ) ; long n = in . nextLong ( ) ; divisor ( n ) ;
import java . util . Scanner ;   public class JavaApplication1 {   public static void main ( String [ ] args ) { Scanner input = new Scanner ( System . in ) ; char letter ; letter = input . next ( ) . charAt ( 0 ) ; int shift = 0 ; if ( letter == ' R ' ) shift = - 1 ; else shift = 1 ; String keybord = " qwertyuiopasdfghjkl ; zxcvbnm , . / " ; String massage = " " ; String str = input . next ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int index = keybord . indexOf ( str . charAt ( i ) ) ; massage += keybord . charAt ( index + shift ) ; } System . out . println ( massage ) ; input . close ( ) ; } }
import java . io . File ; import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . IOException ; import java . nio . file . Paths ; import java . util . Arrays ; import java . util . InputMismatchException ; import java . util . TreeSet ;   public class Main {   public Main ( ) throws FileNotFoundException {
import java . util . * ; public class Contest8 { static Scanner scn = new Scanner ( System . in ) ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import static java . lang . Math . ceil ;    public class CF672ASummerCamp {   static BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static PrintWriter out = new PrintWriter ( System . out ) ;   public static void main ( String [ ] args ) throws IOException { int n = Integer . parseInt ( in . readLine ( ) ) ; String s = " " ; for ( int i = 1 ; i <= n ; i ++ ) { s += i ; } out . print ( s . charAt ( n - 1 ) ) ; out . close ( ) ; } }
import java . util . Scanner ;   public class _0725ReverseaSubstring {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; long n = sc . nextLong ( ) ; sc . nextLine ( ) ; String s = sc . nextLine ( ) ; for ( int i = 1 ; i < n ; i ++ ) { if ( s . charAt ( i ) < s . charAt ( i - 1 ) ) { System . out . println ( " YES " ) ; System . out . println ( ( i ) + " ▁ " + ( i + 1 ) ) ; return ; } } System . out . println ( " NO " ) ; }   }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import static java . lang . Math . * ; import static java . lang . System . out ; import java . util . * ; import java . io . PrintStream ; import java . io . PrintWriter ; public class A { static final int mod = 1000000007 ; static final long temp = 998244353 ; static final long MOD = 1000000007 ; static final long M = ( long ) 1e9 + 7 ; static class Pair implements Comparable < Pair > { int first , second ; public Pair ( int aa , int bb ) { first = aa ; second = bb ; } public int compareTo ( Pair o ) { if ( this . second < o . second ) return - 1 ; if ( this . second > o . second ) return + 1 ; return this . first - o . first ; } } static class Tuple implements Comparable < Tuple > { long first , second , third ; public Tuple ( long first , long second , long third ) { this . first = first ; this . second = second ; this . third = third ; } public int compareTo ( Tuple o ) { return ( int ) ( o . third - this . third ) ; } } public static class DSU { int [ ] parent ; int [ ] rank ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . io . StreamTokenizer ;   public class Main { public static int a , b , c ; public static StringBuilder ans = new StringBuilder ( ) ; public static String mod ;   public static void main ( String [ ] args ) throws IOException { BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StreamTokenizer st = new StreamTokenizer ( in ) ; PrintWriter pr = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; st . nextToken ( ) ; a = ( int ) st . nval ; st . nextToken ( ) ; b = ( int ) st . nval ; st . nextToken ( ) ; c = ( int ) st . nval ; if ( a >= b ) { mod = "01" ; } else { mod = "10" ; } for ( int i = 0 ; i < ( c + 1 ) / 2 ; i ++ ) { ans . append ( mod ) ; a -- ; b -- ; } if ( ( c & 1 ) == 0 ) { ans . append ( mod . charAt ( 0 ) ) ; if ( mod . charAt ( 0 ) == '0' ) { a -- ; } else { b -- ; } } if ( a != 0 ) { int temp = ans . indexOf ( "0" ) ; while ( a -- > 0 ) { ans . insert ( temp , '0' ) ; } } if ( b != 0 ) { int temp = ans . indexOf ( "1" ) ; while ( b -- > 0 ) { ans . insert ( temp , '1' ) ; } } pr . println ( ans ) ; pr . flush ( ) ; } }
import java . util . Scanner ;    public class TheatreSquare_problem {   public static void main ( String [ ] args ) {
import java . util . * ;   public class CF102 { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int k = sc . nextInt ( ) ; int [ ] ar = new int [ n ] ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { ar [ i ] = sc . nextInt ( ) ; if ( k % ar [ i ] == 0 ) { min = Math . min ( min , k / ar [ i ] ) ; } } System . out . println ( min ) ;
import java . util . * ; import java . lang . * ; import java . io . * ;   public class modularExponentiation { static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; public static void main ( String [ ] args ) throws java . lang . Exception { solve ( ) ; }   public static void solve ( ) throws IOException { int n = Integer . parseInt ( br . readLine ( ) ) ; int m = Integer . parseInt ( br . readLine ( ) ) ;   if ( n >= 33 ) { System . out . println ( m ) ; } else { System . out . println ( m % ( int ) Math . pow ( 2 , n ) ) ; }   } }
import java . io . * ; import java . math . * ; import java . security . * ; import java . text . * ; import java . time . LocalDate ; import java . time . LocalDateTime ; import java . util . * ; import java . util . concurrent . * ; import java . util . regex . * ;   public class Solution {   static class Reader { static BufferedReader reader ; static StringTokenizer tokenizer ;   static void init ( InputStream input ) { reader = new BufferedReader ( new InputStreamReader ( input ) ) ; tokenizer = new StringTokenizer ( " " ) ; }   static String next ( ) throws IOException { while ( ! tokenizer . hasMoreTokens ( ) ) { tokenizer = new StringTokenizer ( reader . readLine ( ) ) ; } return tokenizer . nextToken ( ) ; }   static int nextInt ( ) throws IOException { return Integer . parseInt ( next ( ) ) ; }   static double nextDouble ( ) throws IOException { return Double . parseDouble ( next ( ) ) ; } } public static void main ( String [ ] args ) throws IOException {
import java . util . Scanner ;   public class gigatower { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int a = sc . nextInt ( ) ; int i = 0 ; for ( i = a + 1 ; ; i ++ ) {
import java . util . * ;   public class NewClass { static ArrayList < ArrayList < Integer > > graph = new ArrayList < ArrayList < Integer > > ( ) ; static ArrayList < Boolean > visited = new ArrayList < Boolean > ( ) ; static int count = 0 ; static boolean dfs ( int cn , int pn ) { if ( visited . get ( cn ) ) return true ; visited . set ( cn , Boolean . TRUE ) ; for ( int i : graph . get ( cn ) ) { if ( i != pn ) { count ++ ; if ( dfs ( i , cn ) ) return true ; } } return false ; } public static void main ( String args [ ] ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) , m = sc . nextInt ( ) , team = n ; for ( int i = 0 ; i < n ; i ++ ) { graph . add ( new ArrayList < Integer > ( ) ) ; visited . add ( Boolean . FALSE ) ; } for ( int i = 0 ; i < m ; i ++ ) { int a = sc . nextInt ( ) - 1 , b = sc . nextInt ( ) - 1 ; graph . get ( a ) . add ( b ) ; graph . get ( b ) . add ( a ) ; } for ( int i = 0 ; i < n ; i ++ ) { count = 0 ; boolean b = dfs ( i , - 1 ) ; if ( b && count % 2 != 0 ) { team -- ; } } if ( team % 2 != 0 ) team -- ; System . out . println ( n - team ) ; } }
import java . util . Scanner ; public class Main { public static void main ( String args [ ] ) { Scanner s = new Scanner ( System . in ) ; int t = s . nextInt ( ) ; while ( t -- != 0 ) { String str = s . next ( ) ; int one = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == '1' ) { one ++ ; } } int min = Math . min ( one , str . length ( ) - one ) ; String ans = " DA " ; if ( min % 2 == 0 ) { ans = " NET " ; } System . out . println ( ans ) ; } } }
import java . util . Scanner ;   public class B { public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int n = in . nextInt ( ) ; while ( n -- > 0 ) { int ind = in . nextInt ( ) , z = 0 ; for ( int i = 0 ; i < ind ; i ++ ) { int bh = in . nextInt ( ) ; if ( bh == 0 ) { z ++ ; } } if ( z >= ( ind / 2 ) ) { println ( ind / 2 ) ; for ( int i = 1 ; i <= ind / 2 ; i ++ ) { print ( '0' + " ▁ " ) ; } } else { if ( ( ind / 2 ) % 2 == 0 ) { println ( ind / 2 ) ; for ( int i = 0 ; i < ( ind / 2 ) ; i ++ ) { print ( '1' + " ▁ " ) ; } } else { println ( ind / 2 + 1 ) ; for ( int i = 0 ; i < ( ind / 2 ) + 1 ; i ++ ) { print ( '1' + " ▁ " ) ; } } } println ( ) ; } } static void print ( Object o ) { System . out . print ( o ) ; } static void println ( Object o ) { print ( o ) ; println ( ) ; } static void println ( ) { print ( ' \n ' ) ; } }
import java . util . Scanner ; public class Ishu { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int i ; boolean flag = false ; long x , n , y , temp , sum = 0 ; n = scan . nextLong ( ) ; x = scan . nextLong ( ) ; y = scan . nextLong ( ) ; temp = y - ( n - 1 ) ; if ( temp > 0 ) { sum = n - 1 ; sum += temp * temp ; if ( sum >= x ) flag = true ; } if ( flag ) { for ( i = 1 ; i <= n - 1 ; ++ i ) System . out . println ( 1 ) ; System . out . println ( temp ) ; } else System . out . println ( - 1 ) ; } }
import java . util . Scanner ;   public class Stairs { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ;   int n = scan . nextInt ( ) ; int [ ] number = new int [ 5000 ] ; StringBuilder sb = new StringBuilder ( ) ;   for ( int i = 0 ; i < n ; i ++ ) { number [ scan . nextInt ( ) - 1 ] ++ ; }   int max = 0 ; int count = 0 ; for ( int i = 0 ; i < 5000 ; i ++ ) { if ( number [ i ] > 0 ) { sb . append ( i + 1 + " ▁ " ) ; number [ i ] -- ; count ++ ; max = i ; } }   for ( int i = max - 1 ; i >= 0 ; i -- ) { if ( number [ i ] > 0 ) { sb . append ( i + 1 + " ▁ " ) ; count ++ ; } }   System . out . println ( count + " \n " + sb ) ; } }
import java . io . * ; import java . util . * ;   public class D implements Runnable { public static void main ( String [ ] args ) { new Thread ( null , new D ( ) , " _ cf " , 1 << 28 ) . start ( ) ; }   int [ ] [ ] pascals ; int MOD = ( int ) 1e9 + 7 ; int n ; long m ; int [ ] [ ] dp ; long [ ] [ ] pc ; public void run ( ) { FastScanner fs = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; System . err . println ( " Go ! " ) ;   pascals = new int [ 101 ] [ ] ; for ( int i = 0 ; i < pascals . length ; i ++ ) { pascals [ i ] = new int [ i + 1 ] ; pascals [ i ] [ 0 ] = 1 ; for ( int j = 1 ; j < pascals [ i ] . length ; j ++ ) { pascals [ i ] [ j ] += pascals [ i - 1 ] [ j - 1 ] ; pascals [ i ] [ j ] %= MOD ; if ( j < pascals [ i - 1 ] . length ) pascals [ i ] [ j ] += pascals [ i - 1 ] [ j ] ; pascals [ i ] [ j ] %= MOD ; } } n = fs . nextInt ( ) ; m = fs . nextLong ( ) ; pc = new long [ 101 ] [ 101 ] ;   for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { long ways = pascals [ n ] [ j ] ; long appear = 1 ; long use1 = ( m - n ) / n , use2 = ( m - n ) % n ; appear += use1 ; if ( i < use2 ) appear ++ ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ;   public class B_Codeforces_Subsequences {   static String s = " codeforces " ; static long n ; static BufferedReader in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; public static void main ( String [ ] args ) throws IOException { n = Long . parseLong ( in . readLine ( ) ) ; if ( n == 1 ) { System . out . println ( " codeforces " ) ; } else { long a [ ] = new long [ 10 ] ; for ( int i = 0 ; i < 10 ; i ++ ) { a [ i ] = 1 ; } char [ ] ch = s . toCharArray ( ) ; long k = 1 , x = 0 ; while ( n > k ) { long ok = a [ ( int ) ( x % 10 ) ] ; k = k / ok ; a [ ( int ) ( x % 10 ) ] ++ ; ok ++ ; k = k * ok ; x ++ ; } for ( int i = 0 ; i < 10 ; i ++ ) { for ( long j = 0 ; j < a [ i ] ; j ++ ) { System . out . print ( ch [ i ] ) ; } } System . out . println ( ) ; } } }
import java . util . * ; public class Main { static Scanner s = new Scanner ( System . in ) ; public static void main ( String [ ] args ) {   int t = 1 ; while ( t -- > 0 ) { solve ( ) ; } } public static void solve ( ) { String str = s . next ( ) ; ArrayList < Integer > list1 = new ArrayList < > ( ) ; ArrayList < Integer > list2 = new ArrayList < > ( ) ; ArrayList < Integer > list3 = new ArrayList < > ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch == ' ( ' ) list1 . add ( i ) ; } for ( int i = str . length ( ) - 1 ; i >= 0 ; i -- ) { char ch = str . charAt ( i ) ; if ( ch == ' ) ' ) list2 . add ( i ) ; } int flag = 5 ; for ( int i = 0 ; i < Math . min ( list1 . size ( ) , list2 . size ( ) ) ; i ++ ) { if ( list1 . get ( i ) < list2 . get ( i ) ) { list3 . add ( list2 . get ( i ) ) ; list3 . add ( list1 . get ( i ) ) ; flag = 4 ; } else break ; } if ( list3 . size ( ) == 0 ) { System . out . println ( "0" ) ; return ; } System . out . println ( "1" ) ; System . out . println ( list3 . size ( ) ) ; Collections . sort ( list3 ) ; for ( int i = 0 ; i < list3 . size ( ) ; i ++ ) { System . out . print ( ( list3 . get ( i ) + 1 ) + " ▁ " ) ; } } }
import java . util . * ; import java . util . jar . JarOutputStream ;   public class Practise {   public static int [ ] [ ] dp ;   public static void main ( String [ ] args ) {
import java . io . * ; import java . util . * ;   public class B { public static void main ( String [ ] args ) throws IOException { FastReader fr = new FastReader ( ) ; PrintWriter pr = new PrintWriter ( new OutputStreamWriter ( System . out ) ) ; int t = fr . nextInt ( ) ;   while ( t -- > 0 ) { int n = fr . nextInt ( ) ; TreeMap < Integer , List < Integer > > map = new TreeMap < > ( ) ;   for ( int i = 0 ; i < n ; i ++ ) { int add = fr . nextInt ( ) ; map . putIfAbsent ( add , new ArrayList < > ( ) ) ; map . get ( add ) . add ( i + 1 ) ; }  
import java . util . Scanner ; public class MyClass { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int k = s . nextInt ( ) ; int n = s . nextInt ( ) ; int w = s . nextInt ( ) ; int x = 0 , y = 0 ; for ( int i = 1 ; i <= w ; i ++ ) { x = k * i ; y = y + x ; } if ( y > n ) { k = y - n ; System . out . println ( k ) ; } else System . out . println ( "0" ) ; } }
import java . util . * ;   public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; if ( n == 1 ) System . out . println ( 9 ) ; else if ( n == 2 ) System . out . println ( 98 ) ; else if ( n == 3 ) System . out . println ( 989 ) ; else { System . out . print ( 989 ) ; int x = 0 ; while ( n -- > 3 ) { System . out . print ( x ) ; if ( x == 9 ) x = 0 ; else x ++ ; } System . out . println ( ) ; } } } }
import java . util . * ; public class poi { public static void main ( String args [ ] ) { Scanner in = new Scanner ( System . in ) ; int t = 1 ; int i , j ; while ( t -- > 0 ) { int n = in . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; }
import java . util . * ; import java . io . * ; import java . util . stream . * ; public class Solution { public static void main ( String [ ] args ) throws Exception { Scanner scan = new Scanner ( System . in ) ; int n = scan . nextInt ( ) ; scan . nextLine ( ) ; String s = scan . nextLine ( ) ; System . out . println ( s . replaceAll ( " ogo ( go ) * " , " * * * " ) ) ; } }
import java . util . * ; public class P2 {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int a [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = sc . nextInt ( ) ; } Arrays . sort ( a ) ; int sum = 0 ; if ( a [ n - 1 ] > 25 ) { sum = a [ n - 1 ] - 25 ; } System . out . println ( sum ) ; } }
import java . io . * ; import java . lang . * ; import java . util . * ;   public class GregAndGraph_295B { private static int n = 0 ; private static long [ ] [ ] graph ;   public static void main ( String [ ] args ) throws IOException { BufferedReader sc = new BufferedReader ( new InputStreamReader ( System . in ) ) ; n = Integer . parseInt ( sc . readLine ( ) ) ; graph = new long [ n ] [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { String [ ] line = sc . readLine ( ) . split ( " \\ s " ) ; for ( int j = 0 ; j < n ; j ++ ) { graph [ i ] [ j ] = Integer . parseInt ( line [ j ] ) ; } } int cnt = 0 ; long [ ] ans = new long [ n ] ; String [ ] downVertices = sc . readLine ( ) . split ( " \\ s " ) ; boolean [ ] vis = new boolean [ n ] ; for ( int p = n - 1 ; p >= 0 ; p -- ) { int down = Integer . parseInt ( downVertices [ p ] ) - 1 ; vis [ down ] = true ; for ( int u = 0 ; u < n ; u ++ ) { for ( int v = 0 ; v < n ; v ++ ) { graph [ u ] [ v ] = Math . min ( graph [ u ] [ v ] , graph [ u ] [ down ] + graph [ down ] [ v ] ) ; } }    long sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( vis [ i ] && vis [ j ] ) { sum += graph [ i ] [ j ] ; } } } ans [ cnt ++ ] = sum ; }   for ( int i = n - 1 ; i >= 0 ; i -- ) { System . out . println ( ans [ i ] ) ; } } }
import java . util . * ; import java . io . * ;   public class Main { public static void main ( String [ ] args ) throws IOException { FastScanner in = new FastScanner ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; new Main ( ) . run ( in , out ) ; out . close ( ) ; }   public static long mod = 17352642619633L ;   void run ( FastScanner in , PrintWriter out ) {   int N = in . nextInt ( ) ;   if ( N == 0 ) { out . println ( " YES " ) ; int [ ] a = { 1 , 2 , 2 , 3 } ; for ( int x : a ) out . println ( x ) ; return ; }   if ( N == 4 ) { int [ ] a = new int [ 4 ] ; for ( int i = 0 ; i < 4 ; i ++ ) a [ i ] = in . nextInt ( ) ; Arrays . sort ( a ) ; if ( range ( a ) != median ( a ) || median ( a ) != avg ( a ) ) NO ( ) ; else out . println ( " YES " ) ; }   if ( N == 1 ) { int a = in . nextInt ( ) ;
import java . util . Scanner ;   public class music {   public static int helper ( int t , int s , int q ) { int ans = s ; int count = 0 ; while ( ans < t ) { ans = ans + ans * ( q - 1 ) ; count ++ ; } if ( count == 0 ) return 1 ; else return count ; }   public static void main ( String [ ] args ) {
import java . io . InputStream ; import java . io . OutputStream ; import java . io . IOException ; import java . io . InputStream ; import java . io . BufferedWriter ; import java . io . Writer ; import java . io . OutputStreamWriter ; import java . io . IOException ; import java . util . InputMismatchException ; import java . io . PrintWriter ; import java . io . OutputStream ; public class Main { public static void main ( String [ ] args ) { InputStream inputStream = System . in ; OutputStream outputStream = System . out ; InputReader in = new InputReader ( inputStream ) ; OutputWriter out = new OutputWriter ( outputStream ) ; TaskB solver = new TaskB ( ) ; solver . solve ( 1 , in , out ) ; out . close ( ) ; } static class TaskB { public void solve ( int testNumber , InputReader in , OutputWriter out ) { int n = in . ri ( ) ; IntPair [ ] walls = new IntPair [ n ] ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . * ;   public class Main {   public static void main ( String [ ] args ) throws IOException {
import java . util . Scanner ;   public class Main { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int [ ] arr = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { arr [ i ] = sc . nextInt ( ) ; } boolean flag = false ; for ( int i = 2 ; i < n ; i ++ ) { if ( ( arr [ i ] > arr [ i - 1 ] && ( arr [ i ] > arr [ i + 1 ] ) ) ) { flag = true ; int j = i - 1 ; int k = i + 1 ; System . out . println ( " YES " ) ; System . out . println ( j + " ▁ " + i + " ▁ " + k ) ; break ; } } if ( ! flag ) System . out . println ( " NO " ) ; flag = false ; } } }  
import java . util . * ; import java . math . * ; public class UnluckyTicket { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; char [ ] temp = sc . next ( ) . toCharArray ( ) ; int [ ] arr1 = new int [ n ] ; int [ ] arr2 = new int [ n ] ; int p2 = n ; for ( int i = 0 ; i < n ; i ++ ) { arr1 [ i ] = temp [ i ] - '0' ; arr2 [ i ] = temp [ p2 ] - '0' ; p2 ++ ; } Arrays . sort ( arr1 ) ; Arrays . sort ( arr2 ) ; p2 = n ; boolean less = false ; boolean more = false ; boolean equal = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr1 [ i ] < arr2 [ i ] ) less = true ; else if ( arr1 [ i ] > arr2 [ i ] ) more = true ; else equal = true ; p2 ++ ; } if ( ( less && ! more || more && ! less ) && ! equal ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; import java . util . Scanner ; import java . io . * ; import javax . lang . model . util . ElementScanner6 ; import static java . lang . System . out ; import java . util . Stack ; import java . util . Queue ; import java . util . LinkedList ;   public class B476M2 {   static int mod = ( int ) ( 1e9 + 7 ) ; static long MOD = ( long ) ( 1e9 + 7 ) ; static FastReader in = new FastReader ( ) ; static PrintWriter pr = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; public static void main ( String args [ ] ) {   int tc = 1 ;
import java . util . * ; import java . lang . * ; import java . io . * ;  
import java . io . * ; import java . util . * ;     public class A {
import java . util . * ; import java . io . * ;   public class Bear_And_Prime_100 {   static class FastReader { BufferedReader br ; StringTokenizer st ;   public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; }   String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; }   int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }   long nextLong ( ) { return Long . parseLong ( next ( ) ) ; }   double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; }   String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; }   }   public static void shuffle ( int [ ] a ) { Random r = new Random ( ) ;   for ( int i = 0 ; i <= a . length - 2 ; i ++ ) { int j = i + r . nextInt ( a . length - i ) ;   swap ( a , i , j ) ; } }   public static void swap ( int [ ] a , int i , int j ) { int temp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = temp ; }   public static void main ( String [ ] args ) {
    import java . awt . * ; import java . io . IOException ; import java . util . Comparator ; import java . util . Scanner ;   public class Main {  
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Random ; import java . util . StringTokenizer ; import java . util . List ; import java . util . Collections ; import java . util . Map ; import java . util . HashMap ; import java . util . Comparator ; import java . util . stream . IntStream ; import java . util . ArrayDeque ; import java . util . PriorityQueue ; import java . util . Set ; import java . util . HashSet ; public class Main { private static FastScanner fs = new FastScanner ( ) ; private static PrintWriter out = new PrintWriter ( System . out ) ; public static void main ( String [ ] args ) { int n = fs . nextInt ( ) ; while ( n -- > 0 ) { int x = fs . nextInt ( ) , y = fs . nextInt ( ) , z = fs . nextInt ( ) ;   int arr [ ] = new int [ ] { x , y , z } ; Arrays . sort ( arr ) ; if ( arr [ 1 ] != arr [ 2 ] ) { System . out . println ( " NO " ) ; } else { System . out . println ( " YES " ) ; System . out . println ( arr [ 0 ] + " ▁ " + arr [ 0 ] + " ▁ " + arr [ 2 ] ) ; } }     } static class Node implements Comparable < Node > { Integer start ; Integer end ; public int compareTo ( Node a ) { int v = start . compareTo ( a . start ) ;
import java . io . * ; import java . util . * ; import java . math . * ;   public class B { public static void main ( String [ ] args ) throws IOException { FastScanner fs = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ;  
  import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . Comparator ; import java . util . Scanner ;       public class problem4 { public static void main ( String [ ] args ) { Scanner scan = new Scanner ( System . in ) ; int numClusters = scan . nextInt ( ) ; int numFiles = scan . nextInt ( ) ;   Clusters clusters = new Clusters ( numClusters ) ; clusters . loadClusters ( scan , numFiles ) ;   ArrayList < Move > moves = new ArrayList < Move > ( ) ;  
import java . util . * ; import java . io . * ; public class Main implements Runnable { FastScanner sc ; PrintWriter pw ; final class FastScanner { BufferedReader br ; StringTokenizer st ; public FastScanner ( ) { try { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } } public long nlo ( ) { return Long . parseLong ( next ( ) ) ; } public String next ( ) { if ( st . hasMoreTokens ( ) ) return st . nextToken ( ) ; try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; } return st . nextToken ( ) ; } public int ni ( ) { return Integer . parseInt ( next ( ) ) ; } public String nli ( ) { String line = " " ; if ( st . hasMoreTokens ( ) ) line = st . nextToken ( ) ; else try { return br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } while ( st . hasMoreTokens ( ) ) line += " ▁ " + st . nextToken ( ) ; return line ; } public double nd ( ) { return Double . parseDouble ( next ( ) ) ; } } public static void main ( String [ ] args ) { new Thread ( null , new Main ( ) , " codeforces " , 1 << 25 ) . start ( ) ; } public void run ( ) { sc = new FastScanner ( ) ; pw = new PrintWriter ( System . out ) ; solve ( ) ; pw . flush ( ) ; pw . close ( ) ; } public long gcd ( long a , long b ) { return b == 0L ? a : gcd ( b , a % b ) ; } public long ppow ( long a , long b , long mod ) { if ( b == 0L ) return 1L ; long tmp = 1 ; while ( b > 1L ) { if ( ( b & 1L ) == 1 ) tmp *= a ; a *= a ; a %= mod ; tmp %= mod ; b >>= 1 ; } return ( tmp * a ) % mod ; }
  import java . util . * ; import java . lang . * ; import java . io . * ; import java . math . * ;    public class file {   
import java . util . * ; import java . lang . * ; import java . io . * ;   public class FastIO { BufferedReader br ; StringTokenizer st ; public FastIO ( ) {
import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . OutputStreamWriter ; import java . io . PrintWriter ; import java . util . StringTokenizer ;   public class temp4 { static class FastReader { BufferedReader br ; StringTokenizer st ; public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; } String next ( ) { while ( st == null || ! st . hasMoreElements ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; } int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } long nextLong ( ) { return Long . parseLong ( next ( ) ) ; } double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; } String nextLine ( ) { String str = " " ; try { str = br . readLine ( ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } return str ; } } static class Print { private final BufferedWriter bw ; public Print ( ) { bw = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ; } public void print ( String str ) throws IOException { bw . append ( str ) ; } public void println ( String str ) throws IOException { print ( str ) ; bw . append ( " \n " ) ; } public void close ( ) throws IOException { bw . close ( ) ; } } public static void main ( String [ ] args ) throws IOException { FastReader scn = new FastReader ( ) ;
import java . util . * ;   public class Absolutezero {    public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int flag = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( i != s . length ( ) - 1 ) { char ch1 = s . charAt ( i + 1 ) ; if ( ch != ' a ' && ch != ' e ' && ch != ' i ' && ch != ' o ' && ch != ' u ' && ch != ' n ' ) { if ( ch1 == ' a ' || ch1 == ' e ' || ch1 == ' i ' || ch1 == ' o ' || ch1 == ' u ' ) {   } else { flag = 1 ; break ; } } } else { if ( ch == ' a ' || ch == ' e ' || ch == ' i ' || ch == ' o ' || ch == ' u ' || ch == ' n ' ) {   } else { flag = 1 ; break ; } } } if ( flag == 0 ) { System . out . println ( " YES " ) ; } else { System . out . println ( " NO " ) ; }    }   }  
  import java . io . FileInputStream ; import java . io . FileNotFoundException ; import java . io . PrintStream ; import java . util . ArrayList ; import java . util . Comparator ; import java . util . List ; import java . util . PriorityQueue ; import java . util . Scanner ;   public class P037B {   public class Spell { private int pow ; private int dmg ; private int index ; public Spell ( int pow , int dmg , int index ) { this . pow = pow ; this . dmg = dmg ; this . index = index ; }   public int getPow ( ) { return pow ; } public void setPow ( int pow ) { this . pow = pow ; } public int getDmg ( ) { return dmg ; } public void setDmg ( int dmg ) { this . dmg = dmg ; } public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } }   public class Cast { private int second ; private int index ; public Cast ( int second , int index ) { this . second = second ; this . index = index ; } public int getSecond ( ) { return second ; } public void setSecond ( int second ) { this . second = second ; } public int getIndex ( ) { return index ; } public void setIndex ( int index ) { this . index = index ; } } public void solve ( ) {
import java . io . * ; import java . util . * ; public class reconnaisance { public static void main ( String [ ] args ) throws IOException { BufferedReader f = new BufferedReader ( new InputStreamReader ( System . in ) ) ; PrintWriter out = new PrintWriter ( System . out ) ; StringTokenizer st = new StringTokenizer ( f . readLine ( ) ) ; int n = Integer . parseInt ( st . nextToken ( ) ) ; int d = Integer . parseInt ( st . nextToken ( ) ) ; int [ ] array = new int [ n ] ; int ans = 0 ; st = new StringTokenizer ( f . readLine ( ) ) ; for ( int i = 0 ; i < n ; i ++ ) { array [ i ] = Integer . parseInt ( st . nextToken ( ) ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( Math . abs ( array [ i ] - array [ j ] ) <= d ) { ans ++ ; } } } out . println ( ans - n ) ; out . close ( ) ; } }
import java . util . * ; import java . math . * ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ;  
import static java . lang . Integer . parseInt ; import static java . lang . Long . parseLong ; import static java . lang . Double . parseDouble ; import static java . lang . Math . PI ; import static java . lang . Math . min ; import static java . lang . System . arraycopy ; import static java . lang . System . exit ; import static java . util . Arrays . copyOf ;   import java . util . LinkedList ; import java . io . FileReader ; import java . io . FileWriter ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . HashMap ; import java . util . NoSuchElementException ; import java . util . PriorityQueue ; import java . util . StringTokenizer ; import java . util . Comparator ; import java . lang . StringBuilder ; import java . util . Collections ; public class Solution {   static int scanInt ( ) throws IOException { return parseInt ( scanString ( ) ) ; }   static long scanLong ( ) throws IOException { return parseLong ( scanString ( ) ) ; } static double scanDouble ( ) throws IOException { return parseDouble ( scanString ( ) ) ; }   static String scanString ( ) throws IOException { if ( tok == null || ! tok . hasMoreTokens ( ) ) { tok = new StringTokenizer ( in . readLine ( ) ) ; } return tok . nextToken ( ) ; } static String scanLine ( ) throws IOException { return in . readLine ( ) ; }   static void printCase ( String str ) { out . print ( " Case ▁ # " + test + " : ▁ " + str ) ; }   static void printlnCase ( ) { out . println ( " Case ▁ # " + test + " : " ) ; }   static BufferedReader in ; static PrintWriter out ; static StringTokenizer tok ; static int test ; static StringBuilder str ; public static void main ( String [ ] args ) { try { long startTime = System . currentTimeMillis ( ) ;   in = new BufferedReader ( new InputStreamReader ( System . in ) ) ; out = new PrintWriter ( System . out ) ;
import java . util . * ; public class ch1 { public static void main ( String [ ] args ) throws Exception { int a , b = 0 ; char ch ; Scanner reader = new Scanner ( System . in ) ; a = reader . nextInt ( ) ; String str = reader . next ( ) ; for ( int i = 0 ; i < a ; ++ i ) { if ( str . charAt ( i ) == ' + ' ) ++ b ; else if ( b > 0 ) -- b ; } System . out . print ( b ) ; } }
import java . util . * ; public class P2 {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int d = 0 ; int C = 0 ; int S = 0 ; if ( s . length ( ) >= 5 ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( s . charAt ( i ) >= 48 && s . charAt ( i ) <= 57 ) { d ++ ; } else if ( s . charAt ( i ) >= 65 && s . charAt ( i ) <= 90 ) { C ++ ; } else if ( s . charAt ( i ) >= 97 && s . charAt ( i ) <= 122 ) { S ++ ; } } if ( d >= 1 && C >= 1 && S >= 1 ) { System . out . println ( " Correct " ) ; } else { System . out . println ( " Too ▁ weak " ) ; } } else System . out . println ( " Too ▁ weak " ) ; } }  
import java . io . BufferedReader ; import java . io . InputStreamReader ; import java . io . PrintStream ; import java . util . * ;  
import java . io . * ; import java . lang . * ; import java . io . InputStream ; import java . io . InputStreamReader ; import java . io . BufferedReader ; import java . io . OutputStream ; import java . io . PrintWriter ; import java . io . IOException ; import java . util . Arrays ; import java . util . Random ; import java . util . StringTokenizer ; import java . math . BigInteger ;   public class Birthday {
import java . util . * ;   public class VasyaAndWrestling_B {   public static void main ( String [ ] args ) {
import java . util . Scanner ; public class AA { public static void main ( String [ ] args ) { int y , x ; Scanner ob = new Scanner ( System . in ) ; int a = ob . nextInt ( ) ; int b = ob . nextInt ( ) ; x = a / b ; y = a + x ; x = ( x + a % b ) ; while ( x > b ) { y += x / b ; x = ( x / b + x % b ) ; }   if ( x == b ) { y += 1 ; } System . out . println ( y ) ; } }
import java . util . * ; import java . io . * ; import java . math . BigInteger ; import java . text . * ; public class Main { static long mod = 1000_000_007 ; static long mod1 = 998244353 ; static boolean fileIO = false ; static boolean memory = true ; static FastScanner f ; static PrintWriter pw ; static double eps = ( double ) 1e-6 ; static int oo = ( int ) 1e9 ;   public static void solve ( ) throws Exception { int n = f . ni ( ) ; int k = f . ni ( ) ; int y = n / k ; StringBuffer ans = new StringBuffer ( " " ) ; for ( int i = 0 ; i < k ; ++ i ) { char c = ( char ) ( i + ' a ' ) ; for ( int j = 0 ; j < n / k ; ++ j ) { ans . append ( c ) ; } } int x = ans . length ( ) ; for ( int i = 0 ; i < n - x ; ++ i ) ans . append ( " a " ) ; pn ( ans ) ; } public static void main ( String [ ] args ) throws Exception { if ( memory ) new Thread ( null , new Runnable ( ) { public void run ( ) { try { new Main ( ) . run ( ) ; } catch ( Exception e ) { e . printStackTrace ( ) ; System . exit ( 1 ) ; } } } , " " , 1 << 28 ) . start ( ) ; else new Main ( ) . run ( ) ; } void run ( ) throws Exception { if ( System . getProperty ( " ONLINE _ JUDGE " ) == null ) { f = new FastScanner ( " " ) ; pw = new PrintWriter ( System . out ) ; } else { f = new FastScanner ( ) ; pw = new PrintWriter ( System . out ) ;
import java . io . * ; import java . util . * ; public class Main { static InputReader in = new InputReader ( System . in ) ; static PrintWriter out = new PrintWriter ( System . out ) ; static int oo = ( int ) 1e9 ;
import java . util . * ; import java . io . * ; import java . math . * ;     public class A {   private static long INF = 2000000000L , M = 1000000007 , MM = 998244353 ; private static int N = 0 ;   public static void process ( ) throws IOException {   int n = sc . nextInt ( ) , m = sc . nextInt ( ) ; String a [ ] = new String [ n + 1 ] ; String b [ ] = new String [ m + 1 ] ; for ( int i = 0 ; i < n ; i ++ ) a [ i ] = sc . next ( ) ; for ( int i = 0 ; i < m ; i ++ ) b [ i ] = sc . next ( ) ; int q = sc . nextInt ( ) ; while ( q -- != 0 ) { int nn = sc . nextInt ( ) - 1 ; int aa = nn % n ; int bb = nn % m ; println ( a [ aa ] + " " + b [ bb ] ) ; }   }  
import java . io . * ;   public class questionCF { public static void main ( String [ ] args ) throws IOException {   BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; String month [ ] = { " January " , " February " , " March " , " April " , " May " , " June " , " July " , " August " , " September " , " October " , " November " , " December " } ; String s = br . readLine ( ) ; int k = Integer . parseInt ( br . readLine ( ) ) ; int ind = 0 ; for ( int i = 0 ; i < month . length ; i ++ ) if ( month [ i ] . equals ( s ) ) { ind = i ; break ; } int mod = k % 12 ; if ( ( ind + mod ) >= 12 ) System . out . println ( month [ ( ind + mod ) - 12 ] ) ; else System . out . println ( month [ ind + mod ] ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . StringTokenizer ;   public class KvassAndFairNut { private static final FastReader in = new FastReader ( ) ; private static final PrintWriter out = new PrintWriter ( System . out ) ;   public static void main ( String [ ] args ) { Solver sol = new Solver ( ) ; int tt = 1 ; sol . solve ( tt ) ; out . close ( ) ; }   private static final class Solver { public void solve ( int testCase ) { int n = in . nextInt ( ) ; long s = Long . parseLong ( in . next ( ) ) ; int [ ] a = new int [ n ] ; long sum = 0L ; int min = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; ++ i ) { a [ i ] = in . nextInt ( ) ; sum += a [ i ] ; min = Math . min ( min , a [ i ] ) ; } if ( sum < s ) out . println ( - 1 ) ; else { out . println ( Math . min ( min , ( sum - s ) / n ) ) ; } } }   private static final class FastReader { private BufferedReader br ; private StringTokenizer st ;   public FastReader ( ) { br = new BufferedReader ( new InputStreamReader ( System . in ) , 1 << 16 ) ; st = null ; }   public String next ( ) { while ( st == null || ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { throw new RuntimeException ( e ) ; } } return st . nextToken ( ) ; }   public int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; } } }
import java . io . * ; import java . util . * ;   public class Solution { static MyScanner sc ; private static PrintWriter out ; static long M2 = 1_000_000_000L + 7 ;   public static void main ( String [ ] s ) throws Exception { StringBuilder stringBuilder = new StringBuilder ( ) ;
import java . util . Scanner ;   public class A {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int d = sc . nextInt ( ) ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = sc . nextInt ( ) ; while ( d > 0 ) { for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] > 0 ) { arr [ i - 1 ] ++ ; arr [ i ] -- ; break ; } } d -- ; } System . out . println ( arr [ 0 ] ) ; } } }  
import java . io . * ; import java . math . * ; import java . util . * ;   import static java . util . Arrays . fill ; import static java . lang . Math . * ; import static java . util . Arrays . sort ; import static java . util . Collections . sort ;   public class YoungTable {   public static int mod = 1000000007 ; public static long INF = ( 1L << 60 ) ; static FastScanner2 in = new FastScanner2 ( ) ; static OutputWriter out = new OutputWriter ( System . out ) ;   static class Pair { int x , y ; Pair ( int x , int y ) { this . x = x ; this . y = y ; } } public static void main ( String [ ] args ) {   Map < Integer , Pair > map = new HashMap < > ( ) ; int n = in . nextInt ( ) ; int [ ] a = new int [ n ] ; int [ ] [ ] b = new int [ 51 ] [ 51 ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = in . nextInt ( ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a [ i ] ; j ++ ) { int x = in . nextInt ( ) ; map . put ( x , new Pair ( i , j ) ) ; b [ i ] [ j ] = x ; } } int put = 1 ; int ans = 0 ; ArrayList < String > list = new ArrayList < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < a [ i ] ; j ++ ) { Pair p = map . get ( put ) ;
  import java . util . * ; import java . lang . * ; import java . io . * ;   public class Codechef { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner sc = new Scanner ( System . in ) ; int t ; t = sc . nextInt ( ) ; while ( t -- > 0 ) { int n = sc . nextInt ( ) ; int x = sc . nextInt ( ) ; int a = sc . nextInt ( ) ; int b = sc . nextInt ( ) ; int rem ; int mx = a > b ? a : b ; int mn = a < b ? a : b ; b = mx ; a = mn ; if ( a == 1 && b == n ) System . out . println ( n - 1 ) ; else if ( b + x > n ) { rem = ( b + x ) - n ; b = n ; if ( a - rem <= 0 ) a = 1 ; else a = a - rem ; System . out . println ( b - a ) ; } else System . out . println ( b + x - a ) ; } } }
import java . util . * ; import java . lang . * ; import java . io . * ;   public class A_Yellow_Cards { static BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; static BufferedWriter bw = new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ;
# include < bits / stdc ++ . h > using namespace std ; const int N = 1e6 + 7 ;   bool vis [ N ] ; int main ( ) { int n ; scanf ( " % d " , & n ) ; printf ( "1 ▁ " ) ; int y = n ; for ( int i = 1 ; i <= n ; i ++ ) { int x ; scanf ( " % d " , & x ) ; vis [ x ] = true ; while ( vis [ y ] ) y -- ; printf ( " % d ▁ " , 1 + i - ( n - y ) ) ; } return 0 ; }
import java . util . Scanner ;   public class main {   public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; int n = sc . nextInt ( ) ; int p1 = sc . nextInt ( ) ; int p2 = sc . nextInt ( ) ; int p3 = sc . nextInt ( ) ; int t1 = sc . nextInt ( ) ; int t2 = sc . nextInt ( ) ; int [ ] l = new int [ n ] ; int [ ] r = new int [ n ] ;   int totalTime = 0 ;   for ( int i = 0 ; i < n ; i ++ ) { l [ i ] = sc . nextInt ( ) ; r [ i ] = sc . nextInt ( ) ; }   for ( int i = 0 ; i < n ; i ++ ) { if ( i + 1 == n ) { totalTime += ( r [ i ] - l [ i ] ) * p1 ; } else { totalTime += ( r [ i ] - l [ i ] ) * p1 ; int timeLeft = l [ i + 1 ] - r [ i ] ; if ( timeLeft >= t1 + t2 ) { totalTime += t1 * p1 + t2 * p2 + ( timeLeft - t1 - t2 ) * p3 ; } else if ( timeLeft >= t1 ) { totalTime += t1 * p1 + ( timeLeft - t1 ) * p2 ; } else { totalTime += timeLeft * p1 ; } } }   System . out . print ( totalTime ) ; } }  
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . Arrays ; import java . util . HashMap ; import java . util . HashSet ; import java . util . StringTokenizer ;   public class B { static FastReader scan = new FastReader ( ) ; static PrintWriter out = new PrintWriter ( System . out ) ;   public static void main ( String [ ] args ) { Solver solver = new Solver ( ) ; int testCases = 1 ; while ( testCases -- > 0 ) solver . solve ( ) ; out . close ( ) ; }   static class Solver { void solve ( ) { int x = scan . nextInt ( ) ; while ( x -- > 0 ) { int n = scan . nextInt ( ) , l = scan . nextInt ( ) , r = scan . nextInt ( ) ; if ( l > n ) { out . println ( " No " ) ; } else { long get = n / l , diff = r - l , m = n % l ; if ( diff * get >= m ) out . println ( " Yes " ) ; else out . println ( " No " ) ; } } } }
import java . io . * ; import java . util . * ; public class Ishu { static Scanner scan = new Scanner ( System . in ) ; static void tc ( ) { int n = scan . nextInt ( ) ; int k = scan . nextInt ( ) ; int m = scan . nextInt ( ) ; long sum = 0l ; int [ ] a = new int [ n ] ; int i , j ; int [ ] oper = new int [ n ] ;   for ( i = 0 ; i < n ; ++ i ) { a [ i ] = scan . nextInt ( ) ; sum += a [ i ] ; } int last = a [ n - 1 ] ; int cur = n ; double ans = 0.0 ; Arrays . sort ( a , 0 , n ) ; i = 0 ; j = n - 1 ; int temp = m ; while ( m > 0 && i <= j ) { if ( cur == 1 ) { ans = a [ n - 1 ] + Math . min ( k - oper [ n - 1 ] , m ) ; break ; } double one = ( sum - a [ i ] ) / ( double ) ( cur - 1 ) ; double two = ( sum + 1 ) / ( double ) ( cur ) ; if ( one >= two ) { sum -= a [ i ++ ] ; cur -- ; ans = one ; } else { sum ++ ; a [ j ] ++ ; oper [ j ] ++ ; if ( oper [ j ] == k ) -- j ; ans = two ; } m -- ; } if ( temp >= n ) { temp -= n - 1 ; temp = Math . min ( temp , k ) ; ans = Math . max ( ans , temp + last ) ; } System . out . println ( ans ) ; } public static void main ( String [ ] args ) { int t = 1 ;
import java . util . Scanner ;   public class A1463 {   public static void main ( String [ ] args ) { Scanner in = new Scanner ( System . in ) ; int T = in . nextInt ( ) ; for ( int t = 0 ; t < T ; t ++ ) { int A = in . nextInt ( ) ; int B = in . nextInt ( ) ; int C = in . nextInt ( ) ; int sum = A + B + C ; boolean possible = ( sum % 9 == 0 ) && Math . min ( Math . min ( A , B ) , C ) >= sum / 9 ; System . out . println ( possible ? " YES " : " NO " ) ; } }   }
import java . util . * ; import java . util . Scanner ; import java . io . * ; import javax . lang . model . util . ElementScanner6 ; import static java . lang . System . out ; import java . util . Stack ; import java . util . Queue ; import java . util . LinkedList ;   public class B463M2 {   static int mod = ( int ) ( 1e9 + 7 ) ; static long MOD = ( long ) ( 1e9 + 7 ) ; static FastReader in = new FastReader ( ) ; static PrintWriter pr = new PrintWriter ( new BufferedWriter ( new OutputStreamWriter ( System . out ) ) ) ; public static void main ( String args [ ] ) {   int tc = 1 ;
import java . util . * ; import java . math . * ; import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . StringTokenizer ;  
import java . util . Scanner ;   public class A1426 { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int t = scanner . nextInt ( ) ; for ( int i = 0 ; i < t ; i ++ ) { int n = scanner . nextInt ( ) , x = scanner . nextInt ( ) , l ; if ( n == 1 || n == 2 ) { System . out . println ( 1 ) ; } if ( n > 2 ) { l = ( n - 2 ) / x ; if ( ( n - 2 ) % x == 0 ) { l ++ ; } else if ( ( n - 2 ) % x != 0 ) { l += 2 ; } System . out . println ( l ) ; } } } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . util . * ; public class div3_praca {
import java . io . * ; import java . util . * ; import java . util . List ;   public class AA implements Runnable { static int mod9 = 1000000007 ; public void run ( ) { InputReader sc = new InputReader ( System . in ) ; PrintWriter out = new PrintWriter ( System . out ) ; int i = 0 , j = 0 , k = 0 ; int t = 0 ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . math . BigInteger ; import java . util . * ;   import javafx . util . Pair ;   public class Main {   public static void main ( String [ ] args ) {   FastScanner input = new FastScanner ( ) ; int n = input . nextInt ( ) ; String s = input . next ( ) ; int letter [ ] = new int [ 26 ] ; int max = 0 ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) >= ' A ' && s . charAt ( i ) <= ' Z ' ) { count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( letter [ j ] > 0 ) count ++ ; } Arrays . fill ( letter , 0 ) ; max = Math . max ( max , count ) ; } else { letter [ s . charAt ( i ) - ' a ' ] ++ ; } } count = 0 ; for ( int j = 0 ; j < 26 ; j ++ ) { if ( letter [ j ] > 0 ) count ++ ; } max = Math . max ( max , count ) ; System . out . println ( max ) ;   }   static class FastScanner {   BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; StringTokenizer st = new StringTokenizer ( " " ) ;   String next ( ) { while ( ! st . hasMoreTokens ( ) ) { try { st = new StringTokenizer ( br . readLine ( ) ) ; } catch ( IOException e ) { e . printStackTrace ( ) ; } } return st . nextToken ( ) ; }   int nextInt ( ) { return Integer . parseInt ( next ( ) ) ; }   long nextLong ( ) {   return Long . parseLong ( next ( ) ) ; }   double nextDouble ( ) { return Double . parseDouble ( next ( ) ) ; }   String nextLine ( ) throws IOException { return br . readLine ( ) ; } }   }
import java . io . * ; import java . util . * ; public class Ishu { static Scanner scan = new Scanner ( System . in ) ; static void tc ( ) { long x = scan . nextLong ( ) ; long [ ] a = new long [ 100001 ] ; int i ; for ( i = 1 ; i <= 100000 ; ++ i ) a [ i ] = ( ( ( long ) ( i ) ) * ( i + 1 ) ) / 2 ; if ( x < 0 ) x *= ( - 1 ) ; int ans = 0 ; for ( i = 0 ; i < 100001 ; ++ i ) { if ( a [ i ] >= x ) { ans = i ; break ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; public class Main { PrintWriter out ; FastReader sc ; long mod = ( long ) ( 1e9 + 7 ) ; long maxlong = Long . MAX_VALUE ; long minlong = Long . MIN_VALUE ; public void sol ( ) { int [ ] ar = new int [ 4 ] ; int sum = 0 ; for ( int i = 0 ; i < 4 ; i ++ ) { ar [ i ] = ni ( ) ; sum += ar [ i ] ; } sort ( ar ) ; if ( ( sum - ar [ 3 ] ) == ar [ 3 ] || ( ar [ 0 ] + ar [ 3 ] ) == ( ar [ 1 ] + ar [ 2 ] ) ) yes ( ) ; else no ( ) ; } public static void main ( String [ ] args ) { Main g = new Main ( ) ; g . out = new PrintWriter ( System . out ) ; g . sc = new FastReader ( ) ; int t = 1 ;
import java . io . * ; import java . util . * ; import java . math . * ;
import java . io . BufferedReader ; import java . io . BufferedWriter ; import java . io . FileReader ; import java . io . FileWriter ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . HashMap ;   public class Wrath {   public static void main ( String [ ] args ) throws IOException {   BufferedReader ob = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( ob . readLine ( ) ) ; String s [ ] = ob . readLine ( ) . split ( " ▁ " ) ; int a [ ] = new int [ n ] ; for ( int i = 0 , j = n - 1 ; i < n ; i ++ , j -- ) { a [ i ] = Integer . parseInt ( s [ j ] ) ; } int count = 0 ; for ( int i = 0 ; i < n ; ) { int x = a [ i ] ; if ( x == 0 ) { i ++ ; continue ; } int y = i ; for ( int j = a [ i ] ; j >= 0 && i < n ; j -- , i ++ ) { if ( i == y ) continue ; int temp = a [ i ] ; j = Math . max ( temp , j ) ; count ++ ; } } System . out . println ( n - count ) ; } }
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . io . PrintWriter ; import java . math . BigInteger ; import java . util . ArrayList ; import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . List ; import java . util . PriorityQueue ; import java . util . Random ; import java . util . StringTokenizer ; import java . util . TreeSet ;   public class A {   public static void main ( String [ ] args ) throws IOException {   FastScanner sc = new FastScanner ( ) ; PrintWriter out = new PrintWriter ( System . out ) ; int n = sc . nextInt ( ) ; TreeSet < Long > set = new TreeSet < Long > ( ) ; int k = sc . nextInt ( ) ; ArrayList < Long > lis = new ArrayList < Long > ( ) ; lis . add ( 1L ) ; for ( int i = 1 ; i <= 100 ; i ++ ) { long sum = 0 ; int min = max ( 0 , i - k ) ; for ( int j = min ; j < i ; j ++ ) sum += lis . get ( j ) ; lis . add ( sum ) ; }
import java . util . * ;   public class ICPC { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; String s = sc . next ( ) ; int counta = 0 ; int countB = 0 ; int countb = 0 ; int countu = 0 ; int counts = 0 ; int countl = 0 ; int countr = 0 ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { char ch = s . charAt ( i ) ; if ( ch == ' a ' ) { counta ++ ; } else if ( ch == ' B ' ) { countB ++ ; } else if ( ch == ' b ' ) { countb ++ ; } else if ( ch == ' u ' ) { countu ++ ;   } else if ( ch == ' s ' ) { counts ++ ; } else if ( ch == ' l ' ) { countl ++ ; } else if ( ch == ' r ' ) { countr ++ ; }   } if ( counta >= 2 && countB > 0 && countb > 0 && countl > 0 && countr > 0 && counts > 0 && countu >= 2 ) { int [ ] ar = { countB , countb , countl , counts , countr , counta / 2 , countu / 2 } ; Arrays . sort ( ar ) ; System . out . println ( ar [ 0 ] ) ; } else { System . out . println ( 0 ) ; }      }      static int countSetBits ( int n ) { int count = 0 ; while ( n > 0 ) { count += n & 1 ; n >>= 1 ; } return count ; }   public List < Integer > getDivisors ( int n ) { List < Integer > list = new ArrayList < > ( ) ; for ( int d = 2 ; d * d <= n ; d ++ ) { while ( n % d == 0 ) { list . add ( d ) ; n /= d ; } } if ( n > 1 ) { list . add ( n ) ; } return list ; }   public int lcm ( int n1 , int n2 ) { int gcd = 1 ; for ( int i = 1 ; i <= n1 && i <= n2 ; ++ i ) {
   import java . io . File ; import java . io . FileWriter ; import java . io . IOException ; import java . math . BigInteger ; import java . util . * ;    public class Main { public static void main ( String [ ] args ) throws IOException { File f1 = new File ( " input . txt " ) ; File f2 = new File ( " output . txt " ) ; Scanner input = new Scanner ( f1 ) ; FileWriter output = new FileWriter ( f2 ) ; int n = input . nextInt ( ) ; String s = input . next ( ) ; char ch [ ] = s . toCharArray ( ) ; int L = 0 ; int R = 0 ; for ( int i = 0 , j = s . length ( ) / 2 ; i < s . length ( ) / 2 ; i ++ , j ++ ) { if ( ch [ i ] == ' L ' && ch [ j ] == ' L ' ) { output . write ( ( i + 1 ) + " ▁ " + ( j + 1 ) + " \n " ) ; } else if ( ch [ i ] == ' L ' && ch [ j ] == ' R ' ) { output . write ( ( i + 1 ) + " ▁ " + ( j + 1 ) + " \n " ) ; } else if ( ch [ i ] == ' R ' && ch [ j ] == ' R ' ) { output . write ( ( i + 1 ) + " ▁ " + ( j + 1 ) + " \n " ) ; } else { output . write ( ( j + 1 ) + " ▁ " + ( i + 1 ) + " \n " ) ; } } output . close ( ) ; } }  
import java . util . * ; import java . io . * ;
import java . io . * ; import java . util . * ; public class MyClass { public static void main ( String args [ ] ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( br . readLine ( ) ) ; String s [ ] = br . readLine ( ) . split ( " ▁ " ) ; int count = 0 ; int max = Integer . parseInt ( s [ 0 ] ) ; int min = Integer . parseInt ( s [ 0 ] ) ; for ( int i = 1 ; i < n ; i ++ ) { int val = Integer . parseInt ( s [ i ] ) ; if ( val > max ) { max = val ; count ++ ; } if ( val < min ) { min = val ; count ++ ; } } System . out . println ( count ) ; } }
import java . util . * ; public class General { public static void main ( String [ ] args ) { Scanner s = new Scanner ( System . in ) ; int n = s . nextInt ( ) ; int count = 0 ; int [ ] arr = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { arr [ i ] = s . nextInt ( ) ; } int min = arr [ 0 ] ; int index1 = 0 ; int max = arr [ 0 ] ; int index2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] > max ) { max = arr [ i ] ; index2 = i ; } else if ( arr [ i ] == max ) { if ( index2 > i ) { index2 = i ; } } if ( arr [ i ] < min ) { min = arr [ i ] ; index1 = i ; } else if ( arr [ i ] == min ) { if ( index1 < i ) { index1 = i ; } } } if ( n == 1 ) { System . out . println ( count ) ; } else { count = index2 + ( ( n - 1 ) - index1 ) ; if ( index1 < index2 ) { count -- ; } System . out . println ( count ) ; } } }
  import java . util . * ; import java . lang . * ; import java . io . * ;   public class Main { public static void main ( String [ ] args ) throws java . lang . Exception { Scanner in = new Scanner ( System . in ) ; double MOD = 1e9 + 7 ; long n = in . nextInt ( ) ; int [ ] [ ] m = new int [ ( int ) n + 2 ] [ ( int ) n + 2 ] ; m [ 1 ] [ 1 ] = 1 ; for ( int i = 2 ; i < n + 2 ; i ++ ) { m [ i ] [ 1 ] = m [ i - 1 ] [ i - 1 ] ; for ( int j = 2 ; j <= i ; j ++ ) m [ i ] [ j ] = ( int ) ( ( m [ i ] [ j - 1 ] + m [ i - 1 ] [ j - 1 ] ) % MOD ) ; } System . out . println ( m [ ( int ) ( n + 1 ) ] [ ( int ) n ] ) ; } }
  import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Scanner ; import java . util . StringTokenizer ; import java . util . * ; public class er10a {
import java . util . LinkedList ; import java . util . List ; import java . util . Scanner ;   public class Main { public static int [ ] arr = new int [ 150000 + 1 ] ; public static int find ( int i ) { return arr [ i ] == i ? i : ( arr [ i ] = find ( arr [ i ] ) ) ; } public static void merge ( int x , int y ) { int xp = find ( x ) ; int yp = find ( y ) ; arr [ yp ] = xp ; }   public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int n = scanner . nextInt ( ) ; int m = scanner . nextInt ( ) ; int [ ] count = new int [ n + 1 ] ; long [ ] p = new long [ n + 1 ] ; for ( int i = 0 ; i < arr . length ; i ++ ) { arr [ i ] = i ; } List < Integer > lines = new LinkedList < > ( ) ; for ( int i = 0 ; i < m ; i ++ ) { int x = scanner . nextInt ( ) ; int y = scanner . nextInt ( ) ; lines . add ( x ) ; merge ( x , y ) ; } for ( Integer x : lines ) { count [ find ( x ) ] += 1 ; } for ( int i = 0 ; i < n + 1 ; i ++ ) { p [ find ( i ) ] += 1 ; } for ( int i = 0 ; i < n + 1 ; i ++ ) { if ( i == find ( i ) ) { if ( p [ i ] * ( p [ i ] - 1 ) / 2 != count [ i ] ) { System . out . println ( " NO " ) ; return ; } } } System . out . println ( " YES " ) ;   } }
import java . util . Scanner ;   public class NewMain {   public static void main ( String [ ] args ) {
import java . util . Scanner ; import java . util . ArrayList ; import java . util . Collections ; import java . util . List ; public class question { public static void main ( String args [ ] ) { Scanner scan = new Scanner ( System . in ) ; int n , k , p , x , y , flag = 0 ; List < Integer > arrtest = new ArrayList < > ( ) ; List < Integer > solution = new ArrayList < > ( ) ; n = scan . nextInt ( ) ; k = scan . nextInt ( ) ; p = scan . nextInt ( ) ; x = scan . nextInt ( ) ; y = scan . nextInt ( ) ; for ( int i = 0 ; i < k ; i ++ ) { arrtest . add ( scan . nextInt ( ) ) ; }
import java . util . * ; public class XeniaandDivisors {   public static void main ( String [ ] args ) {
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ;   public class CF1343A { public static void main ( String [ ] args ) throws IOException { BufferedReader br = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int t = Integer . parseInt ( br . readLine ( ) ) ; while ( t -- > 0 ) { long n = Long . parseLong ( br . readLine ( ) ) ; for ( int k = 29 ; k > 1 ; k -- ) { int num = ( int ) Math . pow ( 2 , k ) - 1 ; if ( ( n % num ) == 0 ) { System . out . println ( String . format ( " % s " , n / num ) ) ; break ; } } } } }
import java . io . * ; import java . util . * ;   public class Task1103B { private static InputReader in ; private static PrintWriter out ; private static boolean autoFlush = true ; static final int inf = ( int ) 1e9 + 7 ; static final long infL = ( long ) 1e18 + 7 ;   static class Testcase { public boolean ask ( int x , int y ) { int a = 1 ; boolean b = ( x % a < y % a ) ; out . println ( b ? " y " : " x " ) ; return b ; }   public boolean query ( int x , int y ) {
import java . util . Arrays ; import java . util . Collections ; import java . util . HashMap ; import java . util . HashSet ; import java . util . Map ; import java . util . Scanner ; import java . util . Set ; import java . util . Vector ; public class NewClass1 { public static void main ( String [ ] args ) { Scanner ob = new Scanner ( System . in ) ; int t = ob . nextInt ( ) ; while ( t -- > 0 ) { int n = ob . nextInt ( ) ; int a [ ] = new int [ n ] ; int b [ ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ob . nextInt ( ) ; b [ a [ i ] - 1 ] = i ; } int s ; int e = n ; for ( int i = a . length - 1 ; i >= 0 ; i -- ) { s = b [ i ] ; if ( s < e ) { for ( int j = s ; j < e ; j ++ ) { System . out . print ( a [ j ] + " ▁ " ) ; } e = s ; } } System . out . println ( ) ; } } }
import java . io . * ; import java . util . * ;
import java . io . BufferedReader ; import java . io . IOException ; import java . io . InputStreamReader ; import java . util . Arrays ; import java . util . StringTokenizer ;   public class Solution { public static void main ( String [ ] args ) throws IOException { BufferedReader reader = new BufferedReader ( new InputStreamReader ( System . in ) ) ; int n = Integer . parseInt ( reader . readLine ( ) ) ; long [ ] dp = new long [ n + 1 ] ; Arrays . fill ( dp , Long . MAX_VALUE ) ; dp [ 0 ] = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { StringTokenizer sToken = new StringTokenizer ( reader . readLine ( ) ) ; int t = Integer . parseInt ( sToken . nextToken ( ) ) ; int x = Integer . parseInt ( sToken . nextToken ( ) ) ; for ( int j = n ; j > - 1 ; j -- ) { if ( dp [ Math . max ( 0 , j - t - 1 ) ] == Long . MAX_VALUE ) continue ; dp [ j ] = Math . min ( dp [ j ] , dp [ Math . max ( 0 , j - t - 1 ) ] + x ) ; } } System . out . println ( dp [ n ] ) ; } }
import java . util . * ; public class Sol { public static void main ( String args [ ] ) { Scanner ob = new Scanner ( System . in ) ; int m = ob . nextInt ( ) ; int t = 0 ; while ( m > 0 ) { if ( m >= 100 ) { m -= 100 ; t ++ ; continue ; } else if ( m >= 20 ) { m -= 20 ; t ++ ; continue ; } else if ( m >= 10 ) { m -= 10 ; t ++ ; continue ; } else if ( m >= 5 ) { m -= 5 ; t ++ ; continue ; } else { m -= 1 ; t ++ ; } } System . out . println ( t ) ; } }
import java . util . Scanner ;   public class Parallelepiped { public static void main ( String [ ] args ) { Scanner scanner = new Scanner ( System . in ) ; int s1 = scanner . nextInt ( ) ; int s2 = scanner . nextInt ( ) ; int s3 = scanner . nextInt ( ) ; int a = ( int ) Math . sqrt ( ( s1 * s3 ) / s2 ) ; int b = ( int ) Math . sqrt ( ( s1 * s2 ) / s3 ) ; int c = ( int ) Math . sqrt ( ( s2 * s3 ) / s1 ) ; System . out . println ( 4 * ( a + b + c ) ) ; } }
import java . util . * ; import java . math . * ; public class KsenaiPan { public static void main ( String [ ] args ) { Scanner sc = new Scanner ( System . in ) ; char [ ] arr = sc . next ( ) . toCharArray ( ) ; ArrayList < Character > l = new ArrayList < > ( ) ; ArrayList < Character > r = new ArrayList < > ( ) ; boolean fl = false ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] == ' | ' ) fl = true ; else { if ( ! fl ) { l . add ( arr [ i ] ) ; } else r . add ( arr [ i ] ) ; } } char [ ] in = sc . next ( ) . toCharArray ( ) ; for ( int i = 0 ; i < in . length ; i ++ ) { if ( l . size ( ) < r . size ( ) ) l . add ( in [ i ] ) ; else r . add ( in [ i ] ) ; } if ( l . size ( ) == r . size ( ) ) { for ( char out : l ) System . out . print ( out ) ; System . out . print ( " | " ) ; for ( char out : r ) System . out . print ( out ) ; } else System . out . println ( " Impossible " ) ; } }
import java . io . * ; class GFG { static int gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return gcd ( a - b , b ) ; return gcd ( a , b - a ) ; } static int cpFact ( int x , int y ) { while ( gcd ( x , y ) != 1 ) { x = x / gcd ( x , y ) ; } return x ; } public static void main ( String [ ] args ) { int x = 15 ; int y = 3 ; System . out . println ( cpFact ( x , y ) ) ; x = 14 ; y = 28 ; System . out . println ( cpFact ( x , y ) ) ; x = 7 ; y = 3 ; System . out . println ( cpFact ( x , y ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static long powerNumbers ( int n ) { HashSet < Long > v = new HashSet < Long > ( ) ; for ( long i = 2 ; i * i * i <= n ; i ++ ) { long j = i * i ; while ( j * i <= n ) { j *= i ; long s = ( long ) Math . sqrt ( j ) ; if ( s * s != j ) v . add ( j ) ; } } return v . size ( ) + ( long ) Math . sqrt ( n ) ; } public static void main ( String args [ ] ) { System . out . print ( powerNumbers ( 50 ) ) ; } }
import java . util . * ; class GFG { static void nPermute ( char [ ] str , int n ) { Arrays . sort ( str ) ; int i = 1 ; do { if ( i == n ) break ; i ++ ; } while ( next_permutation ( str ) ) ; System . out . println ( String . valueOf ( str ) ) ; } static boolean next_permutation ( char [ ] p ) { for ( int a = p . length - 2 ; a >= 0 ; -- a ) if ( p [ a ] < p [ a + 1 ] ) for ( int b = p . length - 1 ; ; -- b ) if ( p [ b ] > p [ a ] ) { char t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; for ( ++ a , b = p . length - 1 ; a < b ; ++ a , -- b ) { t = p [ a ] ; p [ a ] = p [ b ] ; p [ b ] = t ; } return true ; } return false ; } public static void main ( String [ ] args ) { String str = " GEEKSFORGEEKS " ; int n = 100 ; nPermute ( str . toCharArray ( ) , n ) ; } }
import java . util . * ; class GFG { static int sz = ( int ) 1e3 ; static HashSet < Integer > fib = new HashSet < Integer > ( ) ; static void fibonacci ( ) { int prev = 0 , curr = 1 , len = 2 ; fib . add ( prev ) ; fib . add ( curr ) ; while ( len <= sz ) { int temp = curr + prev ; fib . add ( temp ) ; prev = curr ; curr = temp ; len ++ ; } } static void printArray ( int arr [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } static void removeFibonacci ( int arr [ ] , int len ) { fibonacci ( ) ; for ( int i = 0 ; i < len ; i ++ ) { if ( fib . contains ( arr [ i ] ) ) { for ( int j = i ; j < len - 1 ; j ++ ) { arr [ j ] = arr [ j + 1 ] ; } i -- ; len -- ; } } printArray ( arr , len ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 6 , 5 , 3 , 8 , 7 , 10 , 11 , 14 , 15 } ; int len = arr . length ; removeFibonacci ( arr , len ) ; } }
class GFG { static long product ( int [ ] [ ] mat , int n ) { long d1 = 0 , d2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { d1 += mat [ i ] [ i ] ; d2 += mat [ i ] [ n - i - 1 ] ; } return 1L * d1 * d2 ; } public static void main ( String [ ] args ) { int [ ] [ ] mat = { { 5 , 8 , 1 } , { 5 , 10 , 3 } , { - 6 , 17 , - 9 } } ; int n = mat . length ; System . out . print ( product ( mat , n ) ) ; } }
import java . util . * ; public class GfG { private static String remainingDigit ( String S , int N ) { char c [ ] = S . toCharArray ( ) ; int del [ ] = { 0 , 0 } ; int count [ ] = { 0 , 0 } ; Queue < Integer > q = new LinkedList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { int x = c [ i ] == '1' ? 1 : 0 ; count [ x ] ++ ; q . add ( x ) ; } while ( count [ 0 ] > 0 && count [ 1 ] > 0 ) { int t = q . poll ( ) ; if ( del [ t ] > 0 ) { del [ t ] -- ; count [ t ] -- ; } else { del [ t ^ 1 ] ++ ; q . add ( t ) ; } } if ( count [ 0 ] > 0 ) return "0" ; return "1" ; } public static void main ( String args [ ] ) { String S = "1010100100000" ; int N = S . length ( ) ; System . out . print ( remainingDigit ( S , N ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void incrementVector ( Vector < Integer > a ) { int n = a . size ( ) ; a . set ( n - 1 , a . get ( n - 1 ) + 1 ) ; int carry = a . get ( n - 1 ) / 10 ; a . set ( n - 1 , a . get ( n - 1 ) % 10 ) ; for ( int i = n - 2 ; i >= 0 ; i -- ) { if ( carry == 1 ) { a . set ( i , a . get ( i ) + 1 ) ; carry = a . get ( i ) / 10 ; a . set ( i , a . get ( i ) % 10 ) ; } } if ( carry == 1 ) a . add ( 0 , 1 ) ; } public static void main ( String [ ] args ) { Vector < Integer > vect = new Vector < Integer > ( ) ; vect . add ( 1 ) ; vect . add ( 7 ) ; vect . add ( 8 ) ; vect . add ( 9 ) ; incrementVector ( vect ) ; for ( int i = 0 ; i < vect . size ( ) ; i ++ ) System . out . print ( vect . get ( i ) + " ▁ " ) ; } }
import java . util . * ; class GFG { static int max_element ( int a [ ] ) { int m = a [ 0 ] ; for ( int i = 0 ; i < a . length ; i ++ ) m = Math . max ( a [ i ] , m ) ; return m ; } static int primeCount ( int arr [ ] , int n ) { int max_val = max_element ( arr ) ; boolean prime [ ] = new boolean [ max_val + 1 ] ; for ( int p = 0 ; p <= max_val ; p ++ ) prime [ p ] = true ; prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( prime [ arr [ i ] ] ) count ++ ; return count ; } static int [ ] getPrefixArray ( int arr [ ] , int n , int pre [ ] ) { pre [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { pre [ i ] = pre [ i - 1 ] + arr [ i ] ; } return pre ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 8 , 4 } ; int n = arr . length ; int pre [ ] = new int [ n ] ; pre = getPrefixArray ( arr , n , pre ) ; System . out . println ( primeCount ( pre , n ) ) ; } }
class GFG { static int sum ( int k , int n ) { int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) { int p = 1 ; for ( int j = 0 ; j < n - i ; j ++ ) { p = p * k ; } for ( int j = 0 ; j < i ; j ++ ) { p = p * ( k - 1 ) ; } sum = sum + p ; } return sum ; } public static void main ( String [ ] args ) { int n = 3 ; int K = 3 ; System . out . println ( sum ( K , n ) ) ; } }
class GFG { static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; } static int countIntegers ( long l , long r ) { long ans = 0 , i = 1 ; long v = power ( 2 , i ) ; while ( v <= r ) { while ( v <= r ) { if ( v >= l ) ans ++ ; v = v * 3 ; } i ++ ; v = power ( 2 , i ) ; } if ( l == 1 ) ans ++ ; return ( int ) ans ; } public static void main ( String [ ] args ) { long l = 12 , r = 21 ; System . out . println ( countIntegers ( l , r ) ) ; } }
class GFG { static final int DP_s = 9 ; static int getNumMonotone ( int len ) { int [ ] [ ] DP = new int [ len ] [ DP_s ] ; for ( int i = 0 ; i < DP_s ; ++ i ) DP [ 0 ] [ i ] = i + 1 ; for ( int i = 0 ; i < len ; ++ i ) DP [ i ] [ 0 ] = 1 ; for ( int i = 1 ; i < len ; ++ i ) for ( int j = 1 ; j < DP_s ; ++ j ) DP [ i ] [ j ] = DP [ i - 1 ] [ j ] + DP [ i ] [ j - 1 ] ; return DP [ len - 1 ] [ DP_s - 1 ] ; } public static void main ( String [ ] args ) { System . out . println ( getNumMonotone ( 10 ) ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { System . out . println ( Integer . bitCount ( 4 ) ) ; System . out . println ( Integer . bitCount ( 15 ) ) ; } }
class Node { int data ; Node left , right ; Node ( int item ) { data = item ; left = right = null ; } } class BinaryTree { Node root ; void printPaths ( Node node ) { int path [ ] = new int [ 1000 ] ; printPathsRecur ( node , path , 0 ) ; } void printPathsRecur ( Node node , int path [ ] , int pathLen ) { if ( node == null ) return ; path [ pathLen ] = node . data ; pathLen ++ ; if ( node . left == null && node . right == null ) printArray ( path , pathLen ) ; else { printPathsRecur ( node . left , path , pathLen ) ; printPathsRecur ( node . right , path , pathLen ) ; } } void printArray ( int ints [ ] , int len ) { int i ; for ( i = 0 ; i < len ; i ++ ) { System . out . print ( ints [ i ] + " ▁ " ) ; } System . out . println ( " " ) ; } public static void main ( String args [ ] ) { BinaryTree tree = new BinaryTree ( ) ; tree . root = new Node ( 10 ) ; tree . root . left = new Node ( 8 ) ; tree . root . right = new Node ( 2 ) ; tree . root . left . left = new Node ( 3 ) ; tree . root . left . right = new Node ( 5 ) ; tree . root . right . left = new Node ( 2 ) ; tree . printPaths ( tree . root ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int countRectangles ( int l , int w ) { int squareSide = __gcd ( l , w ) ; return ( l * w ) / ( squareSide * squareSide ) ; } public static void main ( String [ ] args ) { int l = 4 , w = 6 ; System . out . println ( countRectangles ( l , w ) ) ; } }
class GFG { static void factorize ( long n ) { int count = 0 ; while ( ! ( n % 2 > 0 ) ) { n >>= 1 ; count ++ ; } if ( count > 0 ) { System . out . println ( "2" + " ▁ " + count ) ; } for ( long i = 3 ; i <= ( long ) Math . sqrt ( n ) ; i += 2 ) { count = 0 ; while ( n % i == 0 ) { count ++ ; n = n / i ; } if ( count > 0 ) { System . out . println ( i + " ▁ " + count ) ; } } if ( n > 2 ) { System . out . println ( n + " ▁ " + "1" ) ; } } public static void main ( String [ ] args ) { long n = 1000000000000000000L ; factorize ( n ) ; } }
class GFG { static class Node { int data ; Node left , right ; } ; static class INT { int a ; INT ( int a ) { this . a = a ; } } static Node newNode ( int data ) { Node temp = new Node ( ) ; temp . data = data ; temp . left = temp . right = null ; return temp ; } static void printInorder ( Node node ) { if ( node == null ) return ; printInorder ( node . left ) ; System . out . printf ( " % d ▁ " , node . data ) ; printInorder ( node . right ) ; } static Node conBinaryTreeUtil ( int pre [ ] , int preM [ ] , INT preIndex , int l , int h , int size ) { if ( preIndex . a >= size || l > h ) return null ; Node root = newNode ( pre [ preIndex . a ] ) ; ++ ( preIndex . a ) ; if ( l == h ) return root ; int i ; for ( i = l ; i <= h ; ++ i ) if ( pre [ preIndex . a ] == preM [ i ] ) break ; if ( i <= h ) { root . left = conBinaryTreeUtil ( pre , preM , preIndex , i , h , size ) ; root . right = conBinaryTreeUtil ( pre , preM , preIndex , l + 1 , i - 1 , size ) ; } return root ; } static void conBinaryTree ( Node root , int pre [ ] , int preMirror [ ] , int size ) { INT preIndex = new INT ( 0 ) ; int preMIndex = 0 ; root = conBinaryTreeUtil ( pre , preMirror , preIndex , 0 , size - 1 , size ) ; printInorder ( root ) ; } public static void main ( String args [ ] ) { int preOrder [ ] = { 1 , 2 , 4 , 5 , 3 , 6 , 7 } ; int preOrderMirror [ ] = { 1 , 3 , 7 , 6 , 2 , 5 , 4 } ; int size = preOrder . length ; Node root = new Node ( ) ; conBinaryTree ( root , preOrder , preOrderMirror , size ) ; } }
class GFG { static int checkIfStartsWithCapital ( String str ) { if ( str . charAt ( 0 ) >= ' A ' && str . charAt ( 0 ) <= ' Z ' ) return 1 ; else return 0 ; } static void check ( String str ) { if ( checkIfStartsWithCapital ( str ) == 1 ) System . out . println ( " Accepted " ) ; else System . out . println ( " Not ▁ Accepted " ) ; } public static void main ( String [ ] args ) { String str = " GeeksforGeeks " ; check ( str ) ; str = " geeksforgeeks " ; check ( str ) ; } }
class Test { static boolean checkPolygonWithMidpoints ( int arr [ ] , int N , int midpoints ) { for ( int j = 0 ; j < midpoints ; j ++ ) { int val = 1 ; for ( int k = j ; k < N ; k += midpoints ) { val &= arr [ k ] ; } if ( val != 0 && N / midpoints > 2 ) { System . out . println ( " Polygon ▁ possible ▁ with ▁ side ▁ length ▁ " + N / midpoints ) ; return true ; } } return false ; } static void isPolygonPossible ( int arr [ ] , int N ) { int limit = ( int ) Math . sqrt ( N ) ; for ( int i = 1 ; i <= limit ; i ++ ) { if ( N % i == 0 ) { if ( checkPolygonWithMidpoints ( arr , N , i ) || checkPolygonWithMidpoints ( arr , N , ( N / i ) ) ) return ; } } System . out . println ( " Not ▁ possible " ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 0 , 1 , 0 , 1 , 0 , 1 , 0 , 1 , 1 } ; isPolygonPossible ( arr , arr . length ) ; } }
class GFG { static boolean isToOne ( int n ) { return ( n > 0 ) ; } public static void main ( String [ ] args ) { int n = 5 ; if ( isToOne ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int distinctSubString ( String P , int N ) { HashSet < String > S = new HashSet < String > ( ) ; for ( int i = 0 ; i < N ; ++ i ) { boolean [ ] freq = new boolean [ 26 ] ; String s = " " ; for ( int j = i ; j < N ; ++ j ) { int pos = P . charAt ( j ) - ' a ' ; if ( freq [ pos ] == true ) break ; freq [ pos ] = true ; s += P . charAt ( j ) ; S . add ( s ) ; } } return S . size ( ) ; } public static void main ( String [ ] args ) { String S = " abba " ; int N = S . length ( ) ; System . out . print ( distinctSubString ( S , N ) ) ; } }
class Solution { static int minimumX ( int n , int k ) { int ans = Integer . MAX_VALUE ; for ( int rem = k - 1 ; rem > 0 ; rem -- ) { if ( n % rem == 0 ) ans = Math . min ( ans , rem + ( n / rem ) * k ) ; } return ans ; } public static void main ( String args [ ] ) { int n = 4 , k = 6 ; System . out . println ( minimumX ( n , k ) ) ; n = 5 ; k = 5 ; System . out . println ( minimumX ( n , k ) ) ; } }
import java . util . * ; class solution { static int findMinDifference ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; int diff1 = arr [ n - 1 ] - arr [ 1 ] ; int diff2 = arr [ n - 2 ] - arr [ 0 ] ; return Math . min ( diff1 , diff2 ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 4 , 3 , 4 } ; int n = arr . length ; System . out . print ( findMinDifference ( arr , n ) ) ; } }
import java . io . * ; class GFG { public static void main ( String [ ] args ) { int a = 5 , b = 7 , c = 10 ; if ( a <= b && a <= c ) System . out . println ( a + " ▁ is ▁ the ▁ smallest " ) ; else if ( b <= a && b <= c ) System . out . println ( b + " ▁ is ▁ the ▁ smallest " ) ; else System . out . println ( c + " ▁ is ▁ the ▁ smallest " ) ; } }
class GFG { static int MAX = 100005 ; static boolean [ ] isPrime = new boolean [ MAX ] ; static void sieveOfEratostheneses ( ) { isPrime [ 1 ] = true ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( ! isPrime [ i ] ) { for ( int j = 2 * i ; j < MAX ; j += i ) isPrime [ j ] = true ; } } } static int findPrime ( int n ) { int num = n + 1 ; while ( num > 0 ) { if ( ! isPrime [ num ] ) return num ; num = num + 1 ; } return 0 ; } static int minNumber ( int arr [ ] , int n ) { sieveOfEratostheneses ( ) ; int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; if ( ! isPrime [ sum ] ) return 0 ; int num = findPrime ( sum ) ; return num - sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 6 , 8 , 12 } ; int n = arr . length ; System . out . println ( minNumber ( arr , n ) ) ; } }
class GFG { static boolean isPower ( int n ) { for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int y = 2 ; double p = Math . pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) return true ; y ++ ; p = Math . pow ( x , y ) ; } } return false ; } public static void main ( String [ ] args ) { for ( int i = 2 ; i < 100 ; i ++ ) if ( isPower ( i ) ) System . out . print ( i + " ▁ " ) ; } }
import java . io . * ; class GFG { static int minMovesToSort ( int arr [ ] , int n ) { int moves = 0 ; int i , mn = arr [ n - 1 ] ; for ( i = n - 2 ; i >= 0 ; i -- ) { if ( arr [ i ] > mn ) moves += arr [ i ] - mn ; mn = arr [ i ] ; } return moves ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 5 , 2 , 8 , 4 } ; int n = arr . length ; System . out . println ( minMovesToSort ( arr , n ) ) ; } }
import java . util . * ; class GFG { static class Node { Node left ; Node right ; int data ; Node ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } ; static class Info { int num_BST ; int max ; int min ; boolean isBST ; Info ( int a , int b , int c , boolean d ) { num_BST = a ; max = b ; min = c ; isBST = d ; } Info ( ) { } } ; static Info NumberOfBST ( Node root ) { if ( root == null ) return new Info ( 0 , Integer . MIN_VALUE , Integer . MAX_VALUE , true ) ; if ( root . left == null && root . right == null ) return new Info ( 1 , root . data , root . data , true ) ; Info L = NumberOfBST ( root . left ) ; Info R = NumberOfBST ( root . right ) ; Info bst = new Info ( ) ; bst . min = Math . min ( root . data , ( Math . min ( L . min , R . min ) ) ) ; bst . max = Math . max ( root . data , ( Math . max ( L . max , R . max ) ) ) ; if ( L . isBST && R . isBST && root . data > L . max && root . data < R . min ) { bst . isBST = true ; bst . num_BST = 1 + L . num_BST + R . num_BST ; } else { bst . isBST = false ; bst . num_BST = L . num_BST + R . num_BST ; } return bst ; } public static void main ( String args [ ] ) { Node root = new Node ( 5 ) ; root . left = new Node ( 9 ) ; root . right = new Node ( 3 ) ; root . left . left = new Node ( 6 ) ; root . right . right = new Node ( 4 ) ; root . left . left . left = new Node ( 8 ) ; root . left . left . right = new Node ( 7 ) ; System . out . print ( NumberOfBST ( root ) . num_BST ) ; } }
import java . io . * ; public class GFG { static int calculateSum ( int n ) { return ( int ) ( ( 2 * Math . pow ( ( n * ( n + 1 ) / 2 ) , 2 ) ) ) + ( ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( " Sum ▁ = ▁ " + calculateSum ( n ) ) ; } }
class GFG { static boolean isNonHypotenuse ( int n ) { while ( n % 2 == 0 ) { n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { if ( n % i == 0 ) { if ( ( i - 1 ) % 4 == 0 ) return false ; while ( n % i == 0 ) { n = n / i ; } } } if ( n > 2 && ( n - 1 ) % 4 == 0 ) return false ; else return true ; } public static void test ( int n ) { System . out . println ( " Testing ▁ for ▁ " + n + " ▁ : ▁ " ) ; if ( isNonHypotenuse ( n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } public static void main ( String args [ ] ) { int n = 11 ; test ( n ) ; n = 10 ; test ( n ) ; } }
import java . io . * ; class GFG { static void printSquares ( int n ) { int square = 0 , odd = 1 ; for ( int x = 0 ; x < n ; x ++ ) { System . out . print ( square + " ▁ " ) ; square = square + odd ; odd = odd + 2 ; } } public static void main ( String [ ] args ) { int n = 5 ; printSquares ( n ) ; } }
class GFG { static String revAlternateK ( String s , int k , int len ) { for ( int i = 0 ; i < s . length ( ) ; ) { if ( i + k > len ) break ; s = s . substring ( 0 , i ) + new String ( new StringBuilder ( s . substring ( i , i + k ) ) . reverse ( ) ) + s . substring ( i + k ) ; i += 2 * k ; } return s ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int len = s . length ( ) ; int k = 3 ; System . out . println ( revAlternateK ( s , k , len ) ) ; } }
import java . io . * ; class GFG { static int countRotationsDivBy8 ( String n ) { int len = n . length ( ) ; int count = 0 ; if ( len == 1 ) { int oneDigit = n . charAt ( 0 ) - '0' ; if ( oneDigit % 8 == 0 ) return 1 ; return 0 ; } if ( len == 2 ) { int first = ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; int second = ( n . charAt ( 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( first % 8 == 0 ) count ++ ; if ( second % 8 == 0 ) count ++ ; return count ; } int threeDigit ; for ( int i = 0 ; i < ( len - 2 ) ; i ++ ) { threeDigit = ( n . charAt ( i ) - '0' ) * 100 + ( n . charAt ( i + 1 ) - '0' ) * 10 + ( n . charAt ( i + 2 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; } threeDigit = ( n . charAt ( len - 1 ) - '0' ) * 100 + ( n . charAt ( 0 ) - '0' ) * 10 + ( n . charAt ( 1 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; threeDigit = ( n . charAt ( len - 2 ) - '0' ) * 100 + ( n . charAt ( len - 1 ) - '0' ) * 10 + ( n . charAt ( 0 ) - '0' ) ; if ( threeDigit % 8 == 0 ) count ++ ; return count ; } public static void main ( String [ ] args ) { String n = "43262488612" ; System . out . println ( " Rotations : ▁ " + countRotationsDivBy8 ( n ) ) ; } }
class GFG { static void printValue ( char digit ) { switch ( digit ) { case '0' : System . out . print ( " Zero ▁ " ) ; break ; case '1' : System . out . print ( " One ▁ " ) ; break ; case '2' : System . out . print ( " Two ▁ " ) ; break ; case '3' : System . out . print ( " Three ▁ " ) ; break ; case '4' : System . out . print ( " Four ▁ " ) ; break ; case '5' : System . out . print ( " Five ▁ " ) ; break ; case '6' : System . out . print ( " Six ▁ " ) ; break ; case '7' : System . out . print ( " Seven ▁ " ) ; break ; case '8' : System . out . print ( " Eight ▁ " ) ; break ; case '9' : System . out . print ( " Nine ▁ " ) ; break ; } } static void printWord ( String N ) { int i , length = N . length ( ) ; for ( i = 0 ; i < length ; i ++ ) { printValue ( N . charAt ( i ) ) ; } } public static void main ( String [ ] args ) { String N = "123" ; printWord ( N ) ; } }
class GFG { static int findSplTripletsSum ( int a [ ] , int b [ ] , int c [ ] , int p , int q , int r ) { int sum = 0 ; for ( int i = 0 ; i < p ; i ++ ) { for ( int j = 0 ; j < q ; j ++ ) { for ( int k = 0 ; k < r ; k ++ ) { if ( a [ i ] <= b [ j ] && c [ k ] <= b [ j ] ) { sum += ( a [ i ] + b [ j ] ) * ( b [ j ] + c [ k ] ) ; } } } } return sum ; } public static void main ( String [ ] args ) { int A [ ] = { 1 , 4 , 5 } ; int B [ ] = { 2 , 3 } ; int C [ ] = { 2 , 1 , 3 } ; int p = A . length ; int q = B . length ; int r = C . length ; System . out . print ( " Sum ▁ of ▁ values ▁ of ▁ all ▁ special ▁ triplets ▁ = ▁ " + findSplTripletsSum ( A , B , C , p , q , r ) + " \n " ) ; } }
import java . util . * ; class GFG { static int nthDigit ( int a , int n , int b ) { for ( int i = 1 ; i < n ; i ++ ) a = a / b ; return a % b ; } public static void main ( String [ ] args ) { int a = 100 ; int n = 3 ; int b = 4 ; System . out . print ( nthDigit ( a , n , b ) ) ; } }
class Solution { static int sum ( int n ) { if ( n == 1 ) { return 2 ; } else { return ( n * ( n + 1 ) + sum ( n - 1 ) ) ; } } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( sum ( n ) ) ; } }
class GFG { static int TEN = 10 ; static int minNum ( char [ ] str , int len ) { int res = Integer . MAX_VALUE ; for ( int i = 0 ; i < len ; i ++ ) { if ( str [ i ] == '4' || str [ i ] == '8' ) { res = Math . min ( res , str [ i ] - '0' ) ; } } for ( int i = 0 ; i < len - 1 ; i ++ ) { for ( int j = i + 1 ; j < len ; j ++ ) { int num = ( str [ i ] - '0' ) * TEN + ( str [ j ] - '0' ) ; if ( num % 4 == 0 ) { res = Math . min ( res , num ) ; } } } return ( ( res == Integer . MAX_VALUE ) ? - 1 : res ) ; } public static void main ( String [ ] args ) { String str = "17" ; int len = str . length ( ) ; System . out . print ( minNum ( str . toCharArray ( ) , len ) ) ; } }
public class GFG { static boolean isPower ( int a ) { if ( a == 1 ) return true ; for ( int i = 2 ; i * i <= a ; i ++ ) { double val = Math . log ( a ) / Math . log ( i ) ; if ( ( val - ( int ) val ) < 0.00000001 ) return true ; } return false ; } public static void main ( String [ ] args ) { int n = 16 ; System . out . println ( isPower ( n ) ? " Yes " : " No " ) ; } }
public class GFG { static long countNonDecreasing ( int n ) { int N = 10 ; long count = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { count *= ( N + i - 1 ) ; count /= i ; } return count ; } public static void main ( String args [ ] ) { int n = 3 ; System . out . print ( countNonDecreasing ( n ) ) ; } }
import java . util . * ; class GFG { static int height ; static int search ( int arr [ ] , int strt , int end , int value ) { for ( int i = strt ; i <= end ; i ++ ) if ( arr [ i ] == value ) return i ; return - 1 ; } static int getHeight ( int in [ ] , int level [ ] , int start , int end , int n ) { if ( start > end ) return 0 ; int getIndex = search ( in , start , end , level [ 0 ] ) ; if ( getIndex == - 1 ) return 0 ; int leftCount = getIndex - start ; int rightCount = end - getIndex ; int [ ] newLeftLevel = new int [ leftCount ] ; int [ ] newRightLevel = new int [ rightCount ] ; int lheight = 0 , rheight = 0 ; int k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = start ; j < getIndex ; j ++ ) { if ( level [ i ] == in [ j ] ) { newLeftLevel [ k ] = level [ i ] ; k ++ ; break ; } } } k = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = getIndex + 1 ; j <= end ; j ++ ) { if ( level [ i ] == in [ j ] ) { newRightLevel [ k ] = level [ i ] ; k ++ ; break ; } } } if ( leftCount > 0 ) lheight = getHeight ( in , newLeftLevel , start , getIndex - 1 , leftCount ) ; if ( rightCount > 0 ) rheight = getHeight ( in , newRightLevel , getIndex + 1 , end , rightCount ) ; height = Math . max ( lheight + 1 , rheight + 1 ) ; newRightLevel = null ; newLeftLevel = null ; return height ; } public static void main ( String [ ] args ) { int in [ ] = { 4 , 8 , 10 , 12 , 14 , 20 , 22 } ; int level [ ] = { 20 , 8 , 22 , 4 , 12 , 10 , 14 } ; int n = in . length ; height = 0 ; System . out . println ( getHeight ( in , level , 0 , n - 1 , n ) ) ; } }
class GFG { static class Node { int data ; Node left , right ; } ; static String str ; static Node newNode ( int data ) { Node node = new Node ( ) ; node . data = data ; node . left = node . right = null ; return ( node ) ; } static void treeToString ( Node root ) { if ( root == null ) return ; str += ( Character . valueOf ( ( char ) ( root . data + '0' ) ) ) ; if ( root . left == null && root . right == null ) return ; str += ( ' ( ' ) ; treeToString ( root . left ) ; str += ( ' ) ' ) ; if ( root . right != null ) { str += ( ' ( ' ) ; treeToString ( root . right ) ; str += ( ' ) ' ) ; } } public static void main ( String [ ] args ) { Node root = newNode ( 1 ) ; root . left = newNode ( 2 ) ; root . right = newNode ( 3 ) ; root . left . left = newNode ( 4 ) ; root . left . right = newNode ( 5 ) ; root . right . right = newNode ( 6 ) ; str = " " ; treeToString ( root ) ; System . out . println ( str ) ; } }
import java . util . * ; class GFG { static void triangular_series ( int n ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . printf ( " % d ▁ " ; , i * ( i + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; triangular_series ( n ) ; } }
import java . io . * ; class GFG { static int lds ( int arr [ ] , int n ) { int lds [ ] = new int [ n ] ; int i , j , max = 0 ; for ( i = 0 ; i < n ; i ++ ) lds [ i ] = 1 ; for ( i = 1 ; i < n ; i ++ ) for ( j = 0 ; j < i ; j ++ ) if ( arr [ i ] < arr [ j ] && lds [ i ] < lds [ j ] + 1 ) lds [ i ] = lds [ j ] + 1 ; for ( i = 0 ; i < n ; i ++ ) if ( max < lds [ i ] ) max = lds [ i ] ; return max ; } public static void main ( String [ ] args ) { int arr [ ] = { 15 , 27 , 14 , 38 , 63 , 55 , 46 , 65 , 85 } ; int n = arr . length ; System . out . print ( " Length ▁ of ▁ LDS ▁ is ▁ " + lds ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int n = 3 ; static int dotProduct ( int vect_A [ ] , int vect_B [ ] ) { int product = 0 ; for ( int i = 0 ; i < n ; i ++ ) product = product + vect_A [ i ] * vect_B [ i ] ; return product ; } static void crossProduct ( int vect_A [ ] , int vect_B [ ] , int cross_P [ ] ) { cross_P [ 0 ] = vect_A [ 1 ] * vect_B [ 2 ] - vect_A [ 2 ] * vect_B [ 1 ] ; cross_P [ 1 ] = vect_A [ 2 ] * vect_B [ 0 ] - vect_A [ 0 ] * vect_B [ 2 ] ; cross_P [ 2 ] = vect_A [ 0 ] * vect_B [ 1 ] - vect_A [ 1 ] * vect_B [ 0 ] ; } public static void main ( String [ ] args ) { int vect_A [ ] = { 3 , - 5 , 4 } ; int vect_B [ ] = { 2 , 6 , 5 } ; int cross_P [ ] = new int [ n ] ; System . out . print ( " Dot ▁ product : " ) ; System . out . println ( dotProduct ( vect_A , vect_B ) ) ; System . out . print ( " Cross ▁ product : " ) ; crossProduct ( vect_A , vect_B , cross_P ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( cross_P [ i ] + " ▁ " ) ; } }
class GFG { static long partitions ( int n ) { long p [ ] = new long [ n + 1 ] ; p [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; ++ i ) { int k = 1 ; while ( ( k * ( 3 * k - 1 ) ) / 2 <= i ) { p [ i ] += ( k % 2 != 0 ? 1 : - 1 ) * p [ i - ( k * ( 3 * k - 1 ) ) / 2 ] ; if ( k > 0 ) { k *= - 1 ; } else { k = 1 - k ; } } } return p [ n ] ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( partitions ( N ) ) ; } }
class GFG { static boolean isSquarePossible ( int arr [ ] , int n , int l ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] >= l ) cnt ++ ; if ( cnt >= l ) return true ; } return false ; } static int maxArea ( int arr [ ] , int n ) { int l = 0 , r = n ; int len = 0 ; while ( l <= r ) { int m = l + ( ( r - l ) / 2 ) ; if ( isSquarePossible ( arr , n , m ) ) { len = m ; l = m + 1 ; } else r = m - 1 ; } return ( len * len ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 4 , 5 , 5 } ; int n = arr . length ; System . out . println ( maxArea ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int findEvenPair ( int A [ ] , int N ) { int evenPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] | A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = A . length ; System . out . println ( findEvenPair ( A , N ) ) ; } }
import java . io . * ; class GFG { static int pairORSum ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) ans += arr [ i ] | arr [ j ] ; return ans ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( pairORSum ( arr , n ) ) ; } }
class GFG { static int MAX = 26 ; static boolean targetstring ( String str1 , String str2 ) { int l1 = str1 . length ( ) ; int l2 = str2 . length ( ) ; if ( l1 != l2 ) return false ; int [ ] map = new int [ MAX ] ; for ( int i = 0 ; i < l1 ; i ++ ) map [ str1 . charAt ( i ) - ' a ' ] ++ ; for ( int i = 0 ; i < l2 ; i ++ ) { map [ str2 . charAt ( i ) - ' a ' ] -- ; if ( map [ str2 . charAt ( i ) - ' a ' ] < 0 ) return false ; } return true ; } public static void main ( String args [ ] ) { String str1 = " geeksforgeeks " ; String str2 = " geegeeksksfor " ; if ( targetstring ( str1 , str2 ) ) System . out . print ( " YES " ) ; else System . out . print ( " NO " ) ; } }
import java . util . * ; class GFG { static int maxLength ( String s , int n ) { int ans = Integer . MIN_VALUE ; Vector < Integer > A = new Vector < Integer > ( ) ; Vector < Integer > L = new Vector < Integer > ( ) ; Vector < Integer > R = new Vector < Integer > ( ) ; int [ ] freq = new int [ n + 5 ] ; for ( int i = 0 ; i < 26 ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < n ; j ++ ) { if ( s . charAt ( j ) - ' a ' == i ) count ++ ; freq [ j ] = count ; } for ( int j = 1 ; j < n ; j ++ ) { L . add ( ( 2 * freq [ j - 1 ] ) - j ) ; R . add ( ( 2 * freq [ j ] ) - j ) ; } int max_len = Integer . MIN_VALUE ; int min_val = Integer . MAX_VALUE ; for ( int j = 0 ; j < L . size ( ) ; j ++ ) { min_val = Math . min ( min_val , L . get ( j ) ) ; A . add ( min_val ) ; int l = 0 , r = j ; while ( l <= r ) { int mid = ( l + r ) >> 1 ; if ( A . get ( mid ) <= R . get ( j ) ) { max_len = Math . max ( max_len , j - mid + 1 ) ; r = mid - 1 ; } else { l = mid + 1 ; } } } ans = Math . max ( ans , max_len ) ; A . clear ( ) ; R . clear ( ) ; L . clear ( ) ; } return ans ; } public static void main ( String [ ] args ) { String s = " ababbbacbcbcca " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
class GFG { static boolean isPrime ( int p ) { double checkNumber = Math . pow ( 2 , p ) - 1 ; double nextval = 4 % checkNumber ; for ( int i = 1 ; i < p - 1 ; i ++ ) nextval = ( nextval * nextval - 2 ) % checkNumber ; return ( nextval == 0 ) ; } public static void main ( String [ ] args ) { int p = 7 ; double checkNumber = Math . pow ( 2 , p ) - 1 ; if ( isPrime ( p ) ) System . out . println ( ( int ) checkNumber + " ▁ is ▁ Prime . " ) ; else System . out . println ( ( int ) checkNumber + " ▁ is ▁ not ▁ Prime . " ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int minOps ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int max = arr [ arr . length - 1 ] ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( max - arr [ i ] ) % k != 0 ) return - 1 ; else res += ( max - arr [ i ] ) / k ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 21 , 33 , 9 , 45 , 63 } ; int n = arr . length ; int k = 6 ; System . out . println ( minOps ( arr , n , k ) ) ; } }
class GFG { static int minChanges ( char [ ] str , int n ) { int count = 0 , zeros = 0 , ones = 0 ; if ( str [ 0 ] != '1' ) { count ++ ; ones ++ ; } for ( int i = 1 ; i < n ; i ++ ) { if ( str [ i ] == '0' ) zeros ++ ; else ones ++ ; if ( zeros > ones ) { zeros -- ; ones ++ ; count ++ ; } } return count ; } public static void main ( String [ ] args ) { char [ ] str = "0000" . toCharArray ( ) ; int n = str . length ; System . out . print ( minChanges ( str , n ) ) ; } }
public class GFG { static final int MAX = 1000001 ; static int primeUpto [ ] = new int [ MAX ] ; static void SieveOfEratosthenes ( ) { int isPrime [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) isPrime [ i ] = 1 ; isPrime [ 0 ] = isPrime [ 1 ] = 0 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { if ( isPrime [ i ] == 1 ) { for ( int j = i * 2 ; j < MAX ; j += i ) isPrime [ j ] = 0 ; } } for ( int i = 1 ; i < MAX ; i ++ ) { primeUpto [ i ] = primeUpto [ i - 1 ] ; if ( isPrime [ i ] == 1 ) primeUpto [ i ] ++ ; } } static int countOfNumbers ( int N , int K ) { SieveOfEratosthenes ( ) ; int low = 1 , high = N , ans = 0 ; while ( low <= high ) { int mid = ( low + high ) >> 1 ; if ( mid - primeUpto [ mid ] >= K ) { ans = mid ; high = mid - 1 ; } else low = mid + 1 ; } ans = ans != 0 ? N - ans + 1 : 0 ; return ans ; } public static void main ( String [ ] args ) { int N = 10 , K = 3 ; System . out . println ( countOfNumbers ( N , K ) ) ; } }
class GFG { static boolean isRectangle ( int a , int b , int c , int d ) { if ( a == b && a == c && a == d && c == d && b == c && b == d ) return true ; else if ( a == b && c == d ) return true ; else if ( a == d && c == b ) return true ; else if ( a == c && d == b ) return true ; else return false ; } public static void main ( String [ ] args ) { int a = 1 , b = 2 , c = 3 , d = 4 ; if ( isRectangle ( a , b , c , d ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public class GFG { public static int countSubArrays ( int arr [ ] , int x ) { int count = 0 ; int start = - 1 , end = - 1 ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( arr [ i ] < x ) { if ( start == - 1 ) { start = i ; end = i ; } else { end = i ; } } else { if ( start != - 1 && end != - 1 ) { int length = end - start + 1 ; count = count + ( ( length * ( length + 1 ) ) / 2 ) ; } start = - 1 ; end = - 1 ; } } if ( start != - 1 && end != - 1 ) { int length = end - start + 1 ; count = count + ( ( length * ( length + 1 ) ) / 2 ) ; } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 7 , 8 , 2 , 3 , 9 } ; int x = 6 ; System . out . println ( countSubArrays ( arr , x ) ) ; } }
import java . io . * ; class GFG { static float circumferenceparallelogram ( float a , float b ) { return ( ( 2 * a ) + ( 2 * b ) ) ; } public static void main ( String arg [ ] ) { float a = 10 , b = 8 ; System . out . print ( " Circumference ▁ of ▁ a ▁ given ▁ Parallelogram ▁ is ▁ : " ) ; System . out . println ( circumferenceparallelogram ( a , b ) ) ; } }
import java . util . * ; class GFG { static int singleNumber ( int a [ ] , int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i : a ) { s . add ( i ) ; } int arr_sum = 0 ; for ( int i : a ) { arr_sum += i ; } int set_sum = 0 ; for ( int i : s ) { set_sum += i ; } return ( 3 * set_sum - arr_sum ) / 2 ; } public static void main ( String [ ] args ) { int a [ ] = { 12 , 1 , 12 , 3 , 12 , 1 , 1 , 2 , 3 , 2 , 2 , 3 , 7 } ; int n = a . length ; System . out . println ( " The ▁ element ▁ with ▁ single ▁ " + " occurrence ▁ is ▁ " + singleNumber ( a , n ) ) ; } }
import java . io . * ; class Nth { public int nthTerm ( int N ) { return ( N * ( ( N / 2 ) + ( ( N % 2 ) * 2 ) + N ) ) ; } } class GFG { public static void main ( String [ ] args ) { int N = 5 ; Nth a = new Nth ( ) ; System . out . println ( " Nth ▁ term ▁ for ▁ N ▁ = ▁ " + N + " ▁ : ▁ " + a . nthTerm ( N ) ) ; } }
import java . io . * ; class Ratio { static boolean isRatioPossible ( int lowCost , int upCost , int lowQuant , int upQuant , int r ) { for ( int i = lowQuant ; i <= upQuant ; i ++ ) { int ans = i * r ; if ( lowCost <= ans && ans <= upCost ) return true ; } return false ; } public static void main ( String args [ ] ) { int lowCost = 14 , upCost = 30 , lowQuant = 5 , upQuant = 12 , r = 9 ; if ( isRatioPossible ( lowCost , upCost , lowQuant , upQuant , r ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class MatrixChainMultiplication { static int MatrixChainOrder ( int p [ ] , int i , int j ) { if ( i == j ) return 0 ; int min = Integer . MAX_VALUE ; for ( int k = i ; k < j ; k ++ ) { int count = MatrixChainOrder ( p , i , k ) + MatrixChainOrder ( p , k + 1 , j ) + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( count < min ) min = count ; } return min ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 , 3 } ; int n = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + MatrixChainOrder ( arr , 1 , n - 1 ) ) ; } }
import java . util . * ; class GFG { static int countDigit ( long n ) { if ( n == 0 ) return 0 ; return 1 + countDigit ( n / 10 ) ; } public static void main ( String [ ] args ) { long n = 345289467 ; System . out . print ( " Number ▁ of ▁ digits ▁ : ▁ " + countDigit ( n ) ) ; } }
import java . util . Stack ; class GFG { static void printPrevSmaller ( int arr [ ] , int n ) { Stack < Integer > S = new Stack < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { while ( ! S . empty ( ) && S . peek ( ) >= arr [ i ] ) { S . pop ( ) ; } if ( S . empty ( ) ) { System . out . print ( " _ , ▁ " ) ; } else { System . out . print ( S . peek ( ) + " , ▁ " ) ; } S . push ( arr [ i ] ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 0 , 2 , 5 } ; int n = arr . length ; printPrevSmaller ( arr , n ) ; } }
class GFG { static double wastedWater ( double V , double M , double N ) { double wasted_amt , amt_per_min , time_to_fill ; amt_per_min = M - N ; time_to_fill = V / amt_per_min ; wasted_amt = N * time_to_fill ; return wasted_amt ; } public static void main ( String [ ] args ) { double V , M , N ; V = 700 ; M = 10 ; N = 3 ; System . out . println ( wastedWater ( V , M , N ) ) ; V = 1000 ; M = 100 ; N = 50 ; System . out . println ( wastedWater ( V , M , N ) ) ; } }
public class GFG { static final int NO_OF_CHARS = 256 ; static char getSecondMostFreq ( String str ) { int [ ] count = new int [ NO_OF_CHARS ] ; int i ; for ( i = 0 ; i < str . length ( ) ; i ++ ) ( count [ str . charAt ( i ) ] ) ++ ; int first = 0 , second = 0 ; for ( i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( count [ i ] > count [ first ] ) { second = first ; first = i ; } else if ( count [ i ] > count [ second ] && count [ i ] != count [ first ] ) second = i ; } return ( char ) second ; } public static void main ( String args [ ] ) { String str = " geeksforgeeks " ; char res = getSecondMostFreq ( str ) ; if ( res != ' \0' ) System . out . println ( " Second ▁ most ▁ frequent ▁ char " + " ▁ is ▁ " + res ) ; else System . out . println ( " No ▁ second ▁ most ▁ frequent " + " character " ) ; } }
import java . io . * ; class GFG { static float exponential ( int n , float x ) { float sum = 1 ; for ( int i = n - 1 ; i > 0 ; -- i ) sum = 1 + x * sum / i ; return sum ; } public static void main ( String [ ] args ) { int n = 10 ; float x = 1 ; System . out . println ( " e ^ x ▁ = ▁ " + exponential ( n , x ) ) ; } }
import java . io . * ; import java . util . * ; public class GFG { static int solve ( int [ ] A , int n ) { int i , cnt = 0 , j ; int [ ] parent = new int [ n + 1 ] ; int [ ] vis = new int [ n + 1 ] ; for ( i = 0 ; i < n + 1 ; i ++ ) { parent [ i ] = - 1 ; vis [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { j = i ; if ( parent [ j ] == - 1 ) { while ( parent [ j ] == - 1 ) { parent [ j ] = i ; j = ( j + A [ j ] + 1 ) % n ; } if ( parent [ j ] == i ) { while ( vis [ j ] == 0 ) { vis [ j ] = 1 ; cnt ++ ; j = ( j + A [ j ] + 1 ) % n ; } } } } return cnt ; } public static void main ( String args [ ] ) { int [ ] A = { 0 , 0 , 0 , 2 } ; int n = A . length ; System . out . print ( solve ( A , n ) ) ; } }
import java . util . * ; class GFG { static int getCount ( int [ ] v , int n ) { Arrays . sort ( v ) ; int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int tmp = n - 1 - upperBound ( v , n , v [ i ] - 1 ) ; if ( tmp == v [ i ] ) cnt ++ ; } return cnt ; } static int upperBound ( int [ ] array , int length , int value ) { int low = 0 ; int high = length ; while ( low < high ) { final int mid = ( low + high ) / 2 ; if ( value >= array [ mid ] ) { low = mid + 1 ; } else { high = mid ; } } return low ; } public static void main ( String [ ] args ) { int n = 4 ; int [ ] v = { 1 , 2 , 3 , 4 } ; System . out . println ( getCount ( v , n ) ) ; } }
class GFG { static String lexNext ( String str , int n ) { char [ ] s = str . toCharArray ( ) ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( s [ i ] != ' z ' ) { s [ i ] ++ ; return String . valueOf ( s ) ; } s [ i ] = ' a ' ; } return null ; } static public void main ( String [ ] args ) { String S = " abcdeg " , T = " abcfgh " ; int n = S . length ( ) ; String res = lexNext ( S , n ) ; if ( res != T ) { System . out . println ( res ) ; } else { System . out . println ( " - 1" ) ; } } }
public class GFG { static int bridge_length ( int trainLength , int Speed , int Time ) { return ( ( Time * Speed ) - trainLength ) ; } public static void main ( String [ ] args ) { int trainLength = 120 ; int Speed = 30 ; int Time = 18 ; System . out . print ( " Length ▁ of ▁ bridge ▁ = ▁ " + bridge_length ( trainLength , Speed , Time ) + " ▁ meters " ) ; } }
class GFG { static final int MAX = 1000006 ; static void sieve ( int count [ ] ) { for ( int i = 2 ; i * i <= MAX ; i ++ ) { if ( count [ i ] == 0 ) { for ( int j = 2 * i ; j < MAX ; j += i ) count [ j ] ++ ; count [ i ] = 1 ; } } } static int query ( int count [ ] , int l , int r ) { int sum = 0 ; for ( int i = l ; i <= r ; i ++ ) sum += count [ i ] ; return sum ; } public static void main ( String [ ] args ) { int count [ ] = new int [ MAX ] ; sieve ( count ) ; System . out . println ( query ( count , 6 , 10 ) + " ▁ " + query ( count , 1 , 5 ) ) ; } }
class GFG { static boolean canBecomeEmpty ( String str , String sub_str ) { while ( str . length ( ) > 0 ) { int idx = str . indexOf ( sub_str ) ; if ( idx == - 1 ) { break ; } str = str . replaceFirst ( sub_str , " " ) ; } return ( str . length ( ) == 0 ) ; } public static void main ( String [ ] args ) { String str = " GEEGEEKSKS " , sub_str = " GEEKS " ; if ( canBecomeEmpty ( str , sub_str ) ) { System . out . print ( " \n Yes " ) ; } else { System . out . print ( " \n No " ) ; } } }
import java . util . * ; class GFG { static void printOrder ( int [ ] arr , int n ) { Arrays . sort ( arr ) ; for ( int i = 0 ; i < n / 2 ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; for ( int j = n - 1 ; j >= n / 2 ; j -- ) System . out . print ( arr [ j ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 4 , 6 , 2 , 1 , 3 , 8 , 9 , 7 } ; int n = arr . length ; printOrder ( arr , n ) ; } }
import java . util . * ; class GFG { static int countSwap ( String str ) { int n = str . length ( ) ; char s [ ] = str . toCharArray ( ) ; int count = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { int left = i ; int right = n - left - 1 ; while ( left < right ) { if ( s [ left ] == s [ right ] ) { break ; } else { right -- ; } } if ( left == right ) { return - 1 ; } else { for ( int j = right ; j < n - left - 1 ; j ++ ) { char t = s [ j ] ; s [ j ] = s [ j + 1 ] ; s [ j + 1 ] = t ; count ++ ; } } } return count ; } public static void main ( String [ ] args ) { String s = " geeksfgeeks " ; int count = countSwap ( s ) ; System . out . println ( count ) ; } }
import java . util . * ; class solution { static boolean divisible ( String N , int digit ) { int ans = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { ans = ( ans * 10 + ( N . charAt ( i ) - '0' ) ) ; ans %= digit ; } return ( ans == 0 ) ; } static int allDigits ( String N ) { Boolean [ ] divide = new Boolean [ 10 ] ; Arrays . fill ( divide , Boolean . FALSE ) ; divide [ 1 ] = true ; for ( int digit = 2 ; digit <= 9 ; digit ++ ) { if ( divisible ( N , digit ) ) divide [ digit ] = true ; } int result = 0 ; for ( int i = 0 ; i < N . length ( ) ; i ++ ) { if ( divide [ N . charAt ( i ) - '0' ] == true ) result ++ ; } return result ; } public static void main ( String args [ ] ) { String N = "122324" ; System . out . println ( allDigits ( N ) ) ; } }
import java . util . * ; class GFG { static long getPairs ( Vector < Integer > A , Vector < Integer > B , int n ) { int [ ] D = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { D [ i ] = A . get ( i ) - B . get ( i ) ; } Arrays . sort ( D ) ; long total = 0 ; for ( int i = n - 1 ; i >= 0 ; i -- ) { if ( D [ i ] > 0 ) { total += n - i - 1 ; } else { int k = upper_bound ( D , 0 , D . length , - D [ i ] ) ; total += n - k ; } } return total ; } static int upper_bound ( int [ ] a , int low , int high , int element ) { while ( low < high ) { int middle = low + ( high - low ) / 2 ; if ( a [ middle ] > element ) high = middle ; else low = middle + 1 ; } return low ; } public static void main ( String [ ] args ) { int n = 5 ; Vector < Integer > A = new Vector < Integer > ( ) ; Vector < Integer > B = new Vector < Integer > ( ) ; A . add ( 4 ) ; A . add ( 8 ) ; A . add ( 2 ) ; A . add ( 6 ) ; A . add ( 2 ) ; B . add ( 4 ) ; B . add ( 5 ) ; B . add ( 4 ) ; B . add ( 1 ) ; B . add ( 3 ) ; System . out . print ( getPairs ( A , B , n ) ) ; } }
import java . util . * ; class GFG { static int MAX = 100002 ; static int f ( int i , int m , char s [ ] , int memoize [ ] [ ] ) { if ( i == s . length ) { return 0 ; } if ( memoize [ i ] [ m ] != - 1 ) { return memoize [ i ] [ m ] ; } int x = s [ i ] - '0' ; int ans = ( ( x + m ) % 3 == 0 && x % 2 == 0 ) ? 1 + f ( i + 1 , ( m + x ) % 3 , s , memoize ) : f ( i + 1 , ( m + x ) % 3 , s , memoize ) ; memoize [ i ] [ m ] = ans ; return memoize [ i ] [ m ] ; } static int countDivBy6 ( char s [ ] ) { int n = s . length ; int [ ] [ ] memoize = new int [ n + 1 ] [ 3 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { for ( int j = 0 ; j < 3 ; j ++ ) { memoize [ i ] [ j ] = - 1 ; } } int ans = 0 ; for ( int i = 0 ; i < s . length ; i ++ ) { if ( s [ i ] == '0' ) { ans ++ ; } else { ans += f ( i , 0 , s , memoize ) ; } } return ans ; } public static void main ( String [ ] args ) { char s [ ] = "4806" . toCharArray ( ) ; System . out . println ( countDivBy6 ( s ) ) ; } }
class Main { static int getMedian ( int ar1 [ ] , int ar2 [ ] , int n ) { int i = 0 ; int j = 0 ; int count ; int m1 = - 1 , m2 = - 1 ; for ( count = 0 ; count <= n ; count ++ ) { if ( i == n ) { m1 = m2 ; m2 = ar2 [ 0 ] ; break ; } else if ( j == n ) { m1 = m2 ; m2 = ar1 [ 0 ] ; break ; } if ( ar1 [ i ] < ar2 [ j ] ) { m1 = m2 ; m2 = ar1 [ i ] ; i ++ ; } else { m1 = m2 ; m2 = ar2 [ j ] ; j ++ ; } } return ( m1 + m2 ) / 2 ; } public static void main ( String [ ] args ) { int ar1 [ ] = { 1 , 12 , 15 , 26 , 38 } ; int ar2 [ ] = { 2 , 13 , 17 , 30 , 45 } ; int n1 = ar1 . length ; int n2 = ar2 . length ; if ( n1 == n2 ) System . out . println ( " Median ▁ is ▁ " + getMedian ( ar1 , ar2 , n1 ) ) ; else System . out . println ( " arrays ▁ are ▁ of ▁ unequal ▁ size " ) ; } }
class GFG { static final int INT_SIZE = 32 ; static class TrieNode { int value ; TrieNode [ ] arr = new TrieNode [ 2 ] ; public TrieNode ( ) { value = 0 ; arr [ 0 ] = null ; arr [ 1 ] = null ; } } static TrieNode root ; static void insert ( int pre_xor ) { TrieNode temp = root ; for ( int i = INT_SIZE - 1 ; i >= 0 ; i -- ) { int val = ( pre_xor & ( 1 << i ) ) >= 1 ? 1 : 0 ; if ( temp . arr [ val ] == null ) temp . arr [ val ] = new TrieNode ( ) ; temp = temp . arr [ val ] ; } temp . value = pre_xor ; } static int query ( int pre_xor ) { TrieNode temp = root ; for ( int i = INT_SIZE - 1 ; i >= 0 ; i -- ) { int val = ( pre_xor & ( 1 << i ) ) >= 1 ? 1 : 0 ; if ( temp . arr [ 1 - val ] != null ) temp = temp . arr [ 1 - val ] ; else if ( temp . arr [ val ] != null ) temp = temp . arr [ val ] ; } return pre_xor ^ ( temp . value ) ; } static int maxSubarrayXOR ( int arr [ ] , int n ) { root = new TrieNode ( ) ; insert ( 0 ) ; int result = Integer . MIN_VALUE ; int pre_xor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { pre_xor = pre_xor ^ arr [ i ] ; insert ( pre_xor ) ; result = Math . max ( result , query ( pre_xor ) ) ; } return result ; } public static void main ( String args [ ] ) { int arr [ ] = { 8 , 1 , 2 , 12 } ; int n = arr . length ; System . out . println ( " Max ▁ subarray ▁ XOR ▁ is ▁ " + maxSubarrayXOR ( arr , n ) ) ; } }
public class GfG { static int minCost ( int n , int arr [ ] , int cost ) { int sum = 0 , totalCost = 0 ; for ( int i = 0 ; i < n - 1 ; i ++ ) sum += arr [ i ] ; totalCost += cost * sum ; arr [ n - 1 ] += sum ; totalCost += ( 2 * cost * arr [ n - 1 ] ) ; return totalCost ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 4 , 5 } ; int n = arr . length ; int cost = 1 ; System . out . println ( minCost ( n , arr , cost ) ) ; } }
class GFG { static class Node { int data ; Node next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; ( head_ref ) = new_node ; return head_ref ; } static int productOfNodes ( Node head ) { Node ptr = head ; int product = 1 ; while ( ptr != null ) { product *= ptr . data ; ptr = ptr . next ; } return product ; } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 7 ) ; head = push ( head , 6 ) ; head = push ( head , 8 ) ; head = push ( head , 4 ) ; head = push ( head , 1 ) ; System . out . println ( " Product ▁ = ▁ " + productOfNodes ( head ) ) ; } }
import java . io . * ; class GFG { static int maxLength ( String s , int n ) { int dp [ ] [ ] = new int [ n ] [ n ] ; for ( int i = 0 ; i < n - 1 ; i ++ ) if ( s . charAt ( i ) == ' ( ' && s . charAt ( i + 1 ) == ' ) ' ) dp [ i ] [ i + 1 ] = 2 ; for ( int l = 2 ; l < n ; l ++ ) { for ( int i = 0 , j = l ; j < n ; i ++ , j ++ ) { if ( s . charAt ( i ) == ' ( ' && s . charAt ( j ) == ' ) ' ) dp [ i ] [ j ] = 2 + dp [ i + 1 ] [ j - 1 ] ; for ( int k = i ; k < j ; k ++ ) dp [ i ] [ j ] = Math . max ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k + 1 ] [ j ] ) ; } } return dp [ 0 ] [ n - 1 ] ; } public static void main ( String [ ] args ) { String s = " ( ) ( ( ( ( ( ( ) " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
import java . util . * ; class GFG { static Vector < Integer > processQueries ( int Q [ ] , int m , int n ) { int [ ] a = new int [ m + 1 ] ; int [ ] pos = new int [ m + 1 ] ; for ( int i = 1 ; i <= m ; i ++ ) { a [ i - 1 ] = i ; pos [ i ] = i - 1 ; } Vector < Integer > ans = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { int q = Q [ i ] ; int p = pos [ q ] ; ans . add ( p ) ; for ( int j = p ; j > 0 ; j -- ) { a [ j ] = a [ j ] + a [ j - 1 ] ; a [ j - 1 ] = a [ j ] - a [ j - 1 ] ; a [ j ] = a [ j ] - a [ j - 1 ] ; pos [ a [ j ] ] = j ; } pos [ a [ 0 ] ] = 0 ; } return ans ; } public static void main ( String [ ] args ) { int Q [ ] = { 3 , 1 , 2 , 1 } ; int n = Q . length ; int m = 5 ; Vector < Integer > ans = new Vector < Integer > ( ) ; ans = processQueries ( Q , m , n ) ; for ( int i = 0 ; i < ans . size ( ) ; i ++ ) System . out . print ( ans . get ( i ) + " ▁ " ) ; } }
import java . io . * ; class GFG { static int countSubarrays ( int a [ ] , int n , int x ) { int count = 0 ; int number = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { count += 1 ; } else { number += ( count ) * ( count + 1 ) / 2 ; count = 0 ; } } if ( count != 0 ) number += ( count ) * ( count + 1 ) / 2 ; return number ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 4 , 5 , 6 , 7 , 2 , 10 , 11 } ; int n = a . length ; int k = 5 ; System . out . println ( countSubarrays ( a , n , k ) ) ; } }
import java . util . * ; class GFG { static int findNthOccur ( String str , char ch , int N ) { int occur = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { if ( str . charAt ( i ) == ch ) { occur += 1 ; } if ( occur == N ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { String str = " geeks " ; char ch = ' e ' ; int N = 2 ; System . out . print ( findNthOccur ( str , ch , N ) ) ; } }
class GFG { static boolean isCommonBase ( String base , String s1 , String s2 ) { for ( int j = 0 ; j < s1 . length ( ) ; ++ j ) { if ( base . charAt ( j % base . length ( ) ) != s1 . charAt ( j ) ) { return false ; } } for ( int j = 0 ; j < s2 . length ( ) ; ++ j ) { if ( base . charAt ( j % base . length ( ) ) != s2 . charAt ( j ) ) { return false ; } } return true ; } static int countCommonBases ( String s1 , String s2 ) { int n1 = s1 . length ( ) , n2 = s2 . length ( ) ; int count = 0 ; for ( int i = 1 ; i <= Math . min ( n1 , n2 ) ; i ++ ) { String base = s1 . substring ( 0 , i ) ; if ( isCommonBase ( base , s1 , s2 ) ) { count ++ ; } } return count ; } public static void main ( String [ ] args ) { String s1 = " pqrspqrs " ; String s2 = " pqrspqrspqrspqrs " ; System . out . println ( countCommonBases ( s1 , s2 ) ) ; } }
import java . util . * ; class GFG { static int pow ( int x , int y ) { if ( y == 1 ) return x ; if ( y == 0 ) return 1 ; int temp = pow ( x , y / 2 ) ; temp *= temp ; if ( y % 2 == 1 ) temp *= x ; return temp ; } static int noOfPermutations ( int [ ] a , int n ) { if ( n == 1 ) { return 1 ; } Arrays . sort ( a ) ; if ( a [ n - 1 ] == a [ n - 2 ] ) { return 0 ; } int x = 0 ; for ( int i = 0 ; i < n - 2 ; ++ i ) { if ( a [ i ] == a [ i + 1 ] ) { if ( a [ i ] == a [ i + 2 ] ) { return 0 ; } x ++ ; i ++ ; } } return pow ( 2 , n - 2 * x - 1 ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 2 , 3 , 4 } ; int n = a . length ; int num = noOfPermutations ( a , n ) ; System . out . print ( num ) ; } }
class GFG { static int toggleBitsFromLToR ( int n , int l , int r ) { if ( r < l ) return n ; int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; return ( n ^ num ) ; } static int smallNumWithNSetAndMUnsetBits ( int n , int m ) { int num = ( 1 << ( n + m ) ) - 1 ; return toggleBitsFromLToR ( num , n , n + m - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 , m = 2 ; System . out . println ( smallNumWithNSetAndMUnsetBits ( n , m ) ) ; } }
import java . util . * ; import java . io . * ; class GFG { static void generateNumbers ( int m ) { ArrayList < Integer > numbers = new ArrayList < > ( ) ; int k_max , x ; for ( int y = 0 ; y < 10 ; y ++ ) { k_max = ( int ) ( Math . pow ( 10 , m - 2 ) * ( 10 * y + 1 ) ) / ( int ) ( Math . pow ( 10 , m - 1 ) + y ) ; for ( int k = 1 ; k <= k_max ; k ++ ) { x = ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) / ( 10 * k - 1 ) ; if ( ( int ) ( y * ( Math . pow ( 10 , m - 1 ) - k ) ) % ( 10 * k - 1 ) == 0 ) numbers . add ( 10 * x + y ) ; } } Collections . sort ( numbers ) ; for ( int i = 0 ; i < numbers . size ( ) ; i ++ ) System . out . println ( numbers . get ( i ) ) ; } public static void main ( String args [ ] ) { int m = 3 ; generateNumbers ( m ) ; } }
class GFG { static void arrange ( int arr [ ] , int n , int x ) { for ( int i = 1 ; i < n ; i ++ ) { int diff = Math . abs ( arr [ i ] - x ) ; int j = i - 1 ; if ( Math . abs ( arr [ j ] - x ) > diff ) { int temp = arr [ i ] ; while ( j >= 0 && Math . abs ( arr [ j ] - x ) > diff ) { arr [ j + 1 ] = arr [ j ] ; j -- ; } arr [ j + 1 ] = temp ; } } } static void print ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 5 , 3 , 9 , 2 } ; int n = arr . length ; int x = 7 ; arrange ( arr , n , x ) ; print ( arr , n ) ; } }
import java . io . * ; class GFG { static boolean check ( String s , int m ) { int l = s . length ( ) ; int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < l ; i ++ ) { if ( s . charAt ( i ) == '0' ) { c2 = 0 ; c1 ++ ; } else { c1 = 0 ; c2 ++ ; } if ( c1 == m || c2 == m ) return true ; } return false ; } public static void main ( String [ ] args ) { String s = "001001" ; int m = 2 ; if ( check ( s , m ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static int maxOperations ( int X , int Y ) { if ( X > Y ) return - 1 ; int diff = Y - X ; if ( diff == 1 ) return - 1 ; if ( diff % 2 == 0 ) return ( diff / 2 ) ; return ( 1 + ( ( diff - 3 ) / 2 ) ) ; } public static void main ( String [ ] args ) { int X = 5 , Y = 16 ; System . out . println ( maxOperations ( X , Y ) ) ; } }
public class LargestNumber { static String swap ( String str , int i , int j ) { char ch [ ] = str . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; String c = String . valueOf ( ch ) ; return c ; } static int largestNum ( int num ) { String num_in_str = " " + num ; String temp = num_in_str ; for ( int i = 0 ; i < num_in_str . length ( ) ; i ++ ) { for ( int j = i + 1 ; j < num_in_str . length ( ) ; j ++ ) { num_in_str = swap ( num_in_str , i , j ) ; if ( temp . compareTo ( num_in_str ) < 0 ) temp = num_in_str ; num_in_str = swap ( num_in_str , i , j ) ; } } return Integer . parseInt ( temp ) ; } public static void main ( String [ ] s ) { int num = 423 ; System . out . println ( largestNum ( num ) ) ; num = 2736 ; System . out . println ( largestNum ( num ) ) ; num = 4596 ; System . out . println ( largestNum ( num ) ) ; } }
import java . util . * ; class GFG { static boolean checkPandigital ( int b , String n ) { if ( n . length ( ) < b ) return false ; boolean hash [ ] = new boolean [ b ] ; Arrays . fill ( hash , false ) ; for ( int i = 0 ; i < n . length ( ) ; i ++ ) { if ( n . charAt ( i ) >= '0' && n . charAt ( i ) <= '9' ) hash [ n . charAt ( i ) - '0' ] = true ; else if ( n . charAt ( i ) - ' A ' <= b - 11 ) hash [ n . charAt ( i ) - ' A ' + 10 ] = true ; } for ( int i = 0 ; i < b ; i ++ ) if ( hash [ i ] == false ) return false ; return true ; } public static void main ( String [ ] args ) { int b = 13 ; String n = "1298450376ABC " ; if ( checkPandigital ( b , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class Solution { static int __builtin_popcount ( int n ) { int count = 0 ; while ( n > 0 ) { if ( n % 2 == 1 ) count ++ ; n = n / 2 ; } return count ; } static void count_values ( int n ) { int set_bits = __builtin_popcount ( n ) ; System . out . println ( ( int ) Math . pow ( 2 , set_bits ) ) ; } public static void main ( String args [ ] ) { int n = 27 ; count_values ( n ) ; } }
import java . util . * ; class GFG { static boolean oneDigit ( int num ) { return ( num >= 0 && num < 10 ) ; } static boolean isPalUtil ( int num , int dupNum ) { if ( oneDigit ( num ) ) return ( num == ( dupNum ) % 10 ) ; if ( ! isPalUtil ( num / 10 , dupNum ) ) return false ; dupNum /= 10 ; return ( num % 10 == ( dupNum ) % 10 ) ; } static boolean isPal ( int num ) { if ( num < 0 ) num = - num ; int dupNum = num ; return isPalUtil ( num , dupNum ) ; } static void printPalPrimesLessThanN ( int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; for ( int p = 2 ; p * p <= n ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= n ; i += p ) { prime [ i ] = false ; } } } for ( int p = 2 ; p <= n ; p ++ ) { if ( prime [ p ] && isPal ( p ) ) { System . out . print ( p + " ▁ " ) ; } } } public static void main ( String [ ] args ) { int n = 100 ; System . out . printf ( " Palindromic ▁ primes ▁ smaller ▁ than ▁ or ▁ " + " equal ▁ to ▁ % d ▁ are ▁ : \n " , n ) ; printPalPrimesLessThanN ( n ) ; } }
class GFG { static int n = 6 , m = 6 ; static void maxSum ( long arr [ ] [ ] ) { long [ ] [ ] dp = new long [ n + 1 ] [ 3 ] ; for ( int i = 0 ; i < n ; i ++ ) { long m1 = 0 , m2 = 0 , m3 = 0 ; for ( int j = 0 ; j < m ; j ++ ) { if ( ( j / ( m / 3 ) ) == 0 ) { m1 = Math . max ( m1 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 1 ) { m2 = Math . max ( m2 , arr [ i ] [ j ] ) ; } else if ( ( j / ( m / 3 ) ) == 2 ) { m3 = Math . max ( m3 , arr [ i ] [ j ] ) ; } } dp [ i + 1 ] [ 0 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 2 ] ) + m1 ; dp [ i + 1 ] [ 1 ] = Math . max ( dp [ i ] [ 0 ] , dp [ i ] [ 2 ] ) + m2 ; dp [ i + 1 ] [ 2 ] = Math . max ( dp [ i ] [ 1 ] , dp [ i ] [ 0 ] ) + m3 ; } System . out . print ( Math . max ( Math . max ( dp [ n ] [ 0 ] , dp [ n ] [ 1 ] ) , dp [ n ] [ 2 ] ) + " \n " ) ; } public static void main ( String [ ] args ) { long arr [ ] [ ] = { { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 6 , 4 , 5 , 1 , 3 , 2 } , { 1 , 3 , 5 , 2 , 4 , 6 } } ; maxSum ( arr ) ; } }
import java . util . * ; class GFG { public static int smallestKFreq ( int a [ ] , int n , int k ) { HashMap < Integer , Integer > m = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) if ( m . containsKey ( a [ i ] ) ) m . put ( a [ i ] , m . get ( a [ i ] ) + 1 ) ; else m . put ( a [ i ] , 1 ) ; int res = Integer . MAX_VALUE ; Set < Integer > s = m . keySet ( ) ; for ( int temp : s ) if ( m . get ( temp ) == k ) res = Math . min ( res , temp ) ; return ( res != Integer . MAX_VALUE ) ? res : - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 3 , 1 } ; int k = 2 ; System . out . println ( smallestKFreq ( arr , arr . length , k ) ) ; } }
import java . io . * ; class GFG { static int divSum ( int n ) { int result = 0 ; for ( int i = 2 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( i == ( n / i ) ) result += i ; else result += ( i + n / i ) ; } } return ( result + n + 1 ) ; } public static void main ( String [ ] args ) { int n = 30 ; System . out . println ( divSum ( n ) ) ; } }
class GFG { static char NthCharacter ( int n ) { String s = " " ; int c = 1 ; for ( int i = 1 ; ; i ++ ) { if ( c < 10 ) s += Integer . toString ( c ) ; else { String s1 = " " ; int dup = c ; while ( dup > 0 ) { s1 += Integer . toString ( dup % 10 ) ; dup /= 10 ; } StringBuilder temp = new StringBuilder ( ) ; temp . append ( s1 ) ; temp = temp . reverse ( ) ; s += temp ; } c ++ ; if ( s . length ( ) >= n ) { return s . charAt ( n - 1 ) ; } } } public static void main ( String [ ] args ) { int n = 11 ; System . out . println ( NthCharacter ( n ) ) ; } }
import java . io . * ; import java . util . Arrays ; class GFG { static int MaxTotalRectangleArea ( int [ ] a , int n ) { Arrays . sort ( a ) ; int sum = 0 ; boolean flag = false ; int len = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ! flag ) { flag = true ; len = a [ i + 1 ] ; i ++ ; } else if ( ( a [ i ] == a [ i + 1 ] || a [ i ] - a [ i + 1 ] == 1 ) && ( flag ) ) { sum = sum + a [ i + 1 ] * len ; flag = false ; i ++ ; } } return sum ; } public static void main ( String args [ ] ) { int [ ] a = { 10 , 10 , 10 , 10 , 11 , 10 , 11 , 10 , 9 , 9 , 8 , 8 } ; int n = a . length ; System . out . print ( MaxTotalRectangleArea ( a , n ) ) ; } }
class GFG { static int smallestIndexsum ( int arr [ ] , int n ) { int i = n - 1 ; while ( i >= 0 && arr [ i ] % 2 == 1 ) i -- ; int sum = 0 ; for ( int j = 0 ; j <= i ; j ++ ) sum += arr [ j ] ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 5 , 6 , 3 , 3 } ; int n = arr . length ; System . out . println ( smallestIndexsum ( arr , n ) ) ; } }
class GFG { static int bitwiseAndOdd ( int n ) { int result = 1 ; for ( int i = 3 ; i <= n ; i = i + 2 ) { result = ( result & i ) ; } return result ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( bitwiseAndOdd ( n ) ) ; } }
import java . io . * ; public class GFG { static int sn ( int n , int an ) { return ( n * ( 1 + an ) ) / 2 ; } static int trace ( int n , int m ) { int an = 1 + ( n - 1 ) * ( m + 1 ) ; int rowmajorSum = sn ( n , an ) ; an = 1 + ( n - 1 ) * ( n + 1 ) ; int colmajorSum = sn ( n , an ) ; return rowmajorSum + colmajorSum ; } static public void main ( String [ ] args ) { int N = 3 , M = 3 ; System . out . println ( trace ( N , M ) ) ; } }
import java . io . * ; class GFG { static String allBitsSetInTheGivenRange ( int n , int l , int r ) { int num = ( ( 1 << r ) - 1 ) ^ ( ( 1 << ( l - 1 ) ) - 1 ) ; int new_num = n & num ; if ( new_num == 0 ) return " Yes " ; return " No " ; } public static void main ( String [ ] args ) { int n = 17 ; int l = 2 ; int r = 4 ; System . out . println ( allBitsSetInTheGivenRange ( n , l , r ) ) ; } }
class Test { static int findEqualPoint ( int arr [ ] , int n ) { int distArr [ ] = new int [ n ] ; int i = 0 , di = 0 ; while ( i < n ) { distArr [ di ++ ] = i ++ ; while ( i < n && arr [ i ] == arr [ i - 1 ] ) i ++ ; } return ( di & 1 ) != 0 ? distArr [ di >> 1 ] : - 1 ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 3 , 4 , 4 , 5 , 6 , 6 , 6 , 7 } ; int index = findEqualPoint ( arr , arr . length ) ; System . out . println ( index != - 1 ? " Equal ▁ Point ▁ = ▁ " + arr [ index ] : " Equal ▁ Point ▁ does ▁ not ▁ exists " ) ; } }
class GFG { static int M = 3 ; static int N = 3 ; static void reverseArray ( int arr [ ] [ ] ) { for ( int i = 0 ; i < M ; i ++ ) { int start = 0 ; int end = N - 1 ; while ( start < end ) { int temp = arr [ i ] [ start ] ; arr [ i ] [ start ] = arr [ i ] [ end ] ; arr [ i ] [ end ] = temp ; start ++ ; end -- ; } } for ( int i = 0 ; i < M ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { System . out . print ( arr [ i ] [ j ] + " ▁ " ) ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int arr [ ] [ ] = { { 1 , 2 , 3 } , { 4 , 5 , 6 } , { 7 , 8 , 9 } } ; reverseArray ( arr ) ; } }
import java . util . * ; class Solution { static void printAllSubsetsRec ( int arr [ ] , int n , Vector < Integer > v , int sum ) { if ( sum == 0 ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + " ▁ " ) ; System . out . println ( ) ; return ; } if ( n == 0 ) return ; printAllSubsetsRec ( arr , n - 1 , v , sum ) ; Vector < Integer > v1 = new Vector < Integer > ( v ) ; v1 . add ( arr [ n - 1 ] ) ; printAllSubsetsRec ( arr , n - 1 , v1 , sum - arr [ n - 1 ] ) ; } static void printAllSubsets ( int arr [ ] , int n , int sum ) { Vector < Integer > v = new Vector < Integer > ( ) ; printAllSubsetsRec ( arr , n , v , sum ) ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 5 , 8 , 4 , 6 , 11 } ; int sum = 13 ; int n = arr . length ; printAllSubsets ( arr , n , sum ) ; } }
class GFG { static String bin [ ] = { "000" , "001" , "010" , "011" , "100" , "101" , "110" , "111" } ; static int maxFreq ( String s ) { String binary = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { binary += bin [ s . charAt ( i ) - '0' ] ; } binary = binary . substring ( 0 , binary . length ( ) - 1 ) ; int count = 1 , prev = - 1 , i , j = 0 ; for ( i = binary . length ( ) - 1 ; i >= 0 ; i -- , j ++ ) if ( binary . charAt ( i ) == '1' ) { count = Math . max ( count , j - prev ) ; prev = j ; } return count ; } public static void main ( String [ ] args ) { String octal = "13" ; System . out . println ( maxFreq ( octal ) ) ; } }
import java . util . Comparator ; import java . util . PriorityQueue ; public class GFG { static final int MAX_CHAR = 26 ; static class IntCompare implements Comparator < Integer > { @ Override public int compare ( Integer arg0 , Integer arg1 ) { if ( arg0 > arg1 ) return - 1 ; else if ( arg0 < arg1 ) return 1 ; else return 0 ; } } static int minStringValue ( String str , int k ) { int l = str . length ( ) ; if ( k >= l ) return 0 ; int [ ] frequency = new int [ MAX_CHAR ] ; for ( int i = 0 ; i < l ; i ++ ) frequency [ str . charAt ( i ) - ' a ' ] ++ ; Comparator < Integer > c = new IntCompare ( ) ; PriorityQueue < Integer > q = new PriorityQueue < > ( c ) ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( frequency [ i ] != 0 ) q . add ( frequency [ i ] ) ; } while ( k != 0 ) { int temp = q . peek ( ) ; q . poll ( ) ; temp = temp - 1 ; q . add ( temp ) ; k -- ; } int result = 0 ; while ( ! q . isEmpty ( ) ) { int temp = q . peek ( ) ; result += temp * temp ; q . poll ( ) ; } return result ; } public static void main ( String args [ ] ) { String str = " abbccc " ; int k = 2 ; System . out . println ( minStringValue ( str , k ) ) ; str = " aaab " ; k = 2 ; System . out . println ( minStringValue ( str , k ) ) ; } }
class GFG { static boolean isHeap ( int arr [ ] , int i , int n ) { if ( i > ( n - 2 ) / 2 ) { return true ; } if ( arr [ i ] >= arr [ 2 * i + 1 ] && arr [ i ] >= arr [ 2 * i + 2 ] && isHeap ( arr , 2 * i + 1 , n ) && isHeap ( arr , 2 * i + 2 , n ) ) { return true ; } return false ; } public static void main ( String [ ] args ) { int arr [ ] = { 90 , 15 , 10 , 7 , 12 , 2 , 7 , 3 } ; int n = arr . length - 1 ; if ( isHeap ( arr , 0 , n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
class Fibonacci { static int fibonacci ( int n ) { int a = 0 ; int b = 1 ; int c = 0 ; if ( n <= 1 ) return n ; for ( int i = 2 ; i <= n ; i ++ ) { c = a + b ; a = b ; b = c ; } return c ; } static boolean isMultipleOf10 ( int n ) { int f = fibonacci ( 30 ) ; return ( f % 10 == 0 ) ; } public static void main ( String [ ] args ) { int n = 30 ; if ( isMultipleOf10 ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static void printPascal ( int n ) { for ( int line = 0 ; line < n ; line ++ ) { for ( int i = 0 ; i <= line ; i ++ ) System . out . print ( binomialCoeff ( line , i ) + " ▁ " ) ; System . out . println ( ) ; } } static int binomialCoeff ( int n , int k ) { int res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } public static void main ( String args [ ] ) { int n = 7 ; printPascal ( n ) ; } }
import java . io . * ; public class GFG { static int findSum ( int n ) { n -- ; int sum = 0 ; sum += ( n * ( n + 1 ) ) / 2 ; sum += ( n * ( n + 1 ) * ( 2 * n + 1 ) ) / 6 ; return sum ; } static public void main ( String [ ] args ) { int n = 3 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; import java . util . * ; import java . math . * ; class GFG { static int NO_OF_CHARS = 256 ; static boolean canFormPalindrome ( String str ) { int count [ ] = new int [ NO_OF_CHARS ] ; Arrays . fill ( count , 0 ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) count [ ( int ) ( str . charAt ( i ) ) ] ++ ; int odd = 0 ; for ( int i = 0 ; i < NO_OF_CHARS ; i ++ ) { if ( ( count [ i ] & 1 ) == 1 ) odd ++ ; if ( odd > 1 ) return false ; } return true ; } public static void main ( String args [ ] ) { if ( canFormPalindrome ( " geeksforgeeks " ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; if ( canFormPalindrome ( " geeksogeeks " ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int nthTerm ( int N ) { int nth = 0 , first_term = 12 ; nth = ( int ) ( ( first_term * ( Math . pow ( 2 , N - 1 ) ) ) + 11 * ( ( Math . pow ( 2 , N - 1 ) ) - 1 ) ) ; return nth ; } public static void main ( String [ ] args ) { int N = 5 ; System . out . print ( nthTerm ( N ) + " \n " ) ; } }
import java . io . * ; public class GFG { static boolean Arrive ( int a , int b , int n ) { if ( n >= Math . abs ( a ) + Math . abs ( b ) && ( n - ( Math . abs ( a ) + Math . abs ( b ) ) ) % 2 == 0 ) return true ; return false ; } int main ( ) { return 0 ; } public static void main ( String [ ] args ) { int a = 5 , b = 5 , n = 11 ; if ( Arrive ( a , b , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int ack ( int m , int n ) { if ( m == 0 ) { return n + 1 ; } else if ( ( m > 0 ) && ( n == 0 ) ) { return ack ( m - 1 , 1 ) ; } else if ( ( m > 0 ) && ( n > 0 ) ) { return ack ( m - 1 , ack ( m , n - 1 ) ) ; } else return n + 1 ; } public static void main ( String args [ ] ) { System . out . println ( ack ( 1 , 2 ) ) ; } }
class GFG { static int findCost ( String str , int arr [ ] , int n ) { long costofC = 0 , costofO = 0 , costofD = 0 , costofE = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' c ' ) costofC += arr [ i ] ; else if ( str . charAt ( i ) == ' o ' ) costofO = Math . min ( costofC , costofO + arr [ i ] ) ; else if ( str . charAt ( i ) == ' d ' ) costofD = Math . min ( costofO , costofD + arr [ i ] ) ; else if ( str . charAt ( i ) == ' e ' ) costofE = Math . min ( costofD , costofE + arr [ i ] ) ; } return ( int ) costofE ; } public static void main ( String [ ] args ) { String str = " geekcodergeeks " ; int arr [ ] = { 1 , 2 , 1 , 3 , 4 , 2 , 6 , 4 , 6 , 2 , 3 , 3 , 3 , 2 } ; int n = arr . length ; System . out . print ( findCost ( str , arr , n ) ) ; } }
import java . io . * ; import java . util . * ; class Kadane { public static void main ( String [ ] args ) { int [ ] a = { - 2 , - 3 , 4 , - 1 , - 2 , 1 , 5 , - 3 } ; System . out . println ( " Maximum ▁ contiguous ▁ sum ▁ is ▁ " + maxSubArraySum ( a ) ) ; } static int maxSubArraySum ( int a [ ] ) { int size = a . length ; int max_so_far = Integer . MIN_VALUE , max_ending_here = 0 ; for ( int i = 0 ; i < size ; i ++ ) { max_ending_here = max_ending_here + a [ i ] ; if ( max_so_far < max_ending_here ) max_so_far = max_ending_here ; if ( max_ending_here < 0 ) max_ending_here = 0 ; } return max_so_far ; } }
import java . io . * ; class GFG { static int factorial ( int a , int b ) { int res = 1 ; for ( int i = 1 ; i <= ( a + b ) ; i ++ ) res = res * i ; for ( int i = 1 ; i <= a ; i ++ ) res = res / i ; for ( int i = 1 ; i <= b ; i ++ ) res = res / i ; return res ; } static void Ksmallest ( int x , int y , int k ) { if ( x == 0 && y == 0 ) return ; else if ( x == 0 ) { y -- ; System . out . print ( " V " ) ; Ksmallest ( x , y , k ) ; } else if ( y == 0 ) { x -- ; System . out . print ( " H " ) ; Ksmallest ( x , y , k ) ; } else { if ( factorial ( x - 1 , y ) > k ) { System . out . print ( " H " ) ; Ksmallest ( x - 1 , y , k ) ; } else { System . out . print ( " V " ) ; Ksmallest ( x , y - 1 , k - factorial ( x - 1 , y ) ) ; } } } public static void main ( String [ ] args ) { int x = 2 , y = 2 , k = 2 ; Ksmallest ( x , y , k ) ; } }
import java . util . * ; class GFG { static int MaxIncreasingSub ( int arr [ ] , int n , int k ) { int dp [ ] [ ] = new int [ n ] [ k + 1 ] , ans = - 1 ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < k + 1 ; j ++ ) dp [ i ] [ j ] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 1 ] = arr [ i ] ; } for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < i ; j ++ ) { if ( arr [ j ] < arr [ i ] ) { for ( int l = 1 ; l <= k - 1 ; l ++ ) { if ( dp [ j ] [ l ] != - 1 ) { dp [ i ] [ l + 1 ] = Math . max ( dp [ i ] [ l + 1 ] , dp [ j ] [ l ] + arr [ i ] ) ; } } } } } for ( int i = 0 ; i < n ; i ++ ) { if ( ans < dp [ i ] [ k ] ) ans = dp [ i ] [ k ] ; } return ( ans == - 1 ) ? 0 : ans ; } public static void main ( String args [ ] ) { int n = 8 , k = 3 ; int arr [ ] = { 8 , 5 , 9 , 10 , 5 , 6 , 21 , 8 } ; int ans = MaxIncreasingSub ( arr , n , k ) ; System . out . println ( ans ) ; } }
class GFG { static int max_xor ( int arr [ ] , int n ) { int maxXor = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { maxXor = Math . max ( maxXor , arr [ i ] ^ arr [ j ] ) ; } } return maxXor ; } public static void main ( String [ ] args ) { int arr [ ] = { 25 , 10 , 2 , 8 , 5 , 3 } ; int n = arr . length ; System . out . println ( max_xor ( arr , n ) ) ; } }
class GFG { static int countAnomalies ( int arr [ ] , int n , int k ) { int cnt = 0 ; int i , sum = 0 ; for ( i = 0 ; i < n ; i ++ ) sum += arr [ i ] ; for ( i = 0 ; i < n ; i ++ ) if ( Math . abs ( arr [ i ] - ( sum - arr [ i ] ) ) > k ) cnt ++ ; return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 } ; int n = arr . length ; int k = 1 ; System . out . print ( countAnomalies ( arr , n , k ) ) ; } }
import java . util . * ; class GFG { static int cntWays ( String str , int n ) { int x = n + 1 ; int ways = x * x * ( x * x - 1 ) / 12 ; return ways ; } public static void main ( String [ ] args ) { String str = " ab " ; int n = str . length ( ) ; System . out . println ( cntWays ( str , n ) ) ; } }
import java . io . * ; class GFG { static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( divisorSum ( n ) ) ; n = 5 ; System . out . println ( divisorSum ( n ) ) ; } }
class GFG { static void printString ( char [ ] str , int n ) { int ones = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( str [ i ] == '1' ) ones ++ ; boolean used = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( str [ i ] == '2' && ! used ) { used = true ; for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; } if ( str [ i ] != '1' ) System . out . print ( str [ i ] ) ; } if ( ! used ) for ( int j = 0 ; j < ones ; j ++ ) System . out . print ( "1" ) ; } public static void main ( String [ ] args ) { String str = "100210" ; int n = str . length ( ) ; printString ( str . toCharArray ( ) , n ) ; } }
import java . io . * ; class GFG { static int bitAtGivenPosSetOrUnset ( int n , int k ) { int new_num = n >> ( k - 1 ) ; return ( new_num & 1 ) ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; if ( bitAtGivenPosSetOrUnset ( n , k ) == 1 ) System . out . println ( " Set " ) ; else System . out . println ( " Unset " ) ; } }
import java . util . HashMap ; class GFG { static int commonWords ( String [ ] s ) { int m , i , j ; String str ; HashMap < String , Boolean > has = new HashMap < > ( ) ; String [ ] ans1 = new String [ 100 ] ; boolean [ ] ans2 = new boolean [ 100 ] ; int track = 0 ; m = s . length ; i = 0 ; while ( i < s [ 0 ] . length ( ) ) { str = " " ; while ( i < s [ 0 ] . length ( ) && s [ 0 ] . charAt ( i ) != ' ▁ ' ) { str += s [ 0 ] . charAt ( i ) ; i ++ ; } i ++ ; if ( str . compareTo ( " " ) != 0 ) { ans1 [ track ] = str ; ans2 [ track ] = true ; track ++ ; } } for ( j = 1 ; j < m ; j ++ ) { has . clear ( ) ; i = 0 ; while ( i < s [ j ] . length ( ) ) { str = " " ; while ( i < s [ j ] . length ( ) && s [ j ] . charAt ( i ) != ' ▁ ' ) { str += s [ j ] . charAt ( i ) ; i ++ ; } i ++ ; if ( str . compareTo ( " " ) != 0 ) has . put ( str , true ) ; } for ( int k = 0 ; k < track ; k ++ ) { if ( ans2 [ k ] != false && ! has . containsKey ( ans1 [ k ] ) ) ans2 [ k ] = false ; else if ( ans2 [ k ] != false && has . containsKey ( ans1 [ k ] ) && has . get ( ans1 [ k ] ) == true ) has . put ( ans1 [ k ] , false ) ; } } int cnt = 0 ; for ( int k = 0 ; k < track ; k ++ ) if ( ans2 [ k ] == true ) cnt ++ ; return cnt ; } public static void main ( String [ ] args ) { String [ ] s = { " there ▁ is ▁ a ▁ cow " , " cow ▁ is ▁ our ▁ mother " , " cow ▁ gives ▁ us ▁ milk ▁ and ▁ milk ▁ is ▁ sweet " , " there ▁ is ▁ a ▁ boy ▁ who ▁ loves ▁ cow " } ; System . out . println ( commonWords ( s ) ) ; } }
import java . util . * ; class solution { static double circlearea ( double a ) { if ( a < 0 ) return - 1 ; double A = ( 3.14 * 3 * Math . pow ( a , 2 ) ) / 4 ; return A ; } public static void main ( String arr [ ] ) { double a = 4 ; System . out . println ( circlearea ( a ) ) ; } }
import java . util . * ; class GFG { static void checkTypeOfTriangle ( int a , int b , int c ) { int sqa = ( int ) Math . pow ( a , 2 ) ; int sqb = ( int ) Math . pow ( b , 2 ) ; int sqc = ( int ) Math . pow ( c , 2 ) ; if ( sqa == sqa + sqb || sqb == sqa + sqc || sqc == sqa + sqb ) { System . out . print ( " Right - angled ▁ Triangle " ) ; } else if ( sqa > sqc + sqb || sqb > sqa + sqc || sqc > sqa + sqb ) { System . out . print ( " Obtuse - angled ▁ Triangle " ) ; } else { System . out . print ( " Acute - angled ▁ Triangle " ) ; } } public static void main ( String [ ] args ) { int a , b , c ; a = 2 ; b = 2 ; c = 2 ; checkTypeOfTriangle ( a , b , c ) ; } }
public class GFG { public static int cubesum ( int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum += ( 2 * i + 1 ) * ( 2 * i + 1 ) * ( 2 * i + 1 ) ; return sum ; } public static void main ( String args [ ] ) { int a = 5 ; System . out . println ( cubesum ( a ) ) ; } }
class GFG { static void multiply ( int F [ ] [ ] , int M [ ] [ ] ) { int x = F [ 0 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 0 ] ; int y = F [ 0 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 0 ] [ 1 ] * M [ 1 ] [ 1 ] ; int z = F [ 1 ] [ 0 ] * M [ 0 ] [ 0 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 0 ] ; int w = F [ 1 ] [ 0 ] * M [ 0 ] [ 1 ] + F [ 1 ] [ 1 ] * M [ 1 ] [ 1 ] ; F [ 0 ] [ 0 ] = x ; F [ 0 ] [ 1 ] = y ; F [ 1 ] [ 0 ] = z ; F [ 1 ] [ 1 ] = w ; } static void power ( int F [ ] [ ] , int n ) { if ( n == 0 || n == 1 ) { return ; } int M [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; power ( F , n / 2 ) ; multiply ( F , F ) ; if ( n % 2 != 0 ) { multiply ( F , M ) ; } } static int countWays ( int n ) { int F [ ] [ ] = { { 1 , 1 } , { 1 , 0 } } ; if ( n == 0 ) { return 0 ; } power ( F , n ) ; return F [ 0 ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( countWays ( n ) ) ; } }
class GFG { static long answer ( int n ) { int [ ] dp = new int [ 10 ] ; int [ ] prev = new int [ 10 ] ; if ( n == 1 ) return 10 ; for ( int j = 0 ; j <= 9 ; j ++ ) dp [ j ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= 9 ; j ++ ) { prev [ j ] = dp [ j ] ; } for ( int j = 0 ; j <= 9 ; j ++ ) { if ( j == 0 ) dp [ j ] = prev [ j + 1 ] ; else if ( j == 9 ) dp [ j ] = prev [ j - 1 ] ; else dp [ j ] = prev [ j - 1 ] + prev [ j + 1 ] ; } } long sum = 0 ; for ( int j = 1 ; j <= 9 ; j ++ ) sum += dp [ j ] ; return sum ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( answer ( n ) ) ; } }
class GFG { static double PHI = 1.6180339 ; static int f [ ] = { 0 , 1 , 1 , 2 , 3 , 5 } ; static int fib ( int n ) { if ( n < 6 ) return f [ n ] ; int t = 5 ; int fn = 5 ; while ( t < n ) { fn = ( int ) Math . round ( fn * PHI ) ; t ++ ; } return fn ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( n + " th ▁ Fibonacci ▁ Number ▁ = ▁ " + fib ( n ) ) ; } }
public class GFG { static void printHutStar ( int n ) { int i , j ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) System . out . print ( " ▁ " ) ; for ( j = 0 ; j < ( 2 * i + 1 ) ; j ++ ) System . out . print ( " * " ) ; System . out . println ( ) ; } for ( i = 0 ; i < 3 ; i ++ ) { for ( j = 0 ; j < 3 ; j ++ ) System . out . print ( " * " ) ; for ( j = 0 ; j < ( 2 * n - 7 ) ; j ++ ) System . out . print ( " ▁ " ) ; for ( j = 0 ; j < 3 ; j ++ ) System . out . print ( " * " ) ; System . out . println ( ) ; } } public static void main ( String args [ ] ) { int n = 7 ; printHutStar ( n ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int Modulo ( int a , char b [ ] ) { int mod = 0 ; for ( int i = 0 ; i < b . length ; i ++ ) mod = ( mod * 10 + b [ i ] - '0' ) % a ; return mod ; } static int LastDigit ( char a [ ] , char b [ ] ) { int len_a = a . length , len_b = b . length ; if ( len_a == 1 && len_b == 1 && b [ 0 ] == '0' && a [ 0 ] == '0' ) return 1 ; if ( len_b == 1 && b [ 0 ] == '0' ) return 1 ; if ( len_a == 1 && a [ 0 ] == '0' ) return 0 ; int exp = ( Modulo ( 4 , b ) == 0 ) ? 4 : Modulo ( 4 , b ) ; int res = ( int ) ( Math . pow ( a [ len_a - 1 ] - '0' , exp ) ) ; return res % 10 ; } public static void main ( String args [ ] ) throws IOException { char a [ ] = "117" . toCharArray ( ) , b [ ] = { '3' } ; System . out . println ( LastDigit ( a , b ) ) ; } }
import java . io . * ; import java . math . * ; class GFG { static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( ( y & 1 ) == 1 ) res = ( res * x ) % p ; y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static boolean miillerTest ( int d , int n ) { int a = 2 + ( int ) ( Math . random ( ) % ( n - 4 ) ) ; int x = power ( a , d , n ) ; if ( x == 1 || x == n - 1 ) return true ; while ( d != n - 1 ) { x = ( x * x ) % n ; d *= 2 ; if ( x == 1 ) return false ; if ( x == n - 1 ) return true ; } return false ; } static boolean isPrime ( int n , int k ) { if ( n <= 1 || n == 4 ) return false ; if ( n <= 3 ) return true ; int d = n - 1 ; while ( d % 2 == 0 ) d /= 2 ; for ( int i = 0 ; i < k ; i ++ ) if ( ! miillerTest ( d , n ) ) return false ; return true ; } public static void main ( String args [ ] ) { int k = 4 ; System . out . println ( " All ▁ primes ▁ smaller ▁ " + " than ▁ 100 : ▁ " ) ; for ( int n = 1 ; n < 100 ; n ++ ) if ( isPrime ( n , k ) ) System . out . print ( n + " ▁ " ) ; } }
class GFG { static int remainderWith7 ( String num ) { int series [ ] = { 1 , 3 , 2 , - 1 , - 3 , - 2 } ; int series_index = 0 ; int result = 0 ; for ( int i = num . length ( ) - 1 ; i >= 0 ; i -- ) { int digit = num . charAt ( i ) - '0' ; result += digit * series [ series_index ] ; series_index = ( series_index + 1 ) % 6 ; result %= 7 ; } if ( result < 0 ) result = ( result + 7 ) % 7 ; return result ; } public static void main ( String [ ] args ) { String str = "12345" ; System . out . print ( " Remainder ▁ with ▁ 7 ▁ is ▁ " + remainderWith7 ( str ) ) ; } }
import java . util . * ; class GFG { public static int nthTerm ( int n ) { return ( n * n ) + ( n * n * n ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( nthTerm ( n ) ) ; } }
import java . util . * ; class GFG { static void findTriplets ( int x ) { Vector < Integer > fact = new Vector < Integer > ( ) ; HashSet < Integer > factors = new HashSet < Integer > ( ) ; for ( int i = 2 ; i <= Math . sqrt ( x ) ; i ++ ) { if ( x % i == 0 ) { fact . add ( i ) ; if ( x / i != i ) fact . add ( x / i ) ; factors . add ( i ) ; factors . add ( x / i ) ; } } boolean found = false ; int k = fact . size ( ) ; for ( int i = 0 ; i < k ; i ++ ) { int a = fact . get ( i ) ; for ( int j = 0 ; j < k ; j ++ ) { int b = fact . get ( j ) ; if ( ( a != b ) && ( x % ( a * b ) == 0 ) && ( x / ( a * b ) != a ) && ( x / ( a * b ) != b ) && ( x / ( a * b ) != 1 ) ) { System . out . print ( a + " ▁ " + b + " ▁ " + ( x / ( a * b ) ) ) ; found = true ; break ; } } if ( found ) break ; } if ( ! found ) System . out . print ( " - 1" ) ; } public static void main ( String [ ] args ) { int x = 105 ; findTriplets ( x ) ; } }
import java . util . * ; class GFG { static void unique_combination ( int l , int sum , int K , Vector < Integer > local , Vector < Integer > A ) { if ( sum == K ) { System . out . print ( " { " ) ; for ( int i = 0 ; i < local . size ( ) ; i ++ ) { if ( i != 0 ) System . out . print ( " ▁ " ) ; System . out . print ( local . get ( i ) ) ; if ( i != local . size ( ) - 1 ) System . out . print ( " , ▁ " ) ; } System . out . println ( " } " ) ; return ; } for ( int i = l ; i < A . size ( ) ; i ++ ) { if ( sum + A . get ( i ) > K ) continue ; if ( i == 1 && A . get ( i ) == A . get ( i - 1 ) && i > l ) continue ; local . add ( A . get ( i ) ) ; unique_combination ( i + 1 , sum + A . get ( i ) , K , local , A ) ; local . remove ( local . size ( ) - 1 ) ; } } static void Combination ( Vector < Integer > A , int K ) { Collections . sort ( A ) ; Vector < Integer > local = new Vector < Integer > ( ) ; unique_combination ( 0 , 0 , K , local , A ) ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 10 , 1 , 2 , 7 , 6 , 1 , 5 } ; Vector < Integer > A = new Vector < > ( Arrays . asList ( arr ) ) ; int K = 8 ; Combination ( A , K ) ; } }
import java . util . * ; class GFG { static int countPairs ( int a [ ] , int n ) { int mn = Integer . MAX_VALUE ; int mx = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) { mn = Math . min ( mn , a [ i ] ) ; mx = Math . max ( mx , a [ i ] ) ; } int c1 = 0 ; int c2 = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == mn ) c1 ++ ; if ( a [ i ] == mx ) c2 ++ ; } if ( mn == mx ) return n * ( n - 1 ) / 2 ; else return c1 * c2 ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 2 , 1 , 1 , 3 } ; int n = a . length ; System . out . print ( countPairs ( a , n ) ) ; } }
class LPS { static int max ( int x , int y ) { return ( x > y ) ? x : y ; } static int lps ( String seq ) { int n = seq . length ( ) ; int i , j , cl ; int L [ ] [ ] = new int [ n ] [ n ] ; for ( i = 0 ; i < n ; i ++ ) L [ i ] [ i ] = 1 ; for ( cl = 2 ; cl <= n ; cl ++ ) { for ( i = 0 ; i < n - cl + 1 ; i ++ ) { j = i + cl - 1 ; if ( seq . charAt ( i ) == seq . charAt ( j ) && cl == 2 ) L [ i ] [ j ] = 2 ; else if ( seq . charAt ( i ) == seq . charAt ( j ) ) L [ i ] [ j ] = L [ i + 1 ] [ j - 1 ] + 2 ; else L [ i ] [ j ] = max ( L [ i ] [ j - 1 ] , L [ i + 1 ] [ j ] ) ; } } return L [ 0 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { String seq = " GEEKSFORGEEKS " ; int n = seq . length ( ) ; System . out . println ( " The ▁ lnegth ▁ of ▁ the ▁ lps ▁ is ▁ " + lps ( seq ) ) ; } }
class GFG { static int lenDoubleString ( String s ) { int l = s . length ( ) ; String first_half = s . substring ( 0 , l / 2 ) ; String second_half = " " ; if ( l % 2 == 0 ) second_half = s . substring ( l / 2 ) ; else second_half = s . substring ( l / 2 + 1 ) ; second_half = reverse ( second_half ) ; System . out . println ( first_half + second_half ) ; if ( l % 2 == 0 ) System . out . println ( l ) ; else System . out . println ( l - 1 ) ; return Integer . MIN_VALUE ; } static String reverse ( String input ) { char [ ] temparray = input . toCharArray ( ) ; int left , right = 0 ; right = temparray . length - 1 ; for ( left = 0 ; left < right ; left ++ , right -- ) { char temp = temparray [ left ] ; temparray [ left ] = temparray [ right ] ; temparray [ right ] = temp ; } return String . valueOf ( temparray ) ; } public static void main ( String [ ] args ) { String n = " abba " ; lenDoubleString ( n ) ; n = " abcdedcba " ; lenDoubleString ( n ) ; } }
import java . io . * ; class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return fact ; } static int ncr ( int n , int r ) { return factorial ( n ) / ( factorial ( r ) * factorial ( n - r ) ) ; } public static void main ( String [ ] args ) { int m = 3 , n = 4 , k = 5 ; int totalTriangles = ncr ( m + n + k , 3 ) - ncr ( m , 3 ) - ncr ( n , 3 ) - ncr ( k , 3 ) ; System . out . println ( totalTriangles ) ; } }
class GFG { static boolean isEven ( int n ) { if ( ( n ^ 1 ) == n + 1 ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 100 ; System . out . print ( isEven ( n ) == true ? " Even " : " Odd " ) ; } }
class GFG { static void printArr ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } static void generateArr ( int A [ ] , int n ) { int [ ] B = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { int cnt = 0 ; for ( int j = 0 ; j < i ; j ++ ) { if ( A [ j ] % A [ i ] == 0 ) cnt ++ ; } B [ i ] = cnt ; } printArr ( B , n ) ; } public static void main ( String args [ ] ) { int A [ ] = { 3 , 5 , 1 } ; int n = A . length ; generateArr ( A , n ) ; } }
class GFG { static int minXOR ( int arr [ ] , int n ) { int min_xor = Integer . MAX_VALUE ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) min_xor = Math . min ( min_xor , arr [ i ] ^ arr [ j ] ) ; return min_xor ; } public static void main ( String args [ ] ) { int arr [ ] = { 9 , 5 , 3 } ; int n = arr . length ; System . out . println ( minXOR ( arr , n ) ) ; } }
class Test { static boolean isPowerOfTwo ( int x ) { return x != 0 && ( ( x & ( x - 1 ) ) == 0 ) ; } public static void main ( String [ ] args ) { System . out . println ( isPowerOfTwo ( 31 ) ? " Yes " : " No " ) ; System . out . println ( isPowerOfTwo ( 64 ) ? " Yes " : " No " ) ; } }
import java . io . * ; class GFG { static String areAllBitsSet ( int n ) { if ( n == 0 ) return " No " ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) return " No " ; n = n >> 1 ; } return " Yes " ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . println ( areAllBitsSet ( n ) ) ; } }
import java . io . * ; class GFG { static int findevenPair ( int [ ] A , int N ) { int i , j ; int evenPair = 0 ; for ( i = 0 ; i < N ; i ++ ) { for ( j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] & A [ j ] ) % 2 == 0 ) evenPair ++ ; } } return evenPair ; } public static void main ( String [ ] args ) { int [ ] a = { 5 , 1 , 3 , 2 } ; int n = a . length ; System . out . println ( findevenPair ( a , n ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static int countTriplets ( int n , Vector < pair > points ) { Set < pair > pts = new HashSet < pair > ( ) ; int ct = 0 ; for ( int i = 0 ; i < n ; i ++ ) pts . add ( points . get ( i ) ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i + 1 ; j < n ; j ++ ) { int x = points . get ( i ) . first + points . get ( j ) . first ; int y = points . get ( i ) . second + points . get ( j ) . second ; if ( x % 2 == 0 && y % 2 == 0 ) if ( ! pts . contains ( new pair ( x / 2 , y / 2 ) ) ) ct ++ ; } return ct ; } public static void main ( String args [ ] ) { Vector < pair > points = new Vector < > ( ) ; points . add ( new pair ( 1 , 1 ) ) ; points . add ( new pair ( 2 , 2 ) ) ; points . add ( new pair ( 3 , 3 ) ) ; int n = points . size ( ) ; System . out . println ( countTriplets ( n , points ) ) ; } }
import java . util . * ; class Main { static void printTwoOdd ( int arr [ ] , int size ) { int xor2 = arr [ 0 ] ; int set_bit_no ; int i ; int n = size - 2 ; int x = 0 , y = 0 ; for ( i = 1 ; i < size ; i ++ ) xor2 = xor2 ^ arr [ i ] ; set_bit_no = xor2 & ~ ( xor2 - 1 ) ; for ( i = 0 ; i < size ; i ++ ) { if ( ( arr [ i ] & set_bit_no ) > 0 ) x = x ^ arr [ i ] ; else y = y ^ arr [ i ] ; } System . out . println ( " The ▁ two ▁ ODD ▁ elements ▁ are ▁ " + x + " ▁ & ▁ " + y ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 4 , 5 , 2 , 3 , 3 , 1 } ; int arr_size = arr . length ; printTwoOdd ( arr , arr_size ) ; } }
import java . io . * ; class GFG { static double trianglearea ( double a ) { if ( a < 0 ) return - 1 ; double area = ( 3 * Math . sqrt ( 3 ) * Math . pow ( a , 2 ) ) / 4 ; return area ; } public static void main ( String [ ] args ) { double a = 6 ; System . out . println ( trianglearea ( a ) ) ; } }
import java . util . * ; class GFG { static int calculate ( int a [ ] , int n ) { Arrays . sort ( a ) ; int count = 1 ; int answer = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( a [ i ] == a [ i - 1 ] ) { count += 1 ; } else { answer = answer + ( count * ( count - 1 ) ) / 2 ; count = 1 ; } } answer = answer + ( count * ( count - 1 ) ) / 2 ; return answer ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 2 , 1 , 2 , 4 } ; int n = a . length ; System . out . println ( calculate ( a , n ) ) ; } }
import java . io . * ; class GFG { static int countPrimeFactors ( int n ) { int count = 0 ; while ( n % 2 == 0 ) { n = n / 2 ; count ++ ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { n = n / i ; count ++ ; } } if ( n > 2 ) count ++ ; return ( count ) ; } static void printKAlmostPrimes ( int k , int n ) { for ( int i = 1 , num = 2 ; i <= n ; num ++ ) { if ( countPrimeFactors ( num ) == k ) { System . out . print ( num + " ▁ " ) ; i ++ ; } } return ; } public static void main ( String [ ] args ) { int n = 10 , k = 2 ; System . out . println ( " First ▁ " + n + " ▁ " + k + " - almost ▁ prime ▁ numbers ▁ : ▁ " ) ; printKAlmostPrimes ( k , n ) ; } }
class GFG { static int LAS [ ] [ ] = new int [ 1000 ] [ 2 ] ; static int solve ( int arr [ ] , int n , int i , int pos ) { if ( i == n ) return 0 ; if ( LAS [ i ] [ pos ] == 1 ) return LAS [ i ] [ pos ] ; int inc = 0 , exc = 0 ; if ( arr [ i ] > 0 && pos == 1 ) { pos = 0 ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } else if ( arr [ i ] < 0 && pos == 0 ) { pos = 1 ; inc = 1 + solve ( arr , n , i + 1 , pos ) ; } exc = solve ( arr , n , i + 1 , pos ) ; LAS [ i ] [ pos ] = Math . max ( inc , exc ) ; return LAS [ i ] [ pos ] ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , 3 , 4 , 5 , - 6 , 8 , - 99 } ; int n = arr . length ; System . out . println ( Math . max ( solve ( arr , n , 0 , 0 ) , solve ( arr , n , 0 , 1 ) ) ) ; } }
import java . util . * ; class GFG { static void expressDigit ( int arr [ ] , int n ) { int min = 9 , index = 0 , temp = 0 ; temp = arr [ 0 ] ; for ( int i = 1 ; i < 10 ; i ++ ) { if ( arr [ i ] < min ) { min = arr [ i ] ; index = i ; } } if ( temp < min ) { System . out . print ( 1 ) ; for ( int i = 1 ; i <= temp + 1 ; i ++ ) System . out . print ( 0 ) ; } else { for ( int i = 0 ; i < min ; i ++ ) System . out . print ( index ) ; System . out . print ( index ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 1 , 2 , 1 , 1 , 3 , 1 , 1 , 1 } ; int N = 10 ; expressDigit ( arr , N ) ; } }
import java . util . Arrays ; class GFG { static int maxProduct ( int arr [ ] , int n ) { if ( n < 3 ) { return - 1 ; } Arrays . sort ( arr ) ; return Math . max ( arr [ 0 ] * arr [ 1 ] * arr [ n - 1 ] , arr [ n - 1 ] * arr [ n - 2 ] * arr [ n - 3 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 10 , - 3 , 5 , 6 , - 20 } ; int n = arr . length ; int max = maxProduct ( arr , n ) ; if ( max == - 1 ) { System . out . println ( " No ▁ Triplet ▁ Exists " ) ; } else { System . out . println ( " Maximum ▁ product ▁ is ▁ " + max ) ; } } }
import java . io . * ; class GFG { static int R = 4 ; static int C = 4 ; static int getTotalCoverageOfMatrix ( int [ ] [ ] mat ) { int res = 0 ; for ( int i = 0 ; i < R ; i ++ ) { boolean isOne = false ; for ( int j = 0 ; j < C ; j ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int j = C - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } for ( int j = 0 ; j < C ; j ++ ) { boolean isOne = false ; for ( int i = 0 ; i < R ; i ++ ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } isOne = false ; for ( int i = R - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) isOne = true ; else if ( isOne ) res ++ ; } } return res ; } static public void main ( String [ ] args ) { int [ ] [ ] mat = { { 0 , 0 , 0 , 0 } , { 1 , 0 , 0 , 1 } , { 0 , 1 , 1 , 0 } , { 0 , 1 , 0 , 0 } } ; System . out . println ( getTotalCoverageOfMatrix ( mat ) ) ; } }
import java . util . Arrays ; class GfG { static boolean isPalindrome ( String str , int i , int j ) { while ( i < j ) { if ( str . charAt ( i ) != str . charAt ( j ) ) return false ; i ++ ; j -- ; } return true ; } static int countPrimePalindrome ( String str , int len ) { boolean [ ] prime = new boolean [ len + 1 ] ; Arrays . fill ( prime , true ) ; prime [ 0 ] = prime [ 1 ] = false ; for ( int p = 2 ; p * p <= len ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * p ; i <= len ; i += p ) prime [ i ] = false ; } } int count = 0 ; for ( int j = 2 ; j <= len ; j ++ ) { if ( prime [ j ] ) { for ( int i = 0 ; i + j - 1 < len ; i ++ ) { if ( isPalindrome ( str , i , i + j - 1 ) ) count ++ ; } } } return count ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int len = s . length ( ) ; System . out . println ( countPrimePalindrome ( s , len ) ) ; } }
import java . io . * ; class GFG { static int MAX = 100001 ; static int [ ] isPrime = new int [ MAX ] ; static int sieve ( ) { for ( int p = 2 ; p * p < MAX ; p ++ ) { if ( isPrime [ p ] == 0 ) { for ( int i = p * 2 ; i < MAX ; i += p ) isPrime [ i ] = 1 ; } } return - 1 ; } static int findSubset ( int [ ] a , int n ) { int cnt1 = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( a [ i ] == 1 ) cnt1 ++ ; if ( cnt1 > 0 ) { for ( int i = 0 ; i < n ; i ++ ) { if ( ( a [ i ] != 1 ) && ( isPrime [ a [ i ] + 1 ] == 0 ) ) { System . out . println ( cnt1 + 1 ) ; for ( int j = 0 ; j < cnt1 ; j ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . println ( a [ i ] ) ; return 0 ; } } } if ( cnt1 >= 2 ) { System . out . println ( cnt1 ) ; for ( int i = 0 ; i < cnt1 ; i ++ ) System . out . print ( 1 + " ▁ " ) ; System . out . println ( ) ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( isPrime [ a [ i ] + a [ j ] ] == 0 ) { System . out . println ( 2 ) ; System . out . println ( a [ i ] + " ▁ " + a [ j ] ) ; return 0 ; } } } System . out . println ( - 1 ) ; return - 1 ; } public static void main ( String args [ ] ) { sieve ( ) ; int [ ] A = new int [ ] { 2 , 1 , 1 } ; int n = A . length ; findSubset ( A , n ) ; } }
class GFG { static int minMoves ( int n ) { String s = Integer . toString ( n ) ; int ans = Integer . MAX_VALUE ; int len = s . length ( ) ; for ( int i = 0 ; i < len ; ++ i ) { for ( int j = 0 ; j < len ; ++ j ) { if ( i == j ) continue ; char t [ ] = s . toCharArray ( ) ; int cur = 0 ; for ( int k = i ; k < len - 1 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } for ( int k = j - ( ( j > i ) ? 1 : 0 ) ; k < len - 2 ; ++ k ) { swap ( t , k , k + 1 ) ; ++ cur ; } int pos = - 1 ; for ( int k = 0 ; k < len ; ++ k ) { if ( t [ k ] != '0' ) { pos = k ; break ; } } for ( int k = pos ; k > 0 ; -- k ) { swap ( t , k , k - 1 ) ; ++ cur ; } long nn = Integer . parseInt ( String . valueOf ( t ) ) ; if ( nn % 25 == 0 ) ans = Math . min ( ans , cur ) ; } } if ( ans == Integer . MAX_VALUE ) return - 1 ; return ans ; } static void swap ( char t [ ] , int i , int j ) { char temp = t [ i ] ; t [ i ] = t [ j ] ; t [ j ] = temp ; } public static void main ( String [ ] args ) { int n = 509201 ; System . out . println ( minMoves ( n ) ) ; } }
import java . io . * ; class GFG { static double findSum ( long n ) { return Math . sqrt ( 3 ) * ( n * ( n + 1 ) / 2 ) ; } public static void main ( String [ ] args ) { long n = 10 ; System . out . println ( findSum ( n ) ) ; } }
import java . io . * ; class GFG { static int merge ( int arr [ ] , int temp [ ] , int left , int mid , int right ) { int inv_count = 0 ; int i = left ; int j = mid ; int k = left ; while ( ( i <= mid - 1 ) && ( j <= right ) ) { if ( arr [ i ] <= arr [ j ] ) temp [ k ++ ] = arr [ i ++ ] ; else { temp [ k ++ ] = arr [ j ++ ] ; inv_count = inv_count + ( mid - i ) ; } } while ( i <= mid - 1 ) temp [ k ++ ] = arr [ i ++ ] ; while ( j <= right ) temp [ k ++ ] = arr [ j ++ ] ; for ( i = left ; i <= right ; i ++ ) arr [ i ] = temp [ i ] ; return inv_count ; } static int _mergeSort ( int arr [ ] , int temp [ ] , int left , int right ) { int mid , inv_count = 0 ; if ( right > left ) { mid = ( right + left ) / 2 ; inv_count = _mergeSort ( arr , temp , left , mid ) ; inv_count += _mergeSort ( arr , temp , mid + 1 , right ) ; inv_count += merge ( arr , temp , left , mid + 1 , right ) ; } return inv_count ; } static int countSwaps ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; return _mergeSort ( arr , temp , 0 , n - 1 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 20 , 6 , 4 , 5 } ; int n = arr . length ; System . out . println ( " Number ▁ of ▁ swaps ▁ is ▁ " + countSwaps ( arr , n ) ) ; } }
import java . util . * ; class GFG { static int n ; static int solve ( int i , int x , int dp [ ] [ ] ) { if ( i < 0 ) { return x == 3 ? 1 : 0 ; } if ( dp [ i ] [ x ] != - 1 ) { return dp [ i ] [ x ] ; } dp [ i ] [ x ] = solve ( i - 1 , 0 , dp ) ; dp [ i ] [ x ] += solve ( i - 1 , x + 1 , dp ) ; return dp [ i ] [ x ] ; } public static void main ( String [ ] args ) { n = 4 ; int dp [ ] [ ] = new int [ n ] [ 4 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < 4 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } for ( int i = 0 ; i < n ; i ++ ) { dp [ i ] [ 3 ] = ( 1 << ( i + 1 ) ) ; } System . out . print ( solve ( n - 1 , 0 , dp ) ) ; } }
class GFG { static int minCost ( int [ ] cost , int n ) { int totalCost = 0 ; int boardingBus = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( cost [ boardingBus ] > cost [ i ] ) { totalCost += ( ( i - boardingBus ) * cost [ boardingBus ] ) ; boardingBus = i ; } } totalCost += ( ( n - boardingBus ) * cost [ boardingBus ] ) ; return totalCost ; } public static void main ( String [ ] args ) { int [ ] cost = { 4 , 7 , 8 , 3 , 4 } ; int n = cost . length ; System . out . print ( minCost ( cost , n ) ) ; } }
import java . util . * ; class GFG { static int countSquares ( int m , int n ) { if ( n < m ) { int temp = m ; m = n ; n = temp ; } return n * ( n + 1 ) * ( 3 * m - n + 1 ) / 6 ; } public static void main ( String [ ] args ) { int m = 4 ; int n = 3 ; System . out . print ( " Count ▁ of ▁ squares ▁ is ▁ " + countSquares ( m , n ) ) ; } }
import java . util . * ; class GfG { static int N = 100005 ; static int MAX = 10000002 ; static int lpd [ ] = new int [ MAX ] ; static void preCompute ( ) { lpd [ 0 ] = lpd [ 1 ] = 1 ; for ( int i = 2 ; i * i < MAX ; i ++ ) { for ( int j = i * 2 ; j < MAX ; j += i ) { if ( lpd [ j ] == 0 ) { lpd [ j ] = i ; } } } for ( int i = 2 ; i < MAX ; i ++ ) { if ( lpd [ i ] == 0 ) { lpd [ i ] = i ; } } } static int maxLengthSubsequence ( int arr [ ] , int n ) { int dp [ ] = new int [ N ] ; Map < Integer , Integer > pos = new HashMap < Integer , Integer > ( ) ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { while ( arr [ i ] > 1 ) { int p = lpd [ arr [ i ] ] ; if ( pos . containsKey ( p ) ) { dp [ i ] = Math . max ( dp [ i ] , 1 + dp [ pos . get ( p ) ] ) ; } pos . put ( p , i ) ; while ( arr [ i ] % p == 0 ) arr [ i ] /= p ; } } int ans = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { ans = Math . max ( ans , dp [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 13 , 2 , 8 , 6 , 3 , 1 , 9 } ; int n = arr . length - 1 ; preCompute ( ) ; System . out . println ( maxLengthSubsequence ( arr , n ) ) ; } }
import java . io . * ; class GFG { static void Swap ( int [ ] array , int position1 , int position2 ) { int temp = array [ position1 ] ; array [ position1 ] = array [ position2 ] ; array [ position2 ] = temp ; } static int partition ( int [ ] arr , int low , int high ) { int pivot = arr [ high ] ; int i = ( low - 1 ) ; for ( int j = low ; j <= high - 1 ; j ++ ) { if ( arr [ j ] <= pivot ) { i ++ ; Swap ( arr , i , j ) ; } } Swap ( arr , i + 1 , high ) ; return ( i + 1 ) ; } static void quickSort ( int [ ] arr , int low , int high ) { if ( low < high ) { int pi = partition ( arr , low , high ) ; quickSort ( arr , low , pi - 1 ) ; quickSort ( arr , pi + 1 , high ) ; } } static void printArray ( int [ ] arr , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( " ▁ " + arr [ i ] ) ; System . out . println ( ) ; } static public void main ( String [ ] args ) { int [ ] arr = { 10 , 7 , 8 , 9 , 1 , 5 } ; int n = arr . length ; quickSort ( arr , 0 , n - 1 ) ; System . out . println ( " Sorted ▁ array : ▁ " ) ; printArray ( arr , n ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static int gcdExtended ( int a , int b , int x , int y ) { if ( a == 0 ) { x = 0 ; y = 1 ; return b ; } int x1 = 1 , y1 = 1 ; int gcd = gcdExtended ( b % a , a , x1 , y1 ) ; x = y1 - ( b / a ) * x1 ; y = x1 ; return gcd ; } public static void main ( String [ ] args ) { int x = 1 , y = 1 ; int a = 35 , b = 15 ; int g = gcdExtended ( a , b , x , y ) ; System . out . print ( " gcd ( " + a + " ▁ , ▁ " + b + " ) ▁ = ▁ " + g ) ; } }
public class Test { public static int floorSqrt ( int x ) { if ( x == 0 || x == 1 ) return x ; int start = 1 , end = x , ans = 0 ; while ( start <= end ) { int mid = ( start + end ) / 2 ; if ( mid * mid == x ) return mid ; if ( mid * mid < x ) { start = mid + 1 ; ans = mid ; } else end = mid - 1 ; } return ans ; } public static void main ( String args [ ] ) { int x = 11 ; System . out . println ( floorSqrt ( x ) ) ; } }
import java . util . * ; class GFG { static void shortestDistance ( String S , char X ) { int prev = Integer . MAX_VALUE ; Vector < Integer > ans = new Vector < > ( ) ; for ( int i = 0 ; i < S . length ( ) ; i ++ ) { if ( S . charAt ( i ) == X ) prev = i ; ans . add ( i - prev ) ; } prev = Integer . MAX_VALUE ; for ( int i = S . length ( ) - 1 ; i >= 0 ; i -- ) { if ( S . charAt ( i ) == X ) prev = i ; ans . set ( i , Math . min ( ans . get ( i ) , prev - i ) ) ; } for ( Integer val : ans ) System . out . print ( val + " ▁ " ) ; } public static void main ( String [ ] args ) { String S = " geeksforgeeks " ; char X = ' g ' ; shortestDistance ( S , X ) ; } }
import java . math . * ; class GFG { static int MAX = 100001 ; static double dp [ ] = new double [ MAX ] ; static double probability ( int k , int n ) { double ans = 0.0 ; for ( int i = k ; i <= n ; ++ i ) { double res = dp [ n ] - dp [ i ] - dp [ n - i ] - n ; ans += Math . pow ( 2.0 , res ) ; } return ans ; } static void precompute ( ) { for ( int i = 2 ; i < MAX ; ++ i ) dp [ i ] = ( Math . log ( i ) / Math . log ( 2 ) ) + dp [ i - 1 ] ; } public static void main ( String args [ ] ) { precompute ( ) ; System . out . println ( probability ( 2 , 3 ) ) ; System . out . println ( probability ( 3 , 6 ) ) ; System . out . println ( probability ( 500 , 1000 ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static int maximumXOR ( int n , int l , int r ) { int x = 0 ; for ( int i = ( int ) ( Math . log ( r ) / Math . log ( 2 ) ) ; i >= 0 ; -- i ) { if ( ( n & ( 1 << i ) ) > 0 ) { if ( ( x > r ) || ( x + ( 1 << i ) - 1 < l ) ) x ^= ( 1 << i ) ; } else { if ( ( x ^ ( 1 << i ) ) <= r ) x ^= ( 1 << i ) ; } } return n ^ x ; } public static void main ( String args [ ] ) { int n = 7 , l = 2 , r = 23 ; System . out . println ( " The ▁ output ▁ is ▁ " + maximumXOR ( n , l , r ) ) ; } }
import java . io . * ; class GFG { static double edgeDisjoint ( int n ) { double result = 0 ; result = Math . floor ( n / 2 ) ; return result ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( ( int ) edgeDisjoint ( n ) ) ; } }
import java . io . * ; class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static long Probability ( int sum , int times ) { float favorable = 0 , total = 36 ; long probability = 0 ; for ( int i = 1 ; i <= 6 ; i ++ ) { for ( int j = 1 ; j <= 6 ; j ++ ) { if ( ( i + j ) == sum ) favorable ++ ; } } int gcd1 = __gcd ( ( int ) favorable , ( int ) total ) ; favorable = favorable / ( float ) gcd1 ; total = total / ( float ) gcd1 ; probability = ( long ) Math . pow ( total , times ) ; return probability ; } public static void main ( String [ ] args ) { int sum = 7 , times = 7 ; System . out . println ( "1" + " / " + Probability ( sum , times ) ) ; } }
import java . io . * ; class GFG { static int NumberOfSolutions ( int a , int b , int c , int d ) { int ans = 0 ; for ( int i = a ; i <= b ; i ++ ) if ( d >= Math . max ( c , i + 1 ) ) ans += d - Math . max ( c , i + 1 ) + 1 ; return ans ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , c = 3 , d = 4 ; System . out . println ( NumberOfSolutions ( a , b , c , d ) ) ; } }
import java . util . * ; class GFG { static String reverse ( char [ ] str , int len , int l , int r ) { if ( l < 0 || r >= len || l > r ) return " Invalid ▁ range ! " ; while ( l < r ) { char c = str [ l ] ; str [ l ] = str [ r ] ; str [ r ] = c ; l ++ ; r -- ; } String string = new String ( str ) ; return string ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; int len = str . length ( ) ; int l = 5 , r = 7 ; System . out . println ( reverse ( str . toCharArray ( ) , len , l , r ) ) ; } }
import java . util . * ; class GFG { public static int MAX = 1000000 ; static ArrayList < Integer > primes = new ArrayList < Integer > ( ) ; static void sieveSundaram ( ) { boolean [ ] marked = new boolean [ MAX ] ; for ( int i = 1 ; i <= ( Math . sqrt ( MAX ) - 1 ) / 2 ; i ++ ) { for ( int j = ( i * ( i + 1 ) ) << 1 ; j <= MAX / 2 ; j += 2 * i + 1 ) { marked [ j ] = true ; } } primes . add ( 2 ) ; for ( int i = 1 ; i <= MAX / 2 ; i ++ ) { if ( marked [ i ] == false ) { primes . add ( 2 * i + 1 ) ; } } } static int calculatePrimorial ( int n ) { int result = 1 ; for ( int i = 0 ; i < n ; i ++ ) { result = result * primes . get ( i ) ; } return result ; } public static void main ( String [ ] args ) { int n = 5 ; sieveSundaram ( ) ; for ( int i = 1 ; i <= n ; i ++ ) { System . out . println ( " Primorial ( P # ) ▁ of ▁ " + i + " ▁ is ▁ " + calculatePrimorial ( i ) ) ; } } }
import java . util . * ; class GFG { static int countOccurrances ( int n , int d ) { int count = 0 ; while ( n > 0 ) { count = ( n % 10 == d ) ? count + 1 : count ; n = n / 10 ; } return count ; } public static void main ( String args [ ] ) { int d = 2 ; int n = 214215421 ; System . out . println ( countOccurrances ( n , d ) ) ; } }
import java . util . * ; class GFG { static void SieveOfEratosthenes ( boolean prime [ ] , int p_size ) { prime [ 0 ] = false ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= p_size ; p ++ ) { if ( prime [ p ] ) { for ( int i = p * 2 ; i <= p_size ; i += p ) prime [ i ] = false ; } } } static int sumOfElements ( int arr [ ] , int n ) { boolean prime [ ] = new boolean [ n + 1 ] ; Arrays . fill ( prime , true ) ; SieveOfEratosthenes ( prime , n + 1 ) ; int i , j ; HashMap < Integer , Integer > m = new HashMap < > ( ) ; for ( i = 0 ; i < n ; i ++ ) { if ( m . containsKey ( arr [ i ] ) ) m . put ( arr [ i ] , m . get ( arr [ i ] ) + 1 ) ; else m . put ( arr [ i ] , 1 ) ; } int sum = 0 ; for ( Map . Entry < Integer , Integer > entry : m . entrySet ( ) ) { int key = entry . getKey ( ) ; int value = entry . getValue ( ) ; if ( prime [ value ] ) { sum += ( key ) ; } } return sum ; } public static void main ( String args [ ] ) { int arr [ ] = { 5 , 4 , 6 , 5 , 4 , 6 } ; int n = arr . length ; System . out . println ( sumOfElements ( arr , n ) ) ; } }
import java . util . * ; class Geeks_For_Geeks { public static int [ ] sortArrays ( int [ ] arr ) { int length = arr . length ; for ( int j = 0 ; j < length - 1 ; j ++ ) { if ( arr [ j ] > arr [ j + 1 ] ) { int temp = arr [ j ] ; arr [ j ] = arr [ j + 1 ] ; arr [ j + 1 ] = temp ; j = - 1 ; } } return arr ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 2 , 99 , 9 , 8 , 7 , 6 , 0 , 5 , 4 , 3 } ; System . out . println ( " Original ▁ array : ▁ " + Arrays . toString ( arr ) ) ; arr = sortArrays ( arr ) ; System . out . println ( " Sorted ▁ array : ▁ " + Arrays . toString ( arr ) ) ; } }
class Geeks { static boolean check ( int i , int val ) { if ( i - val < 0 ) return false ; else return true ; } static double MinimumPrimes ( int n ) { double [ ] dp ; dp = new double [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) dp [ i ] = 1e9 ; dp [ 0 ] = dp [ 2 ] = dp [ 3 ] = dp [ 5 ] = dp [ 7 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( check ( i , 2 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 2 ] ) ; if ( check ( i , 3 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 3 ] ) ; if ( check ( i , 5 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 5 ] ) ; if ( check ( i , 7 ) ) dp [ i ] = Math . min ( dp [ i ] , 1 + dp [ i - 7 ] ) ; } if ( dp [ n ] == ( 1e9 ) ) return - 1 ; else return dp [ n ] ; } public static void main ( String args [ ] ) { int n = 12 ; int minimal = ( int ) MinimumPrimes ( n ) ; if ( minimal != - 1 ) System . out . println ( " Minimum ▁ number ▁ of ▁ single ▁ " + " digit ▁ primes ▁ required : ▁ " + minimal ) ; else System . out . println ( " Not ▁ Possible " ) ; } }
import java . io . * ; class GFG { static int binomialCoeff ( int n , int k ) { int C [ ] [ ] = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } public static void main ( String [ ] args ) { int n = 5 , k = 3 ; System . out . println ( " Total ▁ number ▁ of ▁ " + " different ▁ ways ▁ are ▁ " + binomialCoeff ( n - 1 , k - 1 ) ) ; } }
public class FINDSUM { static long mod = 1000000007 ; public static long findSum ( long n ) { return ( ( n % mod ) * ( n % mod ) ) % mod ; } public static void main ( String [ ] args ) { long n = 229137999 ; System . out . print ( findSum ( n ) ) ; } }
import java . io . * ; class GFG { static void print ( int n , int k ) { int rem = 1 ; for ( int i = 0 ; i < k ; i ++ ) { System . out . print ( ( 10 * rem ) / n ) ; rem = ( 10 * rem ) % n ; } } public static void main ( String [ ] args ) { int n = 7 , k = 3 ; print ( n , k ) ; System . out . println ( ) ; n = 21 ; k = 4 ; print ( n , k ) ; } }
class GFG { public static void main ( String [ ] args ) { int [ ] [ ] matrix = new int [ 5 ] [ 5 ] ; int row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } System . out . printf ( " The ▁ matrix ▁ is \n " ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { System . out . printf ( " % d\t " , matrix [ row_index ] [ column_index ] ) ; } System . out . printf ( " \n " ) ; } System . out . printf ( " \n Elements ▁ below ▁ Secondary " + " ▁ diagonal ▁ are : \n " ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index + column_index ) > size - 1 ) System . out . printf ( " % d , ▁ " , matrix [ row_index ] [ column_index ] ) ; } } } }
import java . util . HashSet ; class GFG { static int findProduct ( int arr [ ] , int n ) { int prod = 1 ; HashSet < Integer > s = new HashSet < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { prod *= arr [ i ] ; s . add ( arr [ i ] ) ; } } return prod ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( findProduct ( arr , n ) ) ; } }
class GFG { static int findNumber ( int n ) { for ( int i = n - 1 ; i >= 0 ; i -- ) { int [ ] count = new int [ 10 ] ; int x = i ; int count1 = 0 , count2 = 0 ; while ( x > 0 ) { count [ x % 10 ] ++ ; x /= 10 ; count1 ++ ; } for ( int j = 0 ; j < 10 ; j ++ ) { if ( count [ j ] == 1 ) count2 ++ ; } if ( count1 == count2 ) return i ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 8490 ; System . out . println ( findNumber ( n ) ) ; } }
class GFG { static final int modd = 1000000007 ; static long power ( long x , long y , long p ) { long res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static int ways ( int n , int m ) { return ( int ) ( power ( m - 1 , n - 1 , modd ) * m % modd ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; System . out . println ( ways ( n , m ) ) ; } }
class GFG { static void q1 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " Yes " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q2 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q2 ( s , i + 1 ) ; } static void q3 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " Yes " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } static void q4 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q4 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } static void q0 ( String s , int i ) { if ( i == s . length ( ) ) { System . out . println ( " No " ) ; return ; } if ( s . charAt ( i ) == ' a ' ) q1 ( s , i + 1 ) ; else q3 ( s , i + 1 ) ; } public static void main ( String [ ] args ) { String s = " abbaabb " ; q0 ( s , 0 ) ; } }
import java . io . * ; class GFG { static float heightCalculate ( int H , int n , int m ) { float N = ( float ) ( n * 1.0 ) ; float M = ( float ) ( m * 1.0 ) ; float h = H * ( float ) Math . sqrt ( N / ( N + M ) ) ; return h ; } public static void main ( String [ ] args ) { int H = 10 , n = 3 , m = 4 ; System . out . print ( heightCalculate ( H , n , m ) ) ; } }
import java . io . * ; class GFG { static int CountWays ( int n , boolean flag ) { if ( n == 0 ) return 1 ; int sum = 0 ; if ( flag == false && n > 1 ) sum = sum + CountWays ( n - 1 , false ) + CountWays ( n - 2 , true ) ; else sum = sum + CountWays ( n - 1 , false ) ; return sum ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( CountWays ( n , false ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void printVector ( Vector < Integer > v ) { System . out . println ( v . size ( ) ) ; for ( int i = 0 ; i < v . size ( ) ; i ++ ) System . out . print ( v . get ( i ) + " ▁ " ) ; System . out . println ( ) ; } static void findTwoGroup ( int n ) { int sum = n * ( n + 1 ) / 2 ; int group1Sum = sum / 2 ; Vector < Integer > group1 = new Vector < Integer > ( ) ; Vector < Integer > group2 = new Vector < Integer > ( ) ; for ( int i = n ; i > 0 ; i -- ) { if ( group1Sum - i >= 0 ) { group1 . add ( i ) ; group1Sum -= i ; } else { group2 . add ( i ) ; } } printVector ( group1 ) ; printVector ( group2 ) ; } public static void main ( String [ ] args ) { int n = 5 ; findTwoGroup ( n ) ; } }
class GFG { static void printNumbers ( int a [ ] , int n , int x ) { boolean flag = false ; for ( int i = 0 ; i < n ; i ++ ) { int num = a [ i ] ; int g = __gcd ( num , x ) ; while ( g != 1 ) { num /= g ; g = __gcd ( num , x ) ; } if ( num == 1 ) { flag = true ; System . out . print ( a [ i ] + " ▁ " ) ; } } if ( ! flag ) System . out . println ( " There ▁ are ▁ no ▁ such ▁ numbers " ) ; } static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int x = 60 ; int a [ ] = { 2 , 5 , 10 , 7 , 17 } ; int n = a . length ; printNumbers ( a , n , x ) ; } }
import java . util . * ; class GFG { static String maxNumber ( String str , int n ) { int [ ] freq = new int [ 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) == ' z ' ) freq [ 0 ] ++ ; else if ( str . charAt ( i ) == ' n ' ) freq [ 1 ] ++ ; } String num = " " ; for ( int i = 0 ; i < freq [ 1 ] ; i ++ ) num += '1' ; for ( int i = 0 ; i < freq [ 0 ] ; i ++ ) num += '0' ; return num ; } public static void main ( String [ ] args ) { String str = " roenenzooe " ; int n = str . length ( ) ; System . out . println ( maxNumber ( str , n ) ) ; } }
import java . io . * ; class Emirp { public static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } public static boolean isEmirp ( int n ) { if ( isPrime ( n ) == false ) return false ; int rev = 0 ; while ( n != 0 ) { int d = n % 10 ; rev = rev * 10 + d ; n /= 10 ; } return isPrime ( rev ) ; } public static void main ( String args [ ] ) throws IOException { int n = 13 ; if ( isEmirp ( n ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static int substrDeletion ( String str , int len ) { int count0 = 0 , count1 = 0 ; for ( int i = 0 ; i < len ; i ++ ) { if ( str . charAt ( i ) == '0' ) count0 ++ ; else count1 ++ ; } return Math . min ( count0 , count1 ) ; } public static void main ( String [ ] args ) { String str = "010" ; int len = str . length ( ) ; System . out . println ( substrDeletion ( str , len ) ) ; } }
import java . util . * ; class GFG { static boolean IsPossible ( String s ) { int n = s . length ( ) ; HashSet < Character > count = new HashSet < > ( ) ; HashMap < Character , Integer > map = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { count . add ( s . charAt ( i ) ) ; map . put ( s . charAt ( i ) , map . get ( s . charAt ( i ) ) == null ? 1 : map . get ( s . charAt ( i ) ) + 1 ) ; } if ( count . size ( ) == 1 ) return true ; if ( count . size ( ) > 2 ) return false ; String newString = count . toArray ( ) . toString ( ) ; int j = 0 ; char it = newString . charAt ( j ) ; int x = 0 , y = 0 ; x = map . get ( it ) == null ? 0 : map . get ( it ) ; j ++ ; it = newString . charAt ( j ) ; y = map . get ( it ) == null ? 0 : map . get ( it ) ; if ( Math . abs ( x - y ) <= 1 ) return true ; return false ; } public static void main ( String [ ] args ) { String s = " aaaddad " ; if ( IsPossible ( s ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static void radius ( double n , double d ) { System . out . print ( " The ▁ side ▁ of ▁ each ▁ square ▁ is ▁ " + d / ( ( n - 1 ) * Math . sqrt ( 2 ) ) ) ; } public static void main ( String [ ] args ) { double d = 42 , n = 4 ; radius ( n , d ) ; } }
import java . io . * ; class GFG { static void modularEquation ( int a , int b ) { if ( a < b ) { System . out . println ( " No ▁ solution ▁ possible ▁ " ) ; return ; } if ( a == b ) { System . out . println ( " Infinite ▁ Solution ▁ possible ▁ " ) ; return ; } int count = 0 ; int n = a - b ; int y = ( int ) Math . sqrt ( a - b ) ; for ( int i = 1 ; i <= y ; ++ i ) { if ( n % i == 0 ) { if ( n / i > b ) count ++ ; if ( i > b ) count ++ ; } } if ( y * y == n && y > b ) count -- ; System . out . println ( count ) ; } public static void main ( String [ ] args ) { int a = 21 , b = 5 ; modularEquation ( a , b ) ; } }
class GFG { static int reverseNum ( int x ) { String s = Integer . toString ( x ) ; String str = " " ; for ( int i = s . length ( ) - 1 ; i >= 0 ; i -- ) { str = str + s . charAt ( i ) ; } int rev = Integer . parseInt ( str ) ; return rev ; } static boolean isMysteryNumber ( int n ) { for ( int i = 1 ; i <= n / 2 ; i ++ ) { int j = reverseNum ( i ) ; if ( i + j == n ) { System . out . println ( i + " ▁ " + j ) ; return true ; } } System . out . println ( " Not ▁ a ▁ Mystery ▁ Number " ) ; return false ; } public static void main ( String [ ] args ) { int n = 121 ; isMysteryNumber ( n ) ; } }
class GFG { public static int solve ( int [ ] [ ] dp , int wt , int K , int M , int used ) { if ( wt < 0 ) { return 0 ; } if ( wt == 0 ) { if ( used == 1 ) { return 1 ; } return 0 ; } if ( dp [ wt ] [ used ] != - 1 ) { return dp [ wt ] [ used ] ; } int ans = 0 ; for ( int i = 1 ; i <= K ; i ++ ) { if ( i >= M ) { ans += solve ( dp , wt - i , K , M , used | 1 ) ; } else { ans += solve ( dp , wt - i , K , M , used ) ; } } return dp [ wt ] [ used ] = ans ; } public static void main ( String [ ] args ) { int W = 3 , K = 3 , M = 2 ; int [ ] [ ] dp = new int [ W + 1 ] [ 2 ] ; for ( int i = 0 ; i < W + 1 ; i ++ ) { for ( int j = 0 ; j < 2 ; j ++ ) { dp [ i ] [ j ] = - 1 ; } } System . out . print ( solve ( dp , W , K , M , 0 ) + " \n " ) ; } }
import java . util . Vector ; class Test { static void printDivisors ( int n ) { Vector < Integer > v = new Vector < > ( ) ; for ( int i = 1 ; i <= Math . sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) { if ( n / i == i ) System . out . printf ( " % d ▁ " , i ) ; else { System . out . printf ( " % d ▁ " , i ) ; v . add ( n / i ) ; } } } for ( int i = v . size ( ) - 1 ; i >= 0 ; i -- ) System . out . printf ( " % d ▁ " , v . get ( i ) ) ; } public static void main ( String args [ ] ) { System . out . println ( " The ▁ divisors ▁ of ▁ 100 ▁ are : ▁ " ) ; printDivisors ( 100 ) ; } }
import java . util . * ; class GFG { static boolean isSubSequence ( String str1 , String str2 ) { int m = str1 . length ( ) , n = str2 . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n && j < m ; i ++ ) { if ( str1 . charAt ( j ) == str2 . charAt ( i ) ) { j ++ ; } } return ( j == m ) ; } static String findLongestString ( Vector < String > dict , String str ) { String result = " " ; int length = 0 ; for ( String word : dict ) { if ( length < word . length ( ) && isSubSequence ( word , str ) ) { result = word ; length = word . length ( ) ; } } return result ; } public static void main ( String [ ] args ) { String [ ] arr = { " ale " , " apple " , " monkey " , " plea " } ; Vector dict = new Vector ( Arrays . asList ( arr ) ) ; String str = " abpcplea " ; System . out . println ( findLongestString ( dict , str ) ) ; } }
import java . util . Arrays ; import java . lang . Math ; class GFG { public static int lenoflongestnonpalindrome ( String s ) { int max1 = 1 , len = 0 ; char [ ] new_str = s . toCharArray ( ) ; for ( int i = 0 ; i < new_str . length - 1 ; i ++ ) { if ( new_str [ i ] == new_str [ i + 1 ] ) len = 0 ; else if ( i > 0 && ( new_str [ i + 1 ] == new_str [ i - 1 ] ) ) len = 1 ; else len ++ ; max1 = Math . max ( max1 , len + 1 ) ; } if ( max1 == 1 ) return 0 ; else return max1 ; } public static void main ( String [ ] args ) { String s = " synapse " ; System . out . println ( lenoflongestnonpalindrome ( s ) ) ; } }
class GFG { static char MAX_CHAR = 26 ; static void countFreq ( String str , int freq [ ] , int len ) { for ( int i = 0 ; i < len ; i ++ ) { freq [ str . charAt ( i ) - ' a ' ] ++ ; } } static boolean canMakePalindrome ( int freq [ ] , int len ) { int count_odd = 0 ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { count_odd ++ ; } } if ( len % 2 == 0 ) { if ( count_odd > 0 ) { return false ; } else { return true ; } } if ( count_odd != 1 ) { return false ; } return true ; } static String findOddAndRemoveItsFreq ( int freq [ ] ) { String odd_str = " " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { if ( freq [ i ] % 2 != 0 ) { freq [ i ] -- ; odd_str = odd_str + ( char ) ( i + ' a ' ) ; return odd_str ; } } return odd_str ; } static String findPalindromicString ( String str ) { int len = str . length ( ) ; int freq [ ] = new int [ MAX_CHAR ] ; countFreq ( str , freq , len ) ; if ( ! canMakePalindrome ( freq , len ) ) { return " No ▁ Palindromic ▁ String " ; } String odd_str = findOddAndRemoveItsFreq ( freq ) ; String front_str = " " , rear_str = " ▁ " ; for ( int i = 0 ; i < MAX_CHAR ; i ++ ) { String temp = " " ; if ( freq [ i ] != 0 ) { char ch = ( char ) ( i + ' a ' ) ; for ( int j = 1 ; j <= freq [ i ] / 2 ; j ++ ) { temp = temp + ch ; } front_str = front_str + temp ; rear_str = temp + rear_str ; } } return ( front_str + odd_str + rear_str ) ; } public static void main ( String [ ] args ) { String str = " malayalam " ; System . out . println ( findPalindromicString ( str ) ) ; } }
import java . util . * ; class GFG { static void twistedTOH ( int n , char first , char middle , char last ) { if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + first + " ▁ to ▁ " + middle + " ▁ and ▁ then ▁ to ▁ " + last ) ; return ; } twistedTOH ( n - 1 , first , middle , last ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + first + " ▁ to ▁ " + middle ) ; twistedTOH ( n - 1 , last , middle , first ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + middle + " ▁ to ▁ " + last ) ; twistedTOH ( n - 1 , first , middle , last ) ; } public static void main ( String [ ] args ) { int n = 2 ; twistedTOH ( n , ' A ' , ' B ' , ' C ' ) ; } }
class GFG { static int countSetBits ( int n ) { int bitCount = 0 ; for ( int i = 1 ; i <= n ; i ++ ) bitCount += countSetBitsUtil ( i ) ; return bitCount ; } static int countSetBitsUtil ( int x ) { if ( x <= 0 ) return 0 ; return ( x % 2 == 0 ? 0 : 1 ) + countSetBitsUtil ( x / 2 ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . print ( " Total ▁ set ▁ bit ▁ count ▁ is ▁ " ) ; System . out . print ( countSetBits ( n ) ) ; } }
import java . io . * ; class GFG { static int bit ( int x ) { int ans = 0 ; while ( x > 0 ) { x /= 2 ; ans ++ ; } return ans ; } static boolean check ( int d , int x ) { if ( bit ( x / d ) <= bit ( d ) ) return true ; return false ; } static int bs ( int n ) { int l = 1 , r = ( int ) Math . sqrt ( n ) ; while ( l < r ) { int m = ( l + r ) / 2 ; if ( check ( m , n ) ) r = m ; else l = m + 1 ; } if ( ! check ( l , n ) ) return l + 1 ; else return l ; } static int countDivisor ( int n ) { return n - bs ( n ) + 1 ; } static public void main ( String [ ] args ) { int n = 5 ; System . out . println ( countDivisor ( n ) ) ; } }
import java . io . * ; class GFG { static boolean isPresent ( int B [ ] , int m , int x ) { for ( int i = 0 ; i < m ; i ++ ) if ( B [ i ] == x ) return true ; return false ; } static int findMaxSubarraySumUtil ( int A [ ] , int B [ ] , int n , int m ) { int max_so_far = - 2147483648 , curr_max = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( isPresent ( B , m , A [ i ] ) ) { curr_max = 0 ; continue ; } curr_max = Math . max ( A [ i ] , curr_max + A [ i ] ) ; max_so_far = Math . max ( max_so_far , curr_max ) ; } return max_so_far ; } static void findMaxSubarraySum ( int A [ ] , int B [ ] , int n , int m ) { int maxSubarraySum = findMaxSubarraySumUtil ( A , B , n , m ) ; if ( maxSubarraySum == - 2147483648 ) { System . out . println ( " Maximum ▁ Subarray ▁ Sum " + " ▁ " + " can ' t ▁ be ▁ found " ) ; } else { System . out . println ( " The ▁ Maximum ▁ Subarray ▁ Sum ▁ = ▁ " + maxSubarraySum ) ; } } public static void main ( String [ ] args ) { int A [ ] = { 3 , 4 , 5 , - 4 , 6 } ; int B [ ] = { 1 , 8 , 5 } ; int n = A . length ; int m = B . length ; findMaxSubarraySum ( A , B , n , m ) ; } }
class GFG { static void findArea ( float a , float b ) { float Area ; Area = ( float ) 3.142 * a * b ; System . out . println ( " Area : ▁ " + Area ) ; } public static void main ( String [ ] args ) { float a = 5 , b = 4 ; findArea ( a , b ) ; } }
class GFG { static void perfectSquares ( float l , float r ) { int number = ( int ) Math . ceil ( Math . sqrt ( l ) ) ; int n2 = number * number ; number = ( number * 2 ) + 1 ; while ( ( n2 >= l && n2 <= r ) ) { System . out . print ( n2 + " ▁ " ) ; n2 = n2 + number ; number += 2 ; } } public static void main ( String [ ] args ) { int l = 2 , r = 24 ; perfectSquares ( l , r ) ; } }
import java . io . * ; class GFG { static void printPermutation ( int n , int k ) { int i , mx = n ; for ( i = 1 ; i <= k ; i ++ ) { System . out . print ( mx + " ▁ " ) ; mx -- ; } for ( i = 1 ; i <= mx ; i ++ ) System . out . print ( i + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 5 , K = 3 ; if ( K >= N - 1 ) System . out . print ( " Not ▁ Possible " ) ; else printPermutation ( N , K ) ; } }
import java . io . * ; class GFG { public static int countSetBits ( int n ) { if ( n == 0 ) return 0 ; else return 1 + countSetBits ( n & ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 9 ; System . out . println ( countSetBits ( n ) ) ; } }
public class GFG { static void manipulateString ( String str ) { char [ ] str1 = str . toCharArray ( ) ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { int asc = str1 [ i ] ; int rem = asc - ( 26 - ( str1 [ i ] - 97 ) ) ; int m = rem % 26 ; str1 [ i ] = ( char ) ( m + ' a ' ) ; } String str2 = String . valueOf ( str1 ) ; System . out . println ( str2 ) ; } public static void main ( String [ ] args ) { String str = " geeksforgeeks " ; manipulateString ( str ) ; } }
class GFG { static boolean arraySortedOrNot ( int arr [ ] , int n ) { if ( n == 0 || n == 1 ) return true ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i - 1 ] > arr [ i ] ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 20 , 23 , 23 , 45 , 78 , 88 } ; int n = arr . length ; if ( arraySortedOrNot ( arr , n ) ) System . out . print ( " Yes \n " ) ; else System . out . print ( " No \n " ) ; } }
class GFG { static void cumm ( int [ ] x , int [ ] y , int [ ] cummx , int [ ] cummy , int [ ] cummx2 , int [ ] cummy2 , int n ) { for ( int i = 1 ; i <= n ; i ++ ) { cummx [ i ] = cummx [ i - 1 ] + x [ i ] ; cummy [ i ] = cummy [ i - 1 ] + y [ i ] ; cummx2 [ i ] = cummx2 [ i - 1 ] + x [ i ] * x [ i ] ; cummy2 [ i ] = cummy2 [ i - 1 ] + y [ i ] * y [ i ] ; } } static int calHammeredDistance ( int n , int [ ] x , int [ ] y ) { int [ ] cummx = new int [ n + 1 ] ; int [ ] cummy = new int [ n + 1 ] ; int [ ] cummx2 = new int [ n + 1 ] ; int [ ] cummy2 = new int [ n + 1 ] ; cumm ( x , y , cummx , cummy , cummx2 , cummy2 , n ) ; int hdx = 0 , hdy = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { hdx += ( i - 1 ) * x [ i ] * x [ i ] + cummx2 [ i - 1 ] - 2 * x [ i ] * cummx [ i - 1 ] ; hdy += ( i - 1 ) * y [ i ] * y [ i ] + cummy2 [ i - 1 ] - 2 * y [ i ] * cummy [ i - 1 ] ; } int total = hdx + hdy ; return total ; } public static void main ( String [ ] args ) { int n = 3 ; int [ ] x = new int [ n + 1 ] ; int [ ] y = new int [ n + 1 ] ; x [ 2 ] = 1 ; y [ 0 ] = 1 ; System . out . print ( calHammeredDistance ( n , x , y ) ) ; } }
import java . util . Vector ; class GFG { static Vector < Integer > solve ( int v [ ] ) { Vector < Integer > res = new Vector < Integer > ( ) ; int all3 = v [ 0 ] + v [ 1 ] + v [ 2 ] ; res . add ( all3 - v [ 1 ] * 2 ) ; res . add ( all3 - v [ 2 ] * 2 ) ; res . add ( all3 - v [ 0 ] * 2 ) ; return res ; } static void findVertex ( int xmid [ ] , int ymid [ ] ) { Vector < Integer > V1 = solve ( xmid ) ; Vector < Integer > V2 = solve ( ymid ) ; for ( int i = 0 ; i < 3 ; i ++ ) { System . out . println ( V1 . get ( i ) + " ▁ " + V2 . get ( i ) ) ; } } public static void main ( String [ ] args ) { int xmid [ ] = { 5 , 4 , 5 } ; int ymid [ ] = { 3 , 4 , 5 } ; findVertex ( xmid , ymid ) ; } }
import java . util . * ; class GFG { static int countSubString ( char [ ] S , char L [ ] , int n ) { int [ ] freq = new int [ 26 ] ; int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { freq [ ( int ) ( L [ i ] - ' a ' ) ] = 1 ; } int count = 0 ; for ( int x : S ) { if ( freq [ ( int ) ( x - ' a ' ) ] > 0 ) { ans += ( count * count + count ) / 2 ; count = 0 ; } else count ++ ; } ans += ( count * count + count ) / 2 ; return ans ; } public static void main ( String [ ] args ) { String S = " abcpxyz " ; char L [ ] = { ' a ' , ' p ' , ' q ' } ; int n = L . length ; System . out . print ( countSubString ( S . toCharArray ( ) , L , n ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int solve ( int low , int high , int T ) { while ( low <= high ) { int mid = ( low + high ) / 2 ; if ( ( mid * ( mid + 1 ) ) == T ) return mid ; if ( mid > 0 && ( mid * ( mid + 1 ) ) > T && ( mid * ( mid - 1 ) ) <= T ) return mid - 1 ; if ( ( mid * ( mid + 1 ) ) > T ) high = mid - 1 ; else low = mid + 1 ; } return - 1 ; } public static void main ( String argc [ ] ) { int T = 15 ; int ans = solve ( 1 , T , 2 * T ) ; if ( ans != - 1 ) ans -- ; System . out . println ( " Number ▁ of ▁ stair ▁ steps ▁ = ▁ " + ans ) ; } }
import java . io . * ; class GFG { static int findMaxAverage ( int arr [ ] , int n , int k ) { if ( k > n ) return - 1 ; int sum = arr [ 0 ] ; for ( int i = 1 ; i < k ; i ++ ) sum += arr [ i ] ; int max_sum = sum , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { sum = sum + arr [ i ] - arr [ i - k ] ; if ( sum > max_sum ) { max_sum = sum ; max_end = i ; } } return max_end - k + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ average " + " ▁ subarray ▁ of ▁ length ▁ " + k + " ▁ begins ▁ at ▁ index ▁ " + findMaxAverage ( arr , n , k ) ) ; } }
public class GFG { public static float circlearea ( double a , double b ) { if ( a < 0 || b < 0 ) return - 1 ; float A = ( float ) ( ( 3.14 * Math . pow ( a , 2 ) * Math . pow ( b , 2 ) ) / ( 4 * ( Math . pow ( a , 2 ) + Math . pow ( b , 2 ) ) ) ) ; return A ; } public static void main ( String [ ] args ) { float a = 8 , b = 10 ; System . out . println ( circlearea ( a , b ) ) ; } }
class GFG { public static int countDyckPaths ( int n ) { int res = 1 ; for ( int i = 0 ; i < n ; ++ i ) { res *= ( 2 * n - i ) ; res /= ( i + 1 ) ; } return res / ( n + 1 ) ; } public static void main ( String args [ ] ) { int n = 4 ; System . out . println ( " Number ▁ of ▁ Dyck ▁ Paths ▁ is ▁ " + countDyckPaths ( n ) ) ; } }
class GFG { static String multiply ( String num1 , String num2 ) { int len1 = num1 . length ( ) ; int len2 = num2 . length ( ) ; if ( len1 == 0 || len2 == 0 ) return "0" ; int result [ ] = new int [ len1 + len2 ] ; int i_n1 = 0 ; int i_n2 = 0 ; for ( int i = len1 - 1 ; i >= 0 ; i -- ) { int carry = 0 ; int n1 = num1 . charAt ( i ) - '0' ; i_n2 = 0 ; for ( int j = len2 - 1 ; j >= 0 ; j -- ) { int n2 = num2 . charAt ( j ) - '0' ; int sum = n1 * n2 + result [ i_n1 + i_n2 ] + carry ; carry = sum / 10 ; result [ i_n1 + i_n2 ] = sum % 10 ; i_n2 ++ ; } if ( carry > 0 ) result [ i_n1 + i_n2 ] += carry ; i_n1 ++ ; } int i = result . length - 1 ; while ( i >= 0 && result [ i ] == 0 ) i -- ; if ( i == - 1 ) return "0" ; String s = " " ; while ( i >= 0 ) s += ( result [ i -- ] ) ; return s ; } public static void main ( String [ ] args ) { String str1 = "1235421415454545454545454544" ; String str2 = "1714546546546545454544548544544545" ; if ( ( str1 . charAt ( 0 ) == ' - ' || str2 . charAt ( 0 ) == ' - ' ) && ( str1 . charAt ( 0 ) != ' - ' || str2 . charAt ( 0 ) != ' - ' ) ) System . out . print ( " - " ) ; if ( str1 . charAt ( 0 ) == ' - ' && str2 . charAt ( 0 ) != ' - ' ) { str1 = str1 . substring ( 1 ) ; } else if ( str1 . charAt ( 0 ) != ' - ' && str2 . charAt ( 0 ) == ' - ' ) { str2 = str2 . substring ( 1 ) ; } else if ( str1 . charAt ( 0 ) == ' - ' && str2 . charAt ( 0 ) == ' - ' ) { str1 = str1 . substring ( 1 ) ; str2 = str2 . substring ( 1 ) ; } System . out . println ( multiply ( str1 , str2 ) ) ; } }
class CountMultiples { static int ans [ ] ; static void countSieve ( int arr [ ] , int n ) { int MAX = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) MAX = Math . max ( arr [ i ] , MAX ) ; int cnt [ ] = new int [ MAX + 1 ] ; ans = new int [ MAX + 1 ] ; for ( int i = 0 ; i < n ; ++ i ) ++ cnt [ arr [ i ] ] ; for ( int i = 1 ; i <= MAX ; ++ i ) for ( int j = i ; j <= MAX ; j += i ) ans [ i ] += cnt [ j ] ; return ; } static int countMultiples ( int k ) { return ans [ k ] ; } public static void main ( String args [ ] ) { int arr [ ] = { 2 , 4 , 9 , 15 , 21 , 20 } ; int n = 6 ; countSieve ( arr , n ) ; int k = 2 ; System . out . println ( countMultiples ( k ) ) ; k = 3 ; System . out . println ( countMultiples ( k ) ) ; k = 5 ; System . out . println ( countMultiples ( k ) ) ; } }
import java . io . * ; class GFG { static int number_of_teams ( int M ) { int N1 , N2 , sqr ; sqr = ( int ) Math . sqrt ( 1 + ( 8 * M ) ) ; N1 = ( 1 + sqr ) / 2 ; N2 = ( 1 - sqr ) / 2 ; if ( N1 > 0 ) return N1 ; return N2 ; } public static void main ( String [ ] args ) { int M = 45 ; System . out . println ( number_of_teams ( M ) ) ; } }
import java . io . * ; class GFG { private static int _popcnt32 ( long number ) { int counter = 0 ; while ( number > 0 ) { if ( number % 2 == 1 ) { counter ++ ; } number = number / 2 ; } return counter ; } static long maximize ( long a ) { int n = _popcnt32 ( a ) ; long res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) res = ( int ) res | ( 1 << ( 32 - i ) ) ; return Math . abs ( res ) ; } public static void main ( String args [ ] ) { long a = 1 ; System . out . print ( maximize ( a ) ) ; } }
import java . io . * ; class GFG { static int series ( int n ) { return ( 8 * n * n ) + 1 ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( series ( n ) ) ; } }
import java . util . Collections ; import java . util . Vector ; class GFG { static void sortMultiples ( int arr [ ] , int n , int x ) { Vector < Integer > v = new Vector < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) { v . add ( arr [ i ] ) ; } } Collections . sort ( v ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % x == 0 ) { arr [ i ] = v . get ( j ++ ) ; } } } public static void main ( String [ ] args ) { int arr [ ] = { 125 , 3 , 15 , 6 , 100 , 5 } ; int x = 5 ; int n = arr . length ; sortMultiples ( arr , n , x ) ; for ( int i = 0 ; i < n ; i ++ ) { System . out . print ( arr [ i ] + " ▁ " ) ; } } }
import java . io . * ; class GFG { static int power [ ] = new int [ 31 ] ; static int pre [ ] = new int [ 31 ] ; static void PowerOfTwo ( ) { int x = 1 ; for ( int i = 0 ; i < 31 ; i ++ ) { power [ i ] = x ; x *= 2 ; } pre [ 0 ] = 1 ; for ( int i = 1 ; i < 31 ; i ++ ) pre [ i ] = pre [ i - 1 ] + power [ i ] ; } static int Sum ( int n ) { int ans = n * ( n + 1 ) / 2 ; for ( int i = 0 ; i < 31 ; i ++ ) { if ( power [ i ] > n ) { ans -= 2 * pre [ i - 1 ] ; break ; } } return ans ; } public static void main ( String [ ] args ) { PowerOfTwo ( ) ; int n = 4 ; System . out . println ( Sum ( n ) ) ; } }
import java . io . * ; class GFG { static boolean DivisibleBy41 ( int first , int second , int c , int n ) { int digit [ ] = new int [ n ] ; digit [ 0 ] = first ; digit [ 1 ] = second ; for ( int i = 2 ; i < n ; i ++ ) digit [ i ] = ( digit [ i - 1 ] * c + digit [ i - 2 ] ) % 10 ; int ans = digit [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) ans = ( ans * 10 + digit [ i ] ) % 41 ; if ( ans % 41 == 0 ) return true ; else return false ; } public static void main ( String [ ] args ) { int first = 1 , second = 2 , c = 1 , n = 3 ; if ( DivisibleBy41 ( first , second , c , n ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
class GFG { static long mod = 1000000007L ; static long mult ( long a , long b ) { return ( ( a % mod ) * ( b % mod ) ) % mod ; } static long calculate_factors ( long n ) { long ans , cnt ; cnt = 0 ; ans = 1 ; while ( n % 2 == 0 ) { cnt ++ ; n = n / 2 ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { cnt = 0 ; while ( n % i == 0 ) { cnt ++ ; n = n / i ; } if ( cnt % 2 == 1 ) { ans = mult ( ans , ( cnt + 1 ) ) ; } } if ( n > 2 ) { ans = mult ( ans , ( 2 ) ) ; } return ans % mod ; } public static void main ( String [ ] args ) { long n = 193748576239475639L ; mod = 17 ; System . out . print ( calculate_factors ( n ) + " \n " ) ; } }
class GFG { static int MAX = 100 ; static void binomialCoeff ( int n , int C [ ] ) { C [ 0 ] = 1 ; for ( int i = 1 ; i <= n ; i ++ ) { for ( int j = Math . min ( i , n ) ; j > 0 ; j -- ) C [ j ] = C [ j ] + C [ j - 1 ] ; } } static int summation ( int n ) { int C [ ] = new int [ MAX ] ; for ( int i = 0 ; i < MAX ; i ++ ) C [ i ] = 0 ; binomialCoeff ( n , C ) ; int sum = 0 ; for ( int i = 0 ; i <= n ; i ++ ) sum += ( i * C [ i ] ) ; return sum ; } public static void main ( String args [ ] ) { int n = 2 ; System . out . println ( summation ( n ) ) ; } }
class GFG { static boolean digitWell ( int n , int m , int k ) { int cnt = 0 ; while ( n > 0 ) { if ( n % 10 == m ) ++ cnt ; n /= 10 ; } return cnt == k ; } static int findInt ( int n , int m , int k ) { int i = n + 1 ; while ( true ) { if ( digitWell ( i , m , k ) ) return i ; i ++ ; } } public static void main ( String [ ] args ) { int n = 111 , m = 2 , k = 2 ; System . out . println ( findInt ( n , m , k ) ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; } static void printList ( Node node ) { while ( node != null ) { System . out . print ( node . data + " ▁ " ) ; node = node . next ; } System . out . println ( ) ; } static Node newNode ( int key ) { Node temp = new Node ( ) ; temp . data = key ; temp . next = null ; return temp ; } static Node insertBeg ( Node head , int val ) { Node temp = newNode ( val ) ; temp . next = head ; head = temp ; return head ; } static void rearrangeOddEven ( Node head ) { Stack < Node > odd = new Stack < Node > ( ) ; Stack < Node > even = new Stack < Node > ( ) ; int i = 1 ; while ( head != null ) { if ( head . data % 2 != 0 && i % 2 == 0 ) { odd . push ( head ) ; } else if ( head . data % 2 == 0 && i % 2 != 0 ) { even . push ( head ) ; } head = head . next ; i ++ ; } while ( odd . size ( ) > 0 && even . size ( ) > 0 ) { int k = odd . peek ( ) . data ; odd . peek ( ) . data = even . peek ( ) . data ; even . peek ( ) . data = k ; odd . pop ( ) ; even . pop ( ) ; } } public static void main ( String args [ ] ) { Node head = newNode ( 8 ) ; head = insertBeg ( head , 7 ) ; head = insertBeg ( head , 6 ) ; head = insertBeg ( head , 5 ) ; head = insertBeg ( head , 3 ) ; head = insertBeg ( head , 2 ) ; head = insertBeg ( head , 1 ) ; System . out . println ( " Linked ▁ List : " ) ; printList ( head ) ; rearrangeOddEven ( head ) ; System . out . println ( " Linked ▁ List ▁ after ▁ " + " Rearranging : " ) ; printList ( head ) ; } }
import java . lang . * ; import java . io . * ; class GFG { public static void digit_product_Sum ( int N ) { int a [ ] = new int [ N + 1 ] ; int product = 1 ; a [ 0 ] = 1 ; for ( int i = 1 ; i <= N ; i ++ ) { product = a [ i - 1 ] / 10 ; if ( product == 0 ) product = 1 ; else product = a [ i - 1 ] % 10 ; int val = a [ i - 1 ] / 10 ; if ( val == 0 ) val = a [ i - 1 ] ; a [ i ] = a [ i - 1 ] + ( val * product ) ; } for ( int i = 0 ; i < N ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String [ ] args ) { int N = 10 ; digit_product_Sum ( N ) ; } }
public class GFG { static int SquareCube ( long N ) { int cnt = 0 , i = 1 ; while ( ( int ) ( Math . pow ( i , 6 ) ) <= N ) { ++ cnt ; ++ i ; } return cnt ; } public static void main ( String [ ] args ) { long N = 100000 ; System . out . println ( SquareCube ( N ) ) ; } }
import java . util . * ; class GFG { static void createHash ( HashSet < Integer > hash , int maxElement ) { int prev = 0 , curr = 1 ; hash . add ( prev ) ; hash . add ( curr ) ; while ( curr < maxElement ) { int temp = curr + prev ; hash . add ( temp ) ; prev = curr ; curr = temp ; } } static void findFibonacciPair ( int n ) { HashSet < Integer > hash = new HashSet < Integer > ( ) ; createHash ( hash , n ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( hash . contains ( i ) && hash . contains ( n - i ) ) { System . out . print ( i + " , ▁ " + ( n - i ) + " \n " ) ; return ; } } System . out . print ( " - 1 \n " ) ; } public static void main ( String [ ] args ) { int N = 90 ; findFibonacciPair ( N ) ; } }
import java . util . * ; class GFG { static int Max_Sum ( int a [ ] , int n ) { int [ ] b = new int [ n ] ; int S = 0 ; int res = 0 ; for ( int i = 0 ; i < n ; i ++ ) { b [ i ] = res ; res += a [ i ] ; S += a [ i ] ; res = Math . max ( res , - S ) ; } int ans = S ; ans = Math . max ( ans , res ) ; int g = 0 ; for ( int i = n - 1 ; i >= 0 ; -- i ) { g -= a [ i ] ; ans = Math . max ( ans , g + b [ i ] ) ; } return ans ; } public static void main ( String [ ] args ) { int a [ ] = { - 6 , 10 , - 3 , 10 , - 2 } ; int n = a . length ; System . out . println ( " Maximum ▁ sum ▁ is : ▁ " + Max_Sum ( a , n ) ) ; } }
import java . util . * ; class GFG { static int MAX = 100 ; static void permutatedRows ( int mat [ ] [ ] , int m , int n , int r ) { LinkedHashSet < Integer > s = new LinkedHashSet < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) s . add ( mat [ r ] [ j ] ) ; for ( int i = 0 ; i < m ; i ++ ) { if ( i == r ) continue ; int j ; for ( j = 0 ; j < n ; j ++ ) if ( ! s . contains ( mat [ i ] [ j ] ) ) break ; if ( j != n ) continue ; System . out . print ( i + " , ▁ " ) ; } } public static void main ( String [ ] args ) { int m = 4 , n = 4 , r = 3 ; int mat [ ] [ ] = { { 3 , 1 , 4 , 2 } , { 1 , 6 , 9 , 3 } , { 1 , 2 , 3 , 4 } , { 4 , 3 , 2 , 1 } } ; permutatedRows ( mat , m , n , r ) ; } }
import java . util . Arrays ; import java . util . Comparator ; class Interval { int start , end ; Interval ( int start , int end ) { this . start = start ; this . end = end ; } } public class MergeOverlappingIntervals { public static void mergeIntervals ( Interval arr [ ] ) { Arrays . sort ( arr , new Comparator < Interval > ( ) { public int compare ( Interval i1 , Interval i2 ) { return i2 . start - i1 . start ; } } ) ; int index = 0 ; for ( int i = 1 ; i < arr . length ; i ++ ) { if ( arr [ index ] . end >= arr [ i ] . start ) { arr [ index ] . end = Math . max ( arr [ index ] . end , arr [ i ] . end ) ; arr [ index ] . start = Math . min ( arr [ index ] . start , arr [ i ] . start ) ; } else { arr [ index ] = arr [ i ] ; index ++ ; } } System . out . print ( " The ▁ Merged ▁ Intervals ▁ are : ▁ " ) ; for ( int i = 0 ; i <= index ; i ++ ) { System . out . print ( " [ " + arr [ i ] . start + " , " + arr [ i ] . end + " ] " ) ; } } public static void main ( String args [ ] ) { Interval arr [ ] = new Interval [ 4 ] ; arr [ 0 ] = new Interval ( 6 , 8 ) ; arr [ 1 ] = new Interval ( 1 , 9 ) ; arr [ 2 ] = new Interval ( 2 , 4 ) ; arr [ 3 ] = new Interval ( 4 , 7 ) ; mergeIntervals ( arr ) ; } }
import java . io . * ; class GFG { static int MAX = 1000000 ; static boolean prime [ ] = new boolean [ MAX + 1 ] ; static void SieveOfEratosthenes ( ) { for ( int i = 0 ; i < MAX + 1 ; i ++ ) prime [ i ] = true ; prime [ 1 ] = false ; for ( int p = 2 ; p * p <= MAX ; p ++ ) { if ( prime [ p ] == true ) { for ( int i = p * 2 ; i <= MAX ; i += p ) prime [ i ] = false ; } } } static int findDiff ( int arr [ ] , int n ) { int min = MAX + 2 , max = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime [ arr [ i ] ] == true ) { if ( arr [ i ] > max ) max = arr [ i ] ; if ( arr [ i ] < min ) min = arr [ i ] ; } } return ( max == - 1 ) ? - 1 : ( max - min ) ; } public static void main ( String [ ] args ) { SieveOfEratosthenes ( ) ; int n = 4 ; int arr [ ] = { 1 , 2 , 3 , 5 } ; int res = findDiff ( arr , n ) ; if ( res == - 1 ) System . out . print ( " No ▁ prime ▁ numbers " ) ; else System . out . println ( " Difference ▁ is ▁ " + res ) ; } }
class GFG { static float find_Area ( float a ) { float R = a * ( float ) ( 2.0 - Math . sqrt ( 2 ) ) ; float area = ( float ) ( ( 3.14 * R * R ) / 2.0 ) ; return area ; } public static void main ( String [ ] args ) { float a = 4 ; System . out . println ( " ▁ Area ▁ of ▁ semicircle ▁ = ▁ " + find_Area ( a ) ) ; } }
class GFG { static long discard_count = 0 ; static long power ( long a , long n ) { if ( n == 0 ) return 1 ; long p = power ( a , n / 2 ) ; p = p * p ; if ( n % 2 == 1 ) p = p * a ; return p ; } static void solve ( int i , int n , float sum , float k , float [ ] a , float [ ] prefix ) { if ( sum > k ) { discard_count += power ( 2 , n - i ) ; return ; } if ( i == n ) return ; float rem = prefix [ n - 1 ] - prefix [ i ] ; if ( sum + a [ i ] + rem > k ) solve ( i + 1 , n , sum + a [ i ] , k , a , prefix ) ; if ( sum + rem > k ) solve ( i + 1 , n , sum , k , a , prefix ) ; } static int countSubsequences ( int [ ] arr , int n , long K ) { float sum = 0.0f ; float k = ( float ) Math . log ( K ) ; float [ ] prefix = new float [ n ] ; float [ ] a = new float [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { a [ i ] = ( float ) Math . log ( arr [ i ] ) ; sum += a [ i ] ; } prefix [ 0 ] = a [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { prefix [ i ] = prefix [ i - 1 ] + a [ i ] ; } long total = power ( 2 , n ) - 1 ; if ( sum <= k ) { return ( int ) total ; } solve ( 0 , n , 0.0f , k , a , prefix ) ; return ( int ) ( total - discard_count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 8 , 7 , 2 } ; int n = arr . length ; long k = 50 ; System . out . print ( countSubsequences ( arr , n , k ) ) ; } }
class GFG { static String tribWord ( int n ) { String Sn_1 = "1" ; String Sn_2 = "12" ; String Sn_3 = "1213" ; String tmp ; for ( int i = 3 ; i <= n ; i ++ ) { tmp = Sn_3 ; Sn_3 += ( Sn_2 + Sn_1 ) ; Sn_1 = Sn_2 ; Sn_2 = tmp ; } return Sn_3 ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . print ( tribWord ( n ) ) ; } }
import java . io . * ; public class Interchange { static void interchangeFirstLast ( int m [ ] [ ] ) { int rows = m . length ; for ( int i = 0 ; i < m [ 0 ] . length ; i ++ ) { int t = m [ 0 ] [ i ] ; m [ 0 ] [ i ] = m [ rows - 1 ] [ i ] ; m [ rows - 1 ] [ i ] = t ; } } public static void main ( String args [ ] ) throws IOException { int m [ ] [ ] = { { 8 , 9 , 7 , 6 } , { 4 , 7 , 6 , 5 } , { 3 , 2 , 1 , 8 } , { 9 , 9 , 7 , 7 } } ; interchangeFirstLast ( m ) ; for ( int i = 0 ; i < m . length ; i ++ ) { for ( int j = 0 ; j < m [ 0 ] . length ; j ++ ) System . out . print ( m [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } }
import java . util . * ; class GFG { static int minimumValue ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; int answer = 0 ; for ( int i = 0 ; i < k ; i ++ ) answer += arr [ i ] * arr [ i ] ; return answer * ( 2 * k - 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 21 , 5 , 3 , 8 } , k = 3 ; int n = arr . length ; System . out . print ( minimumValue ( arr , n , k ) ) ; } }
import java . util . * ; import java . lang . * ; import java . io . * ; class GFG { static float findRadiusOfcircumcircle ( float l , float b ) { if ( l < 0 || b < 0 ) return - 1 ; float radius = ( float ) Math . sqrt ( Math . pow ( l , 2 ) + Math . pow ( b , 2 ) ) / 2 ; return radius ; } public static void main ( String args [ ] ) { float l = 4 , b = 3 ; System . out . println ( findRadiusOfcircumcircle ( l , b ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int findValue ( int x , int y , int z ) { int g = __gcd ( y , z ) ; return ( x * g ) / __gcd ( x , g ) ; } public static void main ( String [ ] args ) { int x = 30 , y = 40 , z = 400 ; System . out . print ( findValue ( x , y , z ) ) ; } }
import java . io . * ; class GFG { static float area ( float r ) { if ( r < 0 ) return - 1 ; float area = ( float ) ( 3.14 * Math . pow ( r / ( 2 * Math . sqrt ( 2 ) ) , 2 ) ) ; return area ; } public static void main ( String [ ] args ) { float a = 5 ; System . out . println ( area ( a ) ) ; } }
import java . util . Arrays ; class GFG { static int calculate_min_sum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int min_sum = 0 ; for ( int i = 1 ; i < n ; i += 2 ) { min_sum += Math . abs ( a [ i ] - a [ i - 1 ] ) ; } return min_sum ; } static int calculate_max_sum ( int [ ] a , int n ) { Arrays . sort ( a ) ; int max_sum = 0 ; for ( int i = 0 ; i < n / 2 ; i ++ ) { max_sum += Math . abs ( a [ n - 1 - i ] - a [ i ] ) ; } return max_sum ; } public static void main ( String [ ] args ) { int [ ] a = { 10 , - 10 , 20 , - 40 } ; int n = a . length ; System . out . println ( " The ▁ minimum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + calculate_min_sum ( a , n ) ) ; System . out . println ( " The ▁ maximum ▁ sum ▁ of ▁ pairs ▁ is ▁ " + calculate_max_sum ( a , n ) ) ; } }
import java . io . * ; class GFG { static int sumOfDigits ( int n ) { int res = 0 ; while ( n > 0 ) { res += n % 10 ; n /= 10 ; } return res ; } static int findNumber ( int n ) { int i = n - 1 ; while ( i > 0 ) { if ( sumOfDigits ( i ) > sumOfDigits ( n ) ) return i ; i -- ; } return - 1 ; } public static void main ( String [ ] args ) { int n = 824 ; System . out . println ( findNumber ( n ) ) ; } }
public class GFG { public static int getMaxLength ( int arr [ ] ) { int l = arr . length ; int i = 0 , maxlen = 0 ; while ( i < l ) { int j = i ; while ( i + 1 < l && ( Math . abs ( arr [ i ] - arr [ i + 1 ] ) == 1 || Math . abs ( arr [ i ] - arr [ i + 1 ] ) == 0 ) ) { i ++ ; } int currLen = i - j + 1 ; if ( maxlen < currLen ) maxlen = currLen ; if ( j == i ) i ++ ; } maxlen = ( maxlen == 1 ) ? 0 : maxlen ; return maxlen ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 } ; System . out . print ( getMaxLength ( arr ) ) ; } }
import java . util . * ; public class BinaryTree { Node root ; static class Node { int val ; Node left , right ; Node ( int v ) { val = v ; left = null ; right = null ; } } BinaryTree ( Node r ) { root = r ; } BinaryTree ( ) { } public boolean isSymmetric ( Node root ) { Queue < Node > q = new LinkedList < Node > ( ) ; q . add ( root . left ) ; q . add ( root . right ) ; while ( ! q . isEmpty ( ) ) { Node tempLeft = q . remove ( ) ; Node tempRight = q . remove ( ) ; if ( tempLeft == null && tempRight == null ) continue ; if ( ( tempLeft == null && tempRight != null ) || ( tempLeft != null && tempRight == null ) ) return false ; if ( tempLeft . val != tempRight . val ) return 0 ; q . add ( tempLeft . left ) ; q . add ( tempRight . right ) ; q . add ( tempLeft . right ) ; q . add ( tempRight . left ) ; } return true ; } public static void main ( String [ ] args ) { Node n = new Node ( 1 ) ; BinaryTree bt = new BinaryTree ( n ) ; bt . root . left = new Node ( 2 ) ; bt . root . right = new Node ( 2 ) ; bt . root . left . left = new Node ( 3 ) ; bt . root . left . right = new Node ( 4 ) ; bt . root . right . left = new Node ( 4 ) ; bt . root . right . right = new Node ( 3 ) ; if ( bt . isSymmetric ( bt . root ) ) System . out . println ( " The ▁ given ▁ tree ▁ is ▁ Symmetric " ) ; else System . out . println ( " The ▁ given ▁ tree ▁ is ▁ not ▁ Symmetric " ) ; } }
class Squares { public static int numberOfSquares ( int base ) { base = ( base - 2 ) ; base = base / 2 ; return base * ( base + 1 ) / 2 ; } public static void main ( String args [ ] ) { int base = 8 ; System . out . println ( numberOfSquares ( base ) ) ; } }
import java . io . * ; class GFG { static int modInverse ( int a , int prime ) { a = a % prime ; for ( int x = 1 ; x < prime ; x ++ ) if ( ( a * x ) % prime == 1 ) return x ; return - 1 ; } static void printModIverses ( int n , int prime ) { for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( modInverse ( i , prime ) + " ▁ " ) ; } public static void main ( String args [ ] ) { int n = 10 , prime = 17 ; printModIverses ( n , prime ) ; } }
public class Arc { static double arcLength ( double diameter , double angle ) { double pi = 22.0 / 7.0 ; double arc ; if ( angle >= 360 ) { System . out . println ( " Angle ▁ cannot " + " ▁ be ▁ formed " ) ; return 0 ; } else { arc = ( pi * diameter ) * ( angle / 360.0 ) ; return arc ; } } public static void main ( String args [ ] ) { double diameter = 25.0 ; double angle = 45.0 ; double arc_len = arcLength ( diameter , angle ) ; System . out . println ( arc_len ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( b == 0 ) return a ; return __gcd ( b , a % b ) ; } static int countBits ( int n ) { if ( n == 0 ) return 0 ; else return ( ( n & 1 ) == 0 ? 1 : 0 ) + countBits ( n >> 1 ) ; } static int maxGcd ( int n ) { if ( countBits ( n ) == 0 ) { for ( int i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { return n / i ; } } } else { int val = 0 ; int power = 1 ; int dupn = n ; while ( n > 0 ) { if ( ( n & 1 ) == 0 ) { val += power ; } power = power * 2 ; n = n >> 1 ; } return __gcd ( val ^ dupn , val & dupn ) ; } return 1 ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( maxGcd ( n ) ) ; n = 15 ; System . out . println ( maxGcd ( n ) ) ; } }
class GFG { static void findNumberOfDigits ( long n , int base ) { int dig = ( int ) ( Math . floor ( Math . log ( n ) / Math . log ( base ) ) + 1 ) ; System . out . println ( " The ▁ Number ▁ of ▁ digits ▁ of ▁ Number ▁ " + n + " ▁ in ▁ base ▁ " + base + " ▁ is ▁ " + dig ) ; } public static void main ( String [ ] args ) { long n = 1446 ; int base = 7 ; findNumberOfDigits ( n , base ) ; } }
public class GFG { static final int MAX = 256 ; static String lastNonRepeating ( String str , int n ) { int freq [ ] = new int [ MAX ] ; for ( int i = 0 ; i < n ; i ++ ) freq [ str . charAt ( i ) ] ++ ; for ( int i = n - 1 ; i >= 0 ; i -- ) { char ch = str . charAt ( i ) ; if ( freq [ ch ] == 1 ) return ( " " + ch ) ; } return " - 1" ; } public static void main ( String [ ] args ) { String str = " GeeksForGeeks " ; int n = str . length ( ) ; System . out . println ( lastNonRepeating ( str , n ) ) ; } }
public class GFG { static void diagonalsMinMax ( int [ ] [ ] mat ) { int n = mat . length ; if ( n == 0 ) return ; int principalMin = mat [ 0 ] [ 0 ] , principalMax = mat [ 0 ] [ 0 ] ; int secondaryMin = mat [ n - 1 ] [ 0 ] , secondaryMax = mat [ n - 1 ] [ 0 ] ; for ( int i = 0 ; i < n ; i ++ ) { if ( mat [ i ] [ i ] < principalMin ) { principalMin = mat [ i ] [ i ] ; } if ( mat [ i ] [ i ] > principalMax ) { principalMax = mat [ i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] < secondaryMin ) { secondaryMin = mat [ n - 1 - i ] [ i ] ; } if ( mat [ n - 1 - i ] [ i ] > secondaryMax ) { secondaryMax = mat [ n - 1 - i ] [ i ] ; } } System . out . println ( " Principal ▁ Diagonal ▁ Smallest ▁ Element : ▁ ▁ " + principalMin ) ; System . out . println ( " Principal ▁ Diagonal ▁ Greatest ▁ Element ▁ : ▁ " + principalMax ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Smallest ▁ Element : ▁ " + secondaryMin ) ; System . out . println ( " Secondary ▁ Diagonal ▁ Greatest ▁ Element : ▁ " + secondaryMax ) ; } static public void main ( String [ ] args ) { int [ ] [ ] matrix = { { 1 , 2 , 3 , 4 , - 10 } , { 5 , 6 , 7 , 8 , 6 } , { 1 , 2 , 11 , 3 , 4 } , { 5 , 6 , 70 , 5 , 8 } , { 4 , 9 , 7 , 1 , - 5 } } ; diagonalsMinMax ( matrix ) ; } }
import java . util . * ; class solution { static long getNthTerm ( long N ) { return ( ( int ) Math . pow ( N , 2 ) + N + 1 ) ; } public static void main ( String arr [ ] ) { long N = 11 ; System . out . println ( getNthTerm ( N ) ) ; } }
class GFG { static int findOddPair ( int A [ ] , int N ) { int oddPair = 0 ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = i + 1 ; j < N ; j ++ ) { if ( ( A [ i ] | A [ j ] ) % 2 != 0 ) oddPair ++ ; } } return oddPair ; } public static void main ( String [ ] args ) { int A [ ] = { 5 , 6 , 2 , 8 } ; int N = A . length ; System . out . println ( findOddPair ( A , N ) ) ; } }
import java . util . * ; class GFG { static class pair { int first , second ; public pair ( int first , int second ) { this . first = first ; this . second = second ; } } static void init ( int degree [ ] , pair [ ] edges , int n ) { for ( int i = 0 ; i < n ; i ++ ) { degree [ i ] = 0 ; } for ( int i = 0 ; i < edges . length ; i ++ ) { degree [ edges [ i ] . first ] ++ ; degree [ edges [ i ] . second ] ++ ; } } static void performQueries ( pair [ ] edges , int [ ] q , int n ) { int [ ] degree = new int [ n ] ; init ( degree , edges , n ) ; for ( int i = 0 ; i < q . length ; i ++ ) { int node = q [ i ] ; if ( node == 0 ) { System . out . println ( " No " ) ; continue ; } if ( degree [ node ] == 1 ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { int n = 6 ; pair [ ] edges = { new pair ( 0 , 1 ) , new pair ( 0 , 2 ) , new pair ( 1 , 3 ) , new pair ( 1 , 4 ) , new pair ( 4 , 5 ) } ; int [ ] q = { 0 , 3 , 4 , 5 } ; performQueries ( edges , q , n ) ; } }
class GFG { static int KnapSack ( int val [ ] , int wt [ ] , int n , int W ) { int mat [ ] [ ] = new int [ 2 ] [ W + 1 ] ; int i = 0 ; while ( i < n ) { int j = 0 ; if ( i % 2 != 0 ) { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 1 ] [ j ] = Math . max ( val [ i ] + mat [ 0 ] [ j - wt [ i ] ] , mat [ 0 ] [ j ] ) ; } else { mat [ 1 ] [ j ] = mat [ 0 ] [ j ] ; } } } else { while ( ++ j <= W ) { if ( wt [ i ] <= j ) { mat [ 0 ] [ j ] = Math . max ( val [ i ] + mat [ 1 ] [ j - wt [ i ] ] , mat [ 1 ] [ j ] ) ; } else { mat [ 0 ] [ j ] = mat [ 1 ] [ j ] ; } } } i ++ ; } return ( n % 2 != 0 ) ? mat [ 0 ] [ W ] : mat [ 1 ] [ W ] ; } public static void main ( String [ ] args ) { int val [ ] = { 7 , 8 , 4 } , wt [ ] = { 3 , 8 , 6 } , W = 10 , n = 3 ; System . out . println ( KnapSack ( val , wt , n , W ) ) ; } }
class GFG { static int numberOfPaths ( int m , int n ) { if ( m == 1 || n == 1 ) return 1 ; return numberOfPaths ( m - 1 , n ) + numberOfPaths ( m , n - 1 ) ; } public static void main ( String args [ ] ) { System . out . println ( numberOfPaths ( 3 , 3 ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int minimumCost ( int cost [ ] , int n ) { int dp [ ] = new int [ n ] ; if ( n == 1 ) return cost [ 0 ] ; dp [ 0 ] = cost [ 0 ] ; dp [ 1 ] = cost [ 1 ] ; for ( int i = 2 ; i < n ; i ++ ) { dp [ i ] = Math . min ( dp [ i - 1 ] , dp [ i - 2 ] ) + cost [ i ] ; } return Math . min ( dp [ n - 2 ] , dp [ n - 1 ] ) ; } public static void main ( String args [ ] ) { int a [ ] = { 16 , 19 , 10 , 12 , 18 } ; int n = a . length ; System . out . print ( minimumCost ( a , n ) ) ; } }
public class GFG { static double sum ( int x , int n ) { double total = 1.0 ; double previous = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { previous = ( previous * x ) / ( i + 1 ) ; total = total + previous ; } return total ; } public static void main ( String [ ] args ) { int x = 5 , n = 4 ; System . out . print ( " Sum ▁ is : ▁ " + sum ( x , n ) ) ; } }
class Test { static int arr [ ] = new int [ ] { 1 , 2 , 2 , 4 } ; static int countIncreasing ( int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ j ] > arr [ j - 1 ] ) cnt ++ ; else break ; } } return cnt ; } public static void main ( String [ ] args ) { System . out . println ( " Count ▁ of ▁ strictly ▁ increasing ▁ subarrays ▁ is ▁ " + countIncreasing ( arr . length ) ) ; } }
class GFG { static boolean isBinary ( int number ) { while ( number > 0 ) { int digit = number % 10 ; if ( digit > 1 ) return false ; number /= 10 ; } return true ; } public static void main ( String a [ ] ) { int n = 1000111 ; System . out . println ( isBinary ( n ) ) ; } }
public class Improve { static boolean isVowel ( char c ) { String vowel = " aeiou " ; for ( int i = 0 ; i < vowel . length ( ) ; ++ i ) if ( vowel . charAt ( i ) == c ) return true ; return false ; } static boolean printRLE ( String str , String typed ) { int n = str . length ( ) , m = typed . length ( ) ; int j = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( str . charAt ( i ) != typed . charAt ( j ) ) return false ; if ( isVowel ( str . charAt ( i ) ) == false ) { j ++ ; continue ; } int count1 = 1 ; while ( i < n - 1 && str . charAt ( i ) == str . charAt ( i + 1 ) ) { count1 ++ ; i ++ ; } int count2 = 1 ; while ( j < m - 1 && typed . charAt ( j ) == str . charAt ( i ) ) { count2 ++ ; j ++ ; } if ( count1 > count2 ) return false ; } return true ; } public static void main ( String args [ ] ) { String name = " alex " , typed = " aaalaeex " ; if ( printRLE ( name , typed ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int avg_of_even_num ( int n ) { return n + 1 ; } public static void main ( String [ ] args ) { int n = 8 ; System . out . println ( avg_of_even_num ( n ) ) ; } }
class GFG { static int solve ( int n , int base ) { int result = 0 ; while ( n > 0 ) { int remainder = n % base ; result = result + remainder ; n = n / base ; } return result ; } static void printSumsOfDigits ( int n ) { for ( int base = 2 ; base < n ; ++ base ) System . out . print ( solve ( n , base ) + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 8 ; printSumsOfDigits ( n ) ; } }
import java . util . * ; class GFG { static void printDiamond ( int n ) { System . out . println ( ) ; int i , j = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = i ; j < n ; j ++ ) System . out . print ( " * " ) ; for ( j = 0 ; j < 2 * i + 1 ; j ++ ) System . out . print ( " ▁ " ) ; for ( j = i ; j < n ; j ++ ) System . out . print ( " * " ) ; System . out . println ( ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = 0 ; j < i + 2 ; j ++ ) System . out . print ( " * " ) ; for ( j = 0 ; j < 2 * ( n - 1 - i ) - 1 ; j ++ ) System . out . print ( " ▁ " ) ; for ( j = 0 ; j < i + 2 ; j ++ ) System . out . print ( " * " ) ; System . out . println ( ) ; } System . out . println ( ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( " Inverse ▁ Diamond ▁ Pattern ▁ for ▁ n ▁ = ▁ " + n ) ; printDiamond ( n ) ; n = 7 ; System . out . println ( " \n Inverse ▁ Diamond ▁ Pattern ▁ for ▁ n ▁ = ▁ " + n ) ; printDiamond ( n ) ; } }
import java . io . * ; class GFG { static long center_pentadecagonal_num ( long n ) { return ( 15 * n * n - 15 * n + 2 ) / 2 ; } public static void main ( String [ ] args ) { long n = 3 ; System . out . print ( n + " th ▁ number ▁ : ▁ " ) ; System . out . println ( center_pentadecagonal_num ( n ) ) ; n = 10 ; System . out . print ( n + " th ▁ number ▁ : ▁ " ) ; System . out . println ( center_pentadecagonal_num ( n ) ) ; } }
import java . io . * ; class GFG { static int findevenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) if ( A [ i ] % 2 != 0 ) count ++ ; int oddCount = count * ( count - 1 ) / 2 ; return ( N * ( N - 1 ) / 2 ) - oddCount ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 1 , 3 , 2 } ; int n = a . length ; System . out . print ( findevenPair ( a , n ) ) ; } }
import java . util . * ; class GFG { static int pairCount ( int arr [ ] , int n ) { int max_val = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; Vector < Boolean > prime = new Vector < > ( max_val + 1 ) ; for ( int i = 0 ; i < max_val + 1 ; i ++ ) { prime . add ( true ) ; } prime . add ( 0 , Boolean . FALSE ) ; prime . add ( 1 , Boolean . FALSE ) ; for ( int p = 2 ; p * p <= max_val ; p ++ ) { if ( prime . get ( p ) == true ) { for ( int i = p * 2 ; i <= max_val ; i += p ) { prime . add ( i , Boolean . FALSE ) ; } } } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( prime . get ( arr [ i ] ) ) { count ++ ; } } return ( count * ( count - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 } ; int n = arr . length ; System . out . println ( pairCount ( arr , n ) ) ; } }
class GFG { static int GIF ( double n ) { return ( int ) Math . floor ( n ) ; } public static void main ( String [ ] args ) { double n = 2.3 ; System . out . println ( GIF ( n ) ) ; } }
import java . io . * ; class GFG { static int min_element ( int a [ ] ) { int min = Integer . MAX_VALUE , i ; for ( i = 0 ; i < a . length ; i ++ ) { if ( a [ i ] < min ) min = a [ i ] ; } return min ; } static int findSmallest ( int a [ ] , int n ) { int smallest = min_element ( a ) ; for ( int i = 1 ; i < n ; i ++ ) if ( a [ i ] % smallest >= 1 ) return - 1 ; return smallest ; } public static void main ( String args [ ] ) { int a [ ] = { 25 , 20 , 5 , 10 , 100 } ; int n = a . length ; System . out . println ( findSmallest ( a , n ) ) ; } }
class MatrixChainMultiplication { static int MatrixChainOrder ( int p [ ] , int n ) { int m [ ] [ ] = new int [ n ] [ n ] ; int i , j , k , L , q ; for ( i = 1 ; i < n ; i ++ ) m [ i ] [ i ] = 0 ; for ( L = 2 ; L < n ; L ++ ) { for ( i = 1 ; i < n - L + 1 ; i ++ ) { j = i + L - 1 ; if ( j == n ) continue ; m [ i ] [ j ] = Integer . MAX_VALUE ; for ( k = i ; k <= j - 1 ; k ++ ) { q = m [ i ] [ k ] + m [ k + 1 ] [ j ] + p [ i - 1 ] * p [ k ] * p [ j ] ; if ( q < m [ i ] [ j ] ) m [ i ] [ j ] = q ; } } } return m [ 1 ] [ n - 1 ] ; } public static void main ( String args [ ] ) { int arr [ ] = new int [ ] { 1 , 2 , 3 , 4 } ; int size = arr . length ; System . out . println ( " Minimum ▁ number ▁ of ▁ multiplications ▁ is ▁ " + MatrixChainOrder ( arr , size ) ) ; } }
class GFG { static int numbers ( int n , int arr [ ] , int m ) { int isZero = 0 , isFive = 0 ; int result = 0 ; if ( m < n ) { return - 1 ; } for ( int i = 0 ; i < m ; i ++ ) { if ( arr [ i ] == 0 ) { isZero = 1 ; } if ( arr [ i ] == 5 ) { isFive = 1 ; } } if ( isZero == 1 && isFive == 1 ) { result = 2 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else if ( isZero == 1 || isFive == 1 ) { result = 1 ; for ( int i = 0 ; i < n - 1 ; i ++ ) { result = result * ( -- m ) ; } } else { result = - 1 ; } return result ; } public static void main ( String [ ] args ) { int n = 3 , m = 6 ; int arr [ ] = { 2 , 3 , 5 , 6 , 7 , 9 } ; System . out . println ( numbers ( n , arr , m ) ) ; } }
class GFG { static int findMinRemoval ( int arr [ ] , int n ) { int temp , value = 0 ; int maximum = 0 ; if ( n == 1 ) return 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( i != 0 && i != n - 1 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) + Math . abs ( arr [ i ] - arr [ i - 1 ] ) - Math . abs ( arr [ i - 1 ] - arr [ i + 1 ] ) ; } else if ( i == 0 ) { value = value + Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; temp = Math . abs ( arr [ i ] - arr [ i + 1 ] ) ; } else temp = Math . abs ( arr [ i ] - arr [ i - 1 ] ) ; maximum = Math . max ( maximum , temp ) ; } return ( value - maximum ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 5 , 3 , 2 , 10 } ; int n = arr . length ; System . out . print ( findMinRemoval ( arr , n ) + " \n " ) ; } }
class OddOccurrence { static int getOddOccurrence ( int arr [ ] , int arr_size ) { int i ; for ( i = 0 ; i < arr_size ; i ++ ) { int count = 0 ; for ( int j = 0 ; j < arr_size ; j ++ ) { if ( arr [ i ] == arr [ j ] ) count ++ ; } if ( count % 2 != 0 ) return arr [ i ] ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 2 , 3 , 5 , 4 , 5 , 2 , 4 , 3 , 5 , 2 , 4 , 4 , 2 } ; int n = arr . length ; System . out . println ( getOddOccurrence ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void ComputePrefixXor ( int arr [ ] , int PrefixXor [ ] , int n ) { PrefixXor [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) PrefixXor [ i ] = PrefixXor [ i - 1 ] ^ arr [ i ] ; } static int Xor_Sum ( int arr [ ] , int n ) { int [ ] PrefixXor = new int [ n ] ; ComputePrefixXor ( arr , PrefixXor , n ) ; int sum = 0 , index = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) > sum ) { sum = PrefixXor [ i ] + ( PrefixXor [ n - 1 ] ^ PrefixXor [ i ] ) ; index = i ; } } return index + 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 4 , 6 , 3 , 8 , 13 , 34 , 2 , 21 , 10 } ; int n = arr . length ; System . out . println ( Xor_Sum ( arr , n ) ) ; } }
class GFG { static int LucasSum ( int N ) { int sum = 0 ; int a = 2 , b = 1 , c ; sum += a ; while ( b <= N ) { sum += b ; c = a + b ; a = b ; b = c ; } return sum ; } public static void main ( String [ ] args ) { int N = 20 ; System . out . println ( LucasSum ( N ) ) ; } }
import java . io . * ; class GFG { static boolean isPalindrome ( String str ) { int l = 0 ; int h = str . length ( ) - 1 ; while ( h > l ) if ( str . charAt ( l ++ ) != str . charAt ( h -- ) ) return false ; return true ; } static int minRemovals ( String str ) { if ( str . charAt ( 0 ) == '')  return 0 ; if ( isPalindrome ( str ) ) return 1 ; return 2 ; } public static void main ( String [ ] args ) { System . out . println ( minRemovals ( "010010" ) ) ; System . out . println ( minRemovals ( "0100101" ) ) ; } }
import java . io . * ; import java . util . * ; import java . math . * ; class GFG { static boolean pronic_check ( int n ) { int x = ( int ) ( Math . sqrt ( n ) ) ; if ( x * ( x + 1 ) == n ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 56 ; if ( pronic_check ( n ) == true ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . io . * ; class GFG { static int centered_square_num ( int n ) { return n * n + ( ( n - 1 ) * ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( n + " th ▁ Centered " + " ▁ square ▁ number : ▁ " + centered_square_num ( n ) ) ; } }
class GFG { static void solve ( int interval [ ] [ ] , int N , int Q ) { int Mark [ ] = new int [ Q ] ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; for ( int j = l ; j <= r ; j ++ ) Mark [ j ] ++ ; } int count = 0 ; for ( int i = 0 ; i < Q ; i ++ ) { if ( Mark [ i ] != 0 ) count ++ ; } int count1 [ ] = new int [ Q ] ; if ( Mark [ 0 ] == 1 ) count1 [ 0 ] = 1 ; for ( int i = 1 ; i < Q ; i ++ ) { if ( Mark [ i ] == 1 ) count1 [ i ] = count1 [ i - 1 ] + 1 ; else count1 [ i ] = count1 [ i - 1 ] ; } int maxindex = 0 ; int maxcoverage = 0 ; for ( int i = 0 ; i < N ; i ++ ) { int l = interval [ i ] [ 0 ] - 1 ; int r = interval [ i ] [ 1 ] - 1 ; int elem1 ; if ( l != 0 ) elem1 = count1 [ r ] - count1 [ l - 1 ] ; else elem1 = count1 [ r ] ; if ( count - elem1 >= maxcoverage ) { maxcoverage = count - elem1 ; maxindex = i ; } } System . out . println ( " Maximum ▁ Coverage ▁ is ▁ " + maxcoverage + " ▁ after ▁ removing ▁ interval ▁ at ▁ index ▁ " + maxindex ) ; } public static void main ( String [ ] args ) { int interval [ ] [ ] = { { 1 , 4 } , { 4 , 5 } , { 5 , 6 } , { 6 , 7 } , { 3 , 5 } } ; int N = interval . length ; int Q = 7 ; solve ( interval , N , Q ) ; } }
import java . util . * ; class GFG { static int minIncrementForUnique ( int [ ] A ) { HashMap < Integer , Integer > mpp = new HashMap < Integer , Integer > ( ) ; for ( int i : A ) { if ( mpp . containsKey ( i ) ) mpp . put ( i , mpp . get ( i ) + 1 ) ; else mpp . put ( i , 1 ) ; } Vector < Integer > taken = new Vector < Integer > ( ) ; int ans = 0 ; for ( int x = 0 ; x < 100000 ; x ++ ) { if ( mpp . containsKey ( x ) && mpp . get ( x ) >= 2 ) taken . add ( x * ( mpp . get ( x ) - 1 ) ) ; else if ( taken . size ( ) > 0 && ( ( mpp . containsKey ( x ) && mpp . get ( x ) == 0 ) || ! mpp . containsKey ( x ) ) ) { ans += x - taken . get ( taken . size ( ) - 1 ) ; taken . remove ( taken . size ( ) - 1 ) ; } } return ans ; } public static void main ( String [ ] args ) { int [ ] A = { 3 , 2 , 1 , 2 , 1 , 7 } ; System . out . print ( minIncrementForUnique ( A ) ) ; } }
class GFG { static int findLargest ( int [ ] arr , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( arr [ i ] , gcd ) ; return gcd ; } static int __gcd ( int a , int b ) { return b == 0 ? a : __gcd ( b , a % b ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 6 , 9 } ; int n = arr . length ; System . out . print ( findLargest ( arr , n ) ) ; } }
import java . util . * ; class GFG { static boolean isPerfectPower ( int n ) { if ( n == 1 ) { return true ; } for ( int x = 2 ; x <= Math . sqrt ( n ) ; x ++ ) { int y = 2 ; int p = ( int ) Math . pow ( x , y ) ; while ( p <= n && p > 0 ) { if ( p == n ) { return true ; } y ++ ; p = ( int ) Math . pow ( x , y ) ; } } return false ; } static boolean isStrongNumber ( int n ) { HashMap < Integer , Integer > count = new HashMap < Integer , Integer > ( ) ; while ( n % 2 == 0 ) { n = n / 2 ; if ( count . containsKey ( 2 ) ) { count . put ( 2 , count . get ( 2 ) + 1 ) ; } else { count . put ( 2 , 1 ) ; } } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i += 2 ) { while ( n % i == 0 ) { n = n / i ; if ( count . containsKey ( i ) ) { count . put ( i , count . get ( i ) + 1 ) ; } else { count . put ( i , 1 ) ; } } } if ( n > 2 ) { if ( count . containsKey ( n ) ) { count . put ( n , count . get ( n ) + 1 ) ; } else { count . put ( n , 1 ) ; } } int flag = 0 ; for ( Map . Entry < Integer , Integer > b : count . entrySet ( ) ) { if ( b . getValue ( ) == 1 ) { flag = 1 ; break ; } } if ( flag == 1 ) { return false ; } else { return true ; } } static boolean isTrojan ( int n ) { if ( ! isPerfectPower ( n ) && isStrongNumber ( n ) ) { return true ; } else { return false ; } } public static void main ( String [ ] args ) { int n = 108 ; if ( isTrojan ( n ) ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } }
import java . lang . * ; class GFG { public static int binomialCoeff ( int n , int k ) { int [ ] [ ] C = new int [ n + 1 ] [ k + 1 ] ; int i , j ; for ( i = 0 ; i <= n ; i ++ ) { for ( j = 0 ; j <= Math . min ( i , k ) ; j ++ ) { if ( j == 0 || j == i ) C [ i ] [ j ] = 1 ; else C [ i ] [ j ] = C [ i - 1 ] [ j - 1 ] + C [ i - 1 ] [ j ] ; } } return C [ n ] [ k ] ; } public static int count ( int n , int k ) { int sum = 0 ; for ( int j = 1 ; j <= k ; j ++ ) { sum = sum + binomialCoeff ( n , j ) ; } return sum ; } public static void main ( String args [ ] ) { GFG g = new GFG ( ) ; int n = 3 , k = 2 ; System . out . print ( count ( n , k ) ) ; int n1 = 5 , k1 = 2 ; System . out . print ( count ( n1 , k1 ) ) ; } }
import java . util . TreeMap ; class Count { static int countPairs ( int [ ] a , int n ) { TreeMap < Integer , Integer > map = new TreeMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { map . put ( a [ i ] , 1 ) ; } int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( map . get ( a [ i ] ) < 1 ) continue ; int cur = 1 ; while ( cur <= a [ i ] ) cur <<= 1 ; if ( map . containsKey ( cur - a [ i ] ) ) { if ( cur - a [ i ] == a [ i ] && map . get ( a [ i ] ) == 1 ) continue ; count ++ ; map . put ( cur - a [ i ] , map . get ( cur - a [ i ] ) - 1 ) ; map . put ( a [ i ] , map . get ( a [ i ] ) - 1 ) ; } } return count ; } public static void main ( String [ ] args ) { int [ ] a = { 3 , 11 , 14 , 5 , 13 } ; int n = a . length ; System . out . println ( countPairs ( a , n ) ) ; } }
public class GFG { static int startingPoint ( int Length , int Speed1 , int Speed2 ) { int result1 = 0 , result2 = 0 ; int time1 = Length / Speed1 ; int time2 = Length / Speed2 ; result1 = __gcd ( time1 , time2 ) ; result2 = time1 * time2 / ( result1 ) ; return result2 ; } static int __gcd ( int a , int b ) { if ( b == 0 ) { return a ; } return __gcd ( b , a % b ) ; } static float firstTime ( int Length , int Speed1 , int Speed2 ) { float result = 0 ; int relativeSpeed = Math . abs ( Speed1 - Speed2 ) ; result = ( ( float ) Length / relativeSpeed ) ; return result ; } public static void main ( String [ ] args ) { int L = 30 , S1 = 5 , S2 = 2 ; float first_Time = firstTime ( L , S1 , S2 ) ; int starting_Point = startingPoint ( L , S1 , S2 ) ; System . out . println ( " Met ▁ first ▁ time ▁ after ▁ " + first_Time + " ▁ hrs " ) ; System . out . println ( " Met ▁ at ▁ starting ▁ point ▁ after ▁ " + starting_Point + " ▁ hrs " ) ; } }
class GFG { static long binomialCoeff ( int n , int k ) { long res = 1 ; if ( k > n - k ) k = n - k ; for ( int i = 0 ; i < k ; ++ i ) { res *= ( n - i ) ; res /= ( i + 1 ) ; } return res ; } static long catalan ( int n ) { long c = binomialCoeff ( 2 * n , n ) ; return c / ( n + 1 ) ; } static long findWays ( int n ) { if ( ( n & 1 ) != 0 ) return 0 ; return catalan ( n / 2 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( " Total ▁ possible ▁ expressions ▁ of ▁ length ▁ " + n + " ▁ is ▁ " + findWays ( 6 ) ) ; } }
import java . io . * ; class GFG { static void print_sequence ( int n , int k ) { int b = n / ( k * ( k + 1 ) / 2 ) ; if ( b == 0 ) { System . out . println ( " - 1" ) ; } else { int r = 1 ; for ( int x = 1 ; x * x <= n ; x ++ ) { if ( n % x != 0 ) continue ; if ( x <= b && x > r ) r = x ; if ( n / x <= b && n / x > r ) r = n / x ; } for ( int i = 1 ; i < k ; i ++ ) System . out . print ( r * i + " ▁ " ) ; int res = n - ( r * ( k * ( k - 1 ) / 2 ) ) ; System . out . println ( res ) ; } } public static void main ( String [ ] args ) { int n = 24 ; int k = 4 ; print_sequence ( n , k ) ; n = 24 ; k = 5 ; print_sequence ( n , k ) ; n = 6 ; k = 4 ; print_sequence ( n , k ) ; } }
import java . io . * ; class GFG { static int maxLen = 10 ; static int dp [ ] = new int [ maxLen ] ; static boolean [ ] visit = new boolean [ maxLen ] ; static int maxSum ( int arr [ ] , int i , int n , int k ) { if ( i >= n ) return 0 ; if ( visit [ i ] ) return dp [ i ] ; visit [ i ] = true ; int tot = 0 ; dp [ i ] = maxSum ( arr , i + 1 , n , k ) ; for ( int j = i ; j < ( i + k ) && ( j < n ) ; j ++ ) { tot += arr [ j ] ; dp [ i ] = Math . max ( dp [ i ] , tot + maxSum ( arr , j + 2 , n , k ) ) ; } return dp [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , - 3 , 4 , 5 } ; int k = 2 ; int n = arr . length ; System . out . println ( maxSum ( arr , 0 , n , k ) ) ; } }
public class GFG { public static void findIndices ( int arr [ ] , int n ) { int leftMin = 0 , rightMin = 0 ; int leftMax = 0 , rightMax = 0 ; int min = arr [ 0 ] , max = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { if ( arr [ i ] < min ) { leftMin = rightMin = i ; min = arr [ i ] ; } else if ( arr [ i ] == min ) rightMin = i ; if ( arr [ i ] > max ) { leftMax = rightMax = i ; max = arr [ i ] ; } else if ( arr [ i ] == max ) rightMax = i ; } System . out . println ( " Minimum ▁ left ▁ : ▁ " + leftMin ) ; System . out . println ( " Minimum ▁ right ▁ : ▁ " + rightMin ) ; System . out . println ( " Maximum ▁ left ▁ : ▁ " + leftMax ) ; System . out . println ( " Maximum ▁ right ▁ : ▁ " + rightMax ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 1 , 1 , 2 , 1 , 5 , 6 , 5 } ; int n = arr . length ; findIndices ( arr , n ) ; } }
class GFG { static final int MAX = 100 ; static boolean search ( int mat [ ] [ ] , int m , int n , int x ) { int i = m - 1 , j = 0 ; while ( i >= 0 && j < n ) { if ( mat [ i ] [ j ] == x ) return true ; if ( mat [ i ] [ j ] > x ) i -- ; else j ++ ; } return false ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 10 , 20 , 30 , 40 } , { 15 , 25 , 35 , 45 } , { 27 , 29 , 37 , 48 } , { 32 , 33 , 39 , 50 } , { 50 , 60 , 70 , 80 } } ; if ( search ( mat , 5 , 4 , 29 ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . Arrays ; class GFG { static int minOperations ( int [ ] arr , int n ) { int maxi , result = 0 ; int [ ] freq = new int [ 1000001 ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x ] ++ ; } maxi = Arrays . stream ( arr ) . max ( ) . getAsInt ( ) ; for ( int i = 1 ; i <= maxi ; i ++ ) { if ( freq [ i ] != 0 ) { for ( int j = i * 2 ; j <= maxi ; j = j + i ) { freq [ j ] = 0 ; } result ++ ; } } return result ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 4 , 2 , 4 , 4 , 4 } ; int n = arr . length ; System . out . println ( minOperations ( arr , n ) ) ; } }
class GFG { static int gcd ( int a , int b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } static void FindRatio ( int a , int b , int c ) { int up = Math . abs ( b - c ) ; int down = Math . abs ( c - a ) ; int g = gcd ( up , down ) ; up /= g ; down /= g ; System . out . println ( up + " : " + down ) ; } public static void main ( String [ ] args ) { int a = 4 , b = 10 , c = 6 ; FindRatio ( a , b , c ) ; } }
class GFG { static void CalculatePairs ( int a [ ] , int n ) { int cnt_zero = 0 ; int cnt_one = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) cnt_zero += 1 ; else cnt_one += 1 ; } int total_XOR_pairs = cnt_zero * cnt_one ; int total_AND_pairs = ( cnt_one ) * ( cnt_one - 1 ) / 2 ; int total_OR_pairs = cnt_zero * cnt_one + ( cnt_one ) * ( cnt_one - 1 ) / 2 ; System . out . println ( " cntXOR ▁ = ▁ " + total_XOR_pairs ) ; System . out . println ( " cntAND ▁ = ▁ " + total_AND_pairs ) ; System . out . println ( " cntOR ▁ = ▁ " + total_OR_pairs ) ; } public static void main ( String [ ] args ) { int a [ ] = { 1 , 3 , 4 , 2 } ; int n = a . length ; CalculatePairs ( a , n ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int subset ( int ar [ ] , int n ) { int res = 0 ; Arrays . sort ( ar ) ; for ( int i = 0 ; i < n ; i ++ ) { int count = 1 ; for ( ; i < n - 1 ; i ++ ) { if ( ar [ i ] == ar [ i + 1 ] ) count ++ ; else break ; } res = Math . max ( res , count ) ; } return res ; } public static void main ( String argc [ ] ) { int arr [ ] = { 5 , 6 , 9 , 3 , 4 , 3 , 4 } ; int n = 7 ; System . out . println ( subset ( arr , n ) ) ; } }
class GFG { static int [ ] pref = new int [ 100010 ] ; static int isPerfectSquare ( int x ) { double sr = Math . sqrt ( x ) ; return ( ( sr - Math . floor ( sr ) ) == 0 ) ? x : 0 ; } static void compute ( ) { for ( int i = 1 ; i <= 100000 ; ++ i ) { pref [ i ] = pref [ i - 1 ] + isPerfectSquare ( i ) ; } } static void printSum ( int L , int R ) { int sum = pref [ R ] - pref [ L - 1 ] ; System . out . print ( sum + " ▁ " ) ; } public static void main ( String [ ] args ) { compute ( ) ; int Q = 4 ; int arr [ ] [ ] = { { 1 , 10 } , { 1 , 100 } , { 2 , 25 } , { 4 , 50 } } ; for ( int i = 0 ; i < Q ; i ++ ) { printSum ( arr [ i ] [ 0 ] , arr [ i ] [ 1 ] ) ; } } }
import java . util . * ; class GFG { static boolean isToOneRec ( int n , HashSet < Integer > s ) { if ( n == 1 ) { return true ; } if ( s . contains ( n ) ) { return false ; } return ( n % 2 == 1 ) ? isToOneRec ( 3 * n + 1 , s ) : isToOneRec ( n / 2 , s ) ; } static boolean isToOne ( int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; return isToOneRec ( n , s ) ; } public static void main ( String [ ] args ) { int n = 5 ; if ( isToOne ( n ) ) { System . out . print ( " Yes " ) ; } else { System . out . print ( " No " ) ; } } }
public class GFG { static int ways ( int n ) { int first = 2 ; int second = 3 ; int res = 0 ; for ( int i = 3 ; i <= n ; i ++ ) { res = first + second ; first = second ; second = res ; } return res ; } public static void main ( String [ ] args ) { int n = 7 ; System . out . print ( " Total ▁ ways ▁ are : ▁ " + ways ( n ) ) ; } }
class GFG { static int N = 100 ; static void pre_process ( boolean dp [ ] [ ] , char [ ] s ) { int n = s . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp [ i ] [ j ] = false ; } } for ( int j = 1 ; j <= n ; j ++ ) { for ( int i = 0 ; i <= n - j ; i ++ ) { if ( j <= 2 ) { if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = true ; } } else if ( s [ i ] == s [ i + j - 1 ] ) { dp [ i ] [ i + j - 1 ] = dp [ i + 1 ] [ i + j - 2 ] ; } } } } static void answerQuery ( int l , int r , boolean dp [ ] [ ] ) { if ( dp [ l ] [ r ] ) { System . out . println ( " Yes " ) ; } else { System . out . println ( " No " ) ; } } public static void main ( String [ ] args ) { String s = " abaaab " ; boolean [ ] [ ] dp = new boolean [ N ] [ N ] ; pre_process ( dp , s . toCharArray ( ) ) ; int queries [ ] [ ] = { { 0 , 1 } , { 1 , 5 } } ; int q = queries . length ; for ( int i = 0 ; i < q ; i ++ ) { answerQuery ( queries [ i ] [ 0 ] , queries [ i ] [ 1 ] , dp ) ; } } }
import java . util . * ; class GFG { static int distribution ( int arr [ ] , int n ) { Set < Integer > resources = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) resources . add ( arr [ i ] ) ; return Math . min ( resources . size ( ) , n / 2 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 , 1 , 3 , 4 } ; int n = arr . length ; System . out . print ( distribution ( arr , n ) + " \n " ) ; } }
class GFG { static int countOdd ( int [ ] arr , int n ) { int odd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 1 ) odd ++ ; } return odd ; } static int countValidPairs ( int [ ] arr , int n ) { int odd = countOdd ( arr , n ) ; return ( odd * ( odd - 1 ) ) / 2 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( countValidPairs ( arr , n ) ) ; } }
import java . util . * ; class Solution { static boolean isBinary ( int n ) { while ( n != 0 ) { int temp = n % 10 ; if ( temp != 0 && temp != 1 ) { return false ; } n = n / 10 ; } return true ; } static void formBinaryStr ( int n , int a [ ] ) { boolean flag = true ; String s = " " ; for ( int i = 0 ; i < n ; i ++ ) { if ( isBinary ( a [ i ] ) ) s += " " + a [ i ] ; else { flag = false ; break ; } } if ( flag ) System . out . print ( s + " \n " ) ; else System . out . print ( " - 1 \n " ) ; } public static void main ( String args [ ] ) { int a [ ] = { 10 , 1 , 0 , 11 , 10 } ; int N = a . length ; formBinaryStr ( N , a ) ; } }
class GFG { static void bonacciseries ( int n , int m ) { int a [ ] = new int [ m ] ; for ( int i = 0 ; i < m ; i ++ ) a [ i ] = 0 ; a [ n - 1 ] = 1 ; a [ n ] = 1 ; for ( int i = n + 1 ; i < m ; i ++ ) a [ i ] = 2 * a [ i - 1 ] - a [ i - n - 1 ] ; for ( int i = 0 ; i < m ; i ++ ) System . out . print ( a [ i ] + " ▁ " ) ; } public static void main ( String args [ ] ) { int N = 5 , M = 15 ; bonacciseries ( N , M ) ; } }
class GFG { static int countPairs ( int arr [ ] , int n ) { int cnt = 0 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = i + 1 ; j < n ; j ++ ) { if ( arr [ i ] != arr [ j ] ) cnt ++ ; } } return cnt ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 1 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . util . * ; class GFG { static void generate ( Set < String > st , String s ) { if ( s . length ( ) == 0 ) { return ; } if ( ! st . contains ( s ) ) { st . add ( s ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { String t = s ; t = t . substring ( 0 , i ) + t . substring ( i + 1 ) ; generate ( st , t ) ; } } return ; } public static void main ( String args [ ] ) { String s = " xyz " ; TreeSet < String > st = new TreeSet < > ( ) ; generate ( st , s ) ; for ( String str : st ) { System . out . println ( str ) ; } } }
class GFG { static int max ( int a , int b ) { return ( a > b ) ? a : b ; } static void printknapSack ( int W , int wt [ ] , int val [ ] , int n ) { int i , w ; int K [ ] [ ] = new int [ n + 1 ] [ W + 1 ] ; for ( i = 0 ; i <= n ; i ++ ) { for ( w = 0 ; w <= W ; w ++ ) { if ( i == 0 || w == 0 ) K [ i ] [ w ] = 0 ; else if ( wt [ i - 1 ] <= w ) K [ i ] [ w ] = Math . max ( val [ i - 1 ] + K [ i - 1 ] [ w - wt [ i - 1 ] ] , K [ i - 1 ] [ w ] ) ; else K [ i ] [ w ] = K [ i - 1 ] [ w ] ; } } int res = K [ n ] [ W ] ; System . out . println ( res ) ; w = W ; for ( i = n ; i > 0 && res > 0 ; i -- ) { if ( res == K [ i - 1 ] [ w ] ) continue ; else { System . out . print ( wt [ i - 1 ] + " ▁ " ) ; res = res - val [ i - 1 ] ; w = w - wt [ i - 1 ] ; } } } public static void main ( String arg [ ] ) { int val [ ] = { 60 , 100 , 120 } ; int wt [ ] = { 10 , 20 , 30 } ; int W = 50 ; int n = val . length ; printknapSack ( W , wt , val , n ) ; } }
import java . util . * ; class GFG { static int findSum ( int arr [ ] , int n ) { int sum = 0 ; HashSet < Integer > s = new HashSet < Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! s . contains ( arr [ i ] ) ) { sum += arr [ i ] ; s . add ( arr [ i ] ) ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 1 , 1 , 4 , 5 , 6 } ; int n = arr . length ; System . out . println ( findSum ( arr , n ) ) ; } }
class GFG { static int sumOfDigit ( int n , int b ) { int unitDigit , sum = 0 ; while ( n > 0 ) { unitDigit = n % b ; sum += unitDigit ; n = n / b ; } return sum ; } public static void main ( String [ ] args ) { int n = 50 ; int b = 2 ; System . out . print ( sumOfDigit ( n , b ) ) ; } }
import java . io . * ; class GFG { static int minflip ( int [ ] arr1 , int [ ] arr2 , int [ ] arr3 , int p , int q , int n ) { int flip = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( arr1 [ i ] > 0 ^ arr2 [ i ] > 0 != arr3 [ i ] > 0 ) flip ++ ; return ( flip <= p + q ) ? flip : - 1 ; } static public void main ( String [ ] args ) { int [ ] arr1 = { 1 , 0 , 1 , 1 , 1 , 1 , 1 } ; int [ ] arr2 = { 0 , 1 , 1 , 1 , 1 , 0 , 0 } ; int [ ] arr3 = { 1 , 1 , 1 , 1 , 0 , 0 , 1 } ; int n = arr1 . length ; int p = 2 , q = 4 ; System . out . println ( minflip ( arr1 , arr2 , arr3 , p , q , n ) ) ; } }
class GFG { static int checkArray ( int [ ] arr , int n ) { return ( ( arr [ 0 ] % 2 ) > 0 && ( arr [ n - 1 ] % 2 ) > 0 && ( n % 2 ) > 0 ) ? 1 : 0 ; } public static void main ( String [ ] args ) { int [ ] arr = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; System . out . println ( checkArray ( arr , n ) ) ; } }
import java . util . * ; class solution { static void pattern ( int N ) { int i , j , k = 0 , space = 1 , rows = N ; for ( i = rows ; i >= 1 ; i -- ) { for ( j = 1 ; j <= i ; j ++ ) { System . out . print ( " * " ) ; } if ( i != rows ) { for ( k = 1 ; k <= space ; k ++ ) { System . out . print ( " ▁ " ) ; } space = space + 2 ; } for ( j = i ; j >= 1 ; j -- ) { if ( j != rows ) System . out . print ( " * " ) ; } System . out . print ( " \n " ) ; } System . out . print ( " \n " ) ; } public static void main ( String args [ ] ) { int N = 6 ; pattern ( N ) ; } }
class GFG { static int discreteLogarithm ( int a , int b , int m ) { int n = ( int ) ( Math . sqrt ( m ) + 1 ) ; int an = 1 ; for ( int i = 0 ; i < n ; ++ i ) an = ( an * a ) % m ; int [ ] value = new int [ m ] ; for ( int i = 1 , cur = an ; i <= n ; ++ i ) { if ( value [ cur ] == 0 ) value [ cur ] = i ; cur = ( cur * an ) % m ; } for ( int i = 0 , cur = b ; i <= n ; ++ i ) { if ( value [ cur ] > 0 ) { int ans = value [ cur ] * n - i ; if ( ans < m ) return ans ; } cur = ( cur * a ) % m ; } return - 1 ; } public static void main ( String [ ] args ) { int a = 2 , b = 3 , m = 5 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; a = 3 ; b = 7 ; m = 11 ; System . out . println ( discreteLogarithm ( a , b , m ) ) ; } }
public class MaximumAbsoluteDifference { private static int calculateDiff ( int i , int j , int [ ] array ) { return Math . abs ( array [ i ] - array [ j ] ) + Math . abs ( i - j ) ; } private static int maxDistance ( int [ ] array ) { int result = 0 ; for ( int i = 0 ; i < array . length ; i ++ ) { for ( int j = i ; j < array . length ; j ++ ) { result = Math . max ( result , calculateDiff ( i , j , array ) ) ; } } return result ; } public static void main ( String [ ] args ) { int [ ] array = { - 70 , - 64 , - 6 , - 56 , 64 , 61 , - 57 , 16 , 48 , - 98 } ; System . out . println ( maxDistance ( array ) ) ; } }
public class GFG { static int zeroUpto ( int digits ) { int first = ( int ) ( ( Math . pow ( 10 , digits ) - 1 ) / 9 ) ; int second = ( int ) ( ( Math . pow ( 9 , digits ) - 1 ) / 8 ) ; return 9 * ( first - second ) ; } static int toInt ( char c ) { return ( int ) ( c ) - 48 ; } static int countZero ( String num ) { int k = num . length ( ) ; int total = zeroUpto ( k - 1 ) ; int non_zero = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { if ( num . charAt ( i ) == '0' ) { non_zero -- ; break ; } non_zero += ( toInt ( num . charAt ( i ) ) - 1 ) * ( Math . pow ( 9 , k - 1 - i ) ) ; } int no = 0 , remaining = 0 , calculatedUpto = 0 ; for ( int i = 0 ; i < num . length ( ) ; i ++ ) { no = no * 10 + ( toInt ( num . charAt ( i ) ) ) ; if ( i != 0 ) calculatedUpto = calculatedUpto * 10 + 9 ; } remaining = no - calculatedUpto ; int ans = zeroUpto ( k - 1 ) + ( remaining - non_zero - 1 ) ; return ans ; } static public void main ( String [ ] args ) { String num = "107" ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + countZero ( num ) ) ; num = "1264" ; System . out . println ( " Count ▁ of ▁ numbers ▁ from ▁ 1" + " ▁ to ▁ " + num + " ▁ is ▁ " + countZero ( num ) ) ; } }
class GFG { static class Node { int data ; Node next ; Node ( int x ) { data = x ; next = null ; } } ; static void printList ( Node head ) { if ( head == null ) return ; Node temp = head ; do { System . out . print ( temp . data + " - > " ) ; temp = temp . next ; } while ( temp != head ) ; System . out . println ( head . data ) ; } static Node deleteK ( Node head_ref , int k ) { Node head = head_ref ; if ( head == null ) return null ; Node curr = head , prev = null ; while ( true ) { if ( curr . next == head && curr == head ) break ; printList ( head ) ; for ( int i = 0 ; i < k ; i ++ ) { prev = curr ; curr = curr . next ; } if ( curr == head ) { prev = head ; while ( prev . next != head ) prev = prev . next ; head = curr . next ; prev . next = head ; head_ref = head ; } else if ( curr . next == head ) { prev . next = head ; } else { prev . next = curr . next ; } } return head ; } static Node insertNode ( Node head_ref , int x ) { Node head = head_ref ; Node temp = new Node ( x ) ; if ( head == null ) { temp . next = temp ; head_ref = temp ; return head_ref ; } else { Node temp1 = head ; while ( temp1 . next != head ) temp1 = temp1 . next ; temp1 . next = temp ; temp . next = head ; } return head ; } public static void main ( String args [ ] ) { Node head = null ; head = insertNode ( head , 1 ) ; head = insertNode ( head , 2 ) ; head = insertNode ( head , 3 ) ; head = insertNode ( head , 4 ) ; head = insertNode ( head , 5 ) ; head = insertNode ( head , 6 ) ; head = insertNode ( head , 7 ) ; head = insertNode ( head , 8 ) ; head = insertNode ( head , 9 ) ; int k = 4 ; head = deleteK ( head , k ) ; } }
class GFG { static int possibleways ( int n ) { if ( n % 2 == 1 ) return 0 ; else if ( n % 4 == 0 ) return n / 4 - 1 ; else return n / 4 ; } public static void main ( String [ ] args ) { int n = 20 ; System . out . println ( possibleways ( n ) ) ; } }
import java . io . * ; class GFG { static int numberOfWays ( int x ) { int dp [ ] = new int [ x + 1 ] ; dp [ 0 ] = dp [ 1 ] = 1 ; for ( int i = 2 ; i <= x ; i ++ ) dp [ i ] = dp [ i - 1 ] + ( i - 1 ) * dp [ i - 2 ] ; return dp [ x ] ; } public static void main ( String [ ] args ) { int x = 3 ; System . out . println ( numberOfWays ( x ) ) ; } }
class GFG { static int properDivisorSum ( int n ) { int sum = 0 ; int i ; for ( i = 1 ; i <= n ; ++ i ) sum += ( n / i ) * i ; return sum - n * ( n + 1 ) / 2 ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( properDivisorSum ( n ) ) ; n = 5 ; System . out . println ( properDivisorSum ( n ) ) ; } }
import java . io . * ; class GFG { static double diff ( double n , double mid ) { if ( n > ( mid * mid * mid ) ) return ( n - ( mid * mid * mid ) ) ; else return ( ( mid * mid * mid ) - n ) ; } static double cubicRoot ( double n ) { double start = 0 , end = n ; double e = 0.0000001 ; while ( true ) { double mid = ( start + end ) / 2 ; double error = diff ( n , mid ) ; if ( error <= e ) return mid ; if ( ( mid * mid * mid ) > n ) end = mid ; else start = mid ; } } public static void main ( String [ ] args ) { double n = 3 ; System . out . println ( " Cube ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + cubicRoot ( n ) ) ; } }
class GFG { static int getMin ( int arr [ ] , int i , int n ) { return ( n == 1 ) ? arr [ i ] : Math . min ( arr [ i ] , getMin ( arr , i + 1 , n - 1 ) ) ; } static int getMax ( int arr [ ] , int i , int n ) { return ( n == 1 ) ? arr [ i ] : Math . max ( arr [ i ] , getMax ( arr , i + 1 , n - 1 ) ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 1234 , 45 , 67 , 1 } ; int n = arr . length ; System . out . print ( " Minimum ▁ element ▁ of ▁ array : ▁ " + getMin ( arr , 0 , n ) + " \n " ) ; System . out . println ( " Maximum ▁ element ▁ of ▁ array : ▁ " + getMax ( arr , 0 , n ) ) ; } }
import java . io . * ; class GFG { public static void printPascal ( int n ) { for ( int line = 1 ; line <= n ; line ++ ) { int C = 1 ; for ( int i = 1 ; i <= line ; i ++ ) { System . out . print ( C + " ▁ " ) ; C = C * ( line - i ) / i ; } System . out . println ( ) ; } } public static void main ( String [ ] args ) { int n = 5 ; printPascal ( n ) ; } }
import java . util . Arrays ; class GFG { static void fillWithFreq ( int arr [ ] , int n ) { int temp [ ] = new int [ n ] ; Arrays . fill ( temp , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) temp [ arr [ i ] ] += 1 ; for ( int i = 0 ; i < n ; i ++ ) arr [ i ] = temp [ i ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 4 , 5 , 5 , 4 , 5 , 6 , 7 } ; int n = arr . length ; fillWithFreq ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
class GFG { public static void main ( String [ ] args ) { String str = " Mr ▁ John ▁ Smith ▁ ▁ ▁ " ; str = str . trim ( ) ; str = str . replaceAll ( " \\ s " , " % 20" ) ; System . out . println ( str ) ; } }
import java . util . * ; class GFG { static int cntgloves ( int arr [ ] , int n ) { int count = 0 ; Arrays . sort ( arr ) ; for ( int i = 0 ; i < n - 1 😉 { if ( arr [ i ] == arr [ i + 1 ] ) { count ++ ; i = i + 2 ; } else { i ++ ; } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 6 , 5 , 2 , 3 , 5 , 2 , 2 , 1 } ; int n = arr . length ; System . out . println ( cntgloves ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int inversegrayCode ( int n ) { int inv = 0 ; for ( ; n != 0 ; n = n >> 1 ) inv ^= n ; return inv ; } public static void main ( String [ ] args ) { int n = 15 ; System . out . println ( inversegrayCode ( n ) ) ; } }
import java . util . * ; class GFG { static boolean isPerfectSquare ( int [ ] arr , int n ) { HashMap < Integer , Integer > umap = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( umap . containsKey ( arr [ i ] ) ) umap . put ( arr [ i ] , umap . get ( arr [ i ] ) + 1 ) ; else umap . put ( arr [ i ] , 1 ) ; } Iterator < Map . Entry < Integer , Integer > > iterator = umap . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < Integer , Integer > entry = iterator . next ( ) ; if ( entry . getValue ( ) % 2 == 1 ) return false ; } return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 2 , 7 , 7 } ; int n = arr . length ; if ( isPerfectSquare ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void findPairs ( int arr [ ] , int n ) { int cntEven = 0 , cntOdd = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] % 2 == 0 ) cntEven ++ ; else cntOdd ++ ; } int evenPairs = 0 ; evenPairs += ( ( cntEven * ( cntEven - 1 ) ) / 2 ) ; evenPairs += ( ( cntOdd * ( cntOdd - 1 ) ) / 2 ) ; int oddPairs = 0 ; oddPairs += ( cntEven * cntOdd ) ; System . out . println ( " Odd ▁ pairs ▁ = ▁ " + oddPairs ) ; System . out . println ( " Even ▁ pairs ▁ = ▁ " + evenPairs ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int n = arr . length ; findPairs ( arr , n ) ; } }
class GFG { static void shuffle ( int N , int key ) { int NO_OF_BITS = N ; int reverse_num = 0 , temp ; for ( int i = 0 ; i < NO_OF_BITS ; i ++ ) { temp = ( key & ( 1 << i ) ) ; if ( temp > 0 ) reverse_num |= ( 1 << ( ( NO_OF_BITS - 1 ) - i ) ) ; } System . out . print ( reverse_num ) ; } public static void main ( String [ ] args ) { int N = 3 ; int key = 3 ; shuffle ( N , key ) ; } }
public class Subarray_Inversions { static int inversion_count ( int n , int k , int [ ] a ) { int count = 0 ; for ( int start = 0 ; start < n - k + 1 ; start ++ ) { int end = start + k ; count += bubble_count ( a , start , end ) ; } return count ; } public static int bubble_count ( int [ ] arr , int start , int end ) { int count = 0 ; for ( int i = start ; i < end ; i ++ ) { for ( int j = i + 1 ; j < end ; j ++ ) { if ( arr [ i ] > arr [ j ] ) { count ++ ; } } } return count ; } public static void main ( String [ ] args ) { int n = 10 ; int [ ] arr = { 15 , 51 , 44 , 44 , 76 , 50 , 29 , 88 , 48 , 50 } ; int k = 5 ; long result = inversion_count ( n , k , arr ) ; System . out . println ( result ) ; } }
import java . io . * ; class GFG { static void _printParenthesis ( char str [ ] , int pos , int n , int open , int close ) { if ( close == n ) { for ( int i = 0 ; i < str . length ; i ++ ) System . out . print ( str [ i ] ) ; System . out . println ( ) ; return ; } else { if ( open > close ) { str [ pos ] = ' } ' ; _printParenthesis ( str , pos + 1 , n , open , close + 1 ) ; } if ( open < n ) { str [ pos ] = ' { ' ; _printParenthesis ( str , pos + 1 , n , open + 1 , close ) ; } } } static void printParenthesis ( char str [ ] , int n ) { if ( n > 0 ) _printParenthesis ( str , 0 , n , 0 , 0 ) ; return ; } public static void main ( String [ ] args ) { int n = 3 ; char [ ] str = new char [ 2 * n ] ; printParenthesis ( str , n ) ; } }
import java . io . * ; class GFG { static int fun ( int x ) { int y = ( x / 4 ) * 4 ; int ans = 0 ; for ( int i = y ; i <= x ; i ++ ) ans ^= i ; return ans ; } static int query ( int x ) { if ( x == 0 ) return 0 ; int k = ( x + 1 ) / 2 ; return ( ( x %= 2 ) != 0 ) ? 2 * fun ( k ) : ( ( fun ( k - 1 ) * 2 ) ^ ( k & 1 ) ) ; } static void allQueries ( int q , int l [ ] , int r [ ] ) { for ( int i = 0 ; i < q ; i ++ ) System . out . println ( ( query ( r [ i ] ) ^ query ( l [ i ] - 1 ) ) ) ; } public static void main ( String [ ] args ) { int q = 3 ; int [ ] l = { 2 , 2 , 5 } ; int [ ] r = { 4 , 8 , 9 } ; allQueries ( q , l , r ) ; } }
class GFG { static String isDivisible ( long n ) { long temp = n ; int sum = 0 ; while ( n != 0 ) { int k = ( int ) n % 10 ; sum += k ; n /= 10 ; } if ( temp % sum == 0 ) return " YES " ; return " NO " ; } public static void main ( String [ ] args ) { long n = 123 ; System . out . println ( isDivisible ( n ) ) ; } }
import java . io . * ; class GFG { static void find ( int n , int m ) { if ( n <= 2 * m ) System . out . println ( " Minimum ▁ " + 0 ) ; else System . out . println ( " Minimum ▁ " + ( n - 2 * m ) ) ; int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i * ( i - 1 ) / 2 >= m ) break ; } System . out . println ( " Maximum ▁ " + ( n - i ) ) ; } public static void main ( String [ ] args ) { int n = 4 ; int m = 2 ; find ( n , m ) ; } }
class GfG { static boolean isVowel ( char c ) { if ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) return true ; return false ; } static boolean checkPossibility ( String s1 , String s2 ) { int l1 = s1 . length ( ) ; int l2 = s2 . length ( ) ; if ( l1 != l2 ) return false ; for ( int i = 0 ; i < l1 ; i ++ ) { if ( isVowel ( s1 . charAt ( i ) ) && isVowel ( s2 . charAt ( i ) ) ) continue ; else if ( ! ( isVowel ( s1 . charAt ( i ) ) ) && ! ( isVowel ( s2 . charAt ( i ) ) ) ) continue ; else return false ; } return true ; } public static void main ( String [ ] args ) { String S1 = " abcgle " ; String S2 = " ezggli " ; if ( checkPossibility ( S1 , S2 ) == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { static void findNthTerm ( int N ) { int ans ; if ( N % 2 == 0 ) { ans = ( N / 2 ) * 6 + ( N / 2 ) * 2 ; } else { ans = ( N / 2 + 1 ) * 6 + ( N / 2 ) * 2 ; } System . out . print ( ans + " \n " ) ; } public static void main ( String [ ] args ) { int N = 3 ; findNthTerm ( N ) ; } }
import java . io . * ; class GFG { static int N = 4 ; static void multiply ( int mat1 [ ] [ ] , int mat2 [ ] [ ] , int res [ ] [ ] ) { int i , j , k ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) { res [ i ] [ j ] = 0 ; for ( k = 0 ; k < N ; k ++ ) res [ i ] [ j ] += mat1 [ i ] [ k ] * mat2 [ k ] [ j ] ; } } } public static void main ( String [ ] args ) { int mat1 [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int mat2 [ ] [ ] = { { 1 , 1 , 1 , 1 } , { 2 , 2 , 2 , 2 } , { 3 , 3 , 3 , 3 } , { 4 , 4 , 4 , 4 } } ; int res [ ] [ ] = new int [ N ] [ N ] ; int i , j ; multiply ( mat1 , mat2 , res ) ; System . out . println ( " Result ▁ matrix " + " ▁ is ▁ " ) ; for ( i = 0 ; i < N ; i ++ ) { for ( j = 0 ; j < N ; j ++ ) System . out . print ( res [ i ] [ j ] + " ▁ " ) ; System . out . println ( ) ; } } }
import java . io . * ; class GFG { static int [ ] dp = new int [ 1024 ] ; static int get_binary ( int u ) { int ans = 0 ; while ( u > 0 ) { int rem = u % 10 ; ans |= ( 1 << rem ) ; u /= 10 ; } return ans ; } static int recur ( int u , int [ ] array , int n ) { if ( u == 0 ) return 0 ; if ( dp [ u ] != - 1 ) return dp [ u ] ; for ( int i = 0 ; i < n ; i ++ ) { int mask = get_binary ( array [ i ] ) ; if ( ( mask | u ) == u ) { dp [ u ] = Math . max ( Math . max ( 0 , dp [ u ^ mask ] ) + array [ i ] , dp [ u ] ) ; } } return dp [ u ] ; } static int solve ( int [ ] array , int n ) { for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { dp [ i ] = - 1 ; } int ans = 0 ; for ( int i = 0 ; i < ( 1 << 10 ) ; i ++ ) { ans = Math . max ( ans , recur ( i , array , n ) ) ; } return ans ; } static public void main ( String [ ] args ) { int [ ] array = { 22 , 132 , 4 , 45 , 12 , 223 } ; int n = array . length ; System . out . println ( solve ( array , n ) ) ; } }
import java . io . * ; class GFG { static int findSum ( int N , int K ) { int ans = 0 ; int y = N / K ; int x = N % K ; ans = ( K * ( K - 1 ) / 2 ) * y + ( x * ( x + 1 ) ) / 2 ; return ans ; } static public void main ( String [ ] args ) { int N = 10 , K = 2 ; System . out . println ( findSum ( N , K ) ) ; } }
import java . io . * ; class GFG { static int decimalToBinary ( int N ) { int B_Number = 0 ; int cnt = 0 ; while ( N != 0 ) { int rem = N % 2 ; double c = Math . pow ( 10 , cnt ) ; B_Number += rem * c ; N /= 2 ; cnt ++ ; } return B_Number ; } public static void main ( String [ ] args ) { int N = 17 ; System . out . println ( decimalToBinary ( N ) ) ; } }
public class GFG { static boolean isTriPerfect ( int n ) { int sum = 1 + n ; int i = 2 ; while ( i * i <= n ) { if ( n % i == 0 ) { if ( n / i == i ) sum = sum + i ; else sum = sum + i + n / i ; } i += 1 ; } if ( sum == 3 * n & n != 1 ) return true ; else return false ; } public static void main ( String [ ] args ) { int n = 120 ; if ( isTriPerfect ( n ) ) System . out . println ( n + " ▁ is ▁ a ▁ Triperfect ▁ number " ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int xorEqualsOrCount ( int N ) { int count = 0 ; int bit ; while ( N > 0 ) { bit = N % 2 ; if ( bit == 0 ) count ++ ; N = N / 2 ; } return ( int ) Math . pow ( 2 , count ) ; } public static void main ( String args [ ] ) { int N = 7 ; System . out . println ( xorEqualsOrCount ( N ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static boolean judgeSquareSum ( int c ) { for ( long a = 0 ; a * a <= c ; a ++ ) { int b = c - ( int ) ( a * a ) ; if ( binary_search ( 0 , b , b ) ) return true ; } return false ; } public static boolean binary_search ( long s , long e , int n ) { if ( s > e ) return false ; long mid = s + ( e - s ) / 2 ; if ( mid * mid == n ) return true ; if ( mid * mid > n ) return binary_search ( s , mid - 1 , n ) ; return binary_search ( mid + 1 , e , n ) ; } public static void main ( String argc [ ] ) { int c = 17 ; System . out . println ( judgeSquareSum ( c ) ) ; } }
class GFG { static boolean isOdd ( int [ ] arr , int n ) { int l , r , flag = 0 , flag1 = 0 , sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { sum += arr [ i ] ; if ( arr [ i ] % 2 == 0 && flag == 0 ) { flag = 1 ; l = arr [ i ] ; } if ( arr [ i ] % 2 != 0 && flag1 == 0 ) { r = arr [ i ] ; flag1 = 1 ; } } if ( sum % 2 != 0 ) { return true ; } else { if ( flag1 == 1 && flag == 1 ) return true ; else return false ; } } public static void main ( String [ ] args ) { int ar [ ] = { 5 , 4 , 4 , 5 , 1 , 3 } ; int n = ar . length ; boolean res = isOdd ( ar , n ) ; if ( res == true ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int nthTerm ( int n ) { return 3 * ( int ) Math . pow ( n , 2 ) + 2 * n - 5 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( nthTerm ( N ) ) ; } }
import java . util . * ; class GFG { static int MAX = 26 ; static String smallestStr ( char [ ] str , int n ) { int i , j = 0 ; int [ ] chk = new int [ MAX ] ; for ( i = 0 ; i < MAX ; i ++ ) chk [ i ] = - 1 ; for ( i = 0 ; i < n ; i ++ ) { if ( chk [ str [ i ] - ' a ' ] == - 1 ) chk [ str [ i ] - ' a ' ] = i ; } for ( i = 0 ; i < n ; i ++ ) { boolean flag = false ; for ( j = 0 ; j < str [ i ] - ' a ' ; j ++ ) { if ( chk [ j ] > chk [ str [ i ] - ' a ' ] ) { flag = true ; break ; } } if ( flag ) break ; } if ( i < n ) { char ch1 = str [ i ] ; char ch2 = ( char ) ( j + ' a ' ) ; for ( i = 0 ; i < n ; i ++ ) { if ( str [ i ] == ch1 ) str [ i ] = ch2 ; else if ( str [ i ] == ch2 ) str [ i ] = ch1 ; } } return String . valueOf ( str ) ; } public static void main ( String [ ] args ) { String str = " ccad " ; int n = str . length ( ) ; System . out . println ( smallestStr ( str . toCharArray ( ) , n ) ) ; } }
import java . util . * ; class GFG { static int N = 3 ; static int numberOfCells ( int mat [ ] [ ] ) { boolean [ ] [ ] row = new boolean [ N ] [ N ] ; boolean [ ] [ ] col = new boolean [ N ] [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = N - 1 ; j >= 0 ; j -- ) { if ( mat [ i ] [ j ] == 1 ) { row [ i ] [ j ] = ( j + 1 < N ) ? row [ i ] [ j + 1 ] : true ; } else { row [ i ] [ j ] = false ; } } } for ( int j = 0 ; j < N ; j ++ ) { for ( int i = N - 1 ; i >= 0 ; i -- ) { if ( mat [ i ] [ j ] == 1 ) { col [ i ] [ j ] = ( i + 1 < N ) ? col [ i + 1 ] [ j ] : true ; } else { col [ i ] [ j ] = false ; } } } int cnt = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ i ] [ j ] && col [ i ] [ j ] ) { cnt ++ ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( col [ i ] [ N - 1 ] ) cnt ++ ; } for ( int j = 0 ; j < N - 1 ; j ++ ) { if ( row [ N - 1 ] [ j ] ) cnt ++ ; } return cnt ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 0 , 1 , 1 } , { 0 , 1 , 1 } , { 0 , 1 , 1 } } ; System . out . print ( numberOfCells ( mat ) ) ; } }
class GFG { static void printRLE ( String s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { int count = 1 ; while ( i + 1 < s . length ( ) && s . charAt ( i ) == s . charAt ( i + 1 ) ) { i ++ ; count ++ ; } System . out . print ( s . charAt ( i ) + " " + count + " ▁ " ) ; } System . out . println ( ) ; } public static void main ( String args [ ] ) { printRLE ( " GeeeEEKKKss " ) ; printRLE ( " ccccOddEEE " ) ; } }
import java . util . HashMap ; class Test { static int arr [ ] = new int [ ] { 1 , 5 , 7 , - 1 , 5 } ; static int getPairsCount ( int n , int sum ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( ! hm . containsKey ( arr [ i ] ) ) hm . put ( arr [ i ] , 0 ) ; hm . put ( arr [ i ] , hm . get ( arr [ i ] ) + 1 ) ; } int twice_count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( hm . get ( sum - arr [ i ] ) != null ) twice_count += hm . get ( sum - arr [ i ] ) ; if ( sum - arr [ i ] == arr [ i ] ) twice_count -- ; } return twice_count / 2 ; } public static void main ( String [ ] args ) { int sum = 6 ; System . out . println ( " Count ▁ of ▁ pairs ▁ is ▁ " + getPairsCount ( arr . length , sum ) ) ; } }
class GFG { public static void main ( String [ ] args ) { int matrix [ ] [ ] = new int [ 5 ] [ 5 ] , row_index , column_index , x = 0 , size = 5 ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { matrix [ row_index ] [ column_index ] = ++ x ; } } System . out . printf ( " The ▁ matrix ▁ is \n " ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { System . out . printf ( " % d\t " , matrix [ row_index ] [ column_index ] ) ; } System . out . printf ( " \n " ) ; } System . out . printf ( " \n Boundary ▁ Elements ▁ are : \n " ) ; for ( row_index = 0 ; row_index < size ; row_index ++ ) { for ( column_index = 0 ; column_index < size ; column_index ++ ) { if ( ( row_index == 0 || row_index == size - 1 || column_index == 0 || column_index == size - 1 ) ) { System . out . printf ( " % d , ▁ " , matrix [ row_index ] [ column_index ] ) ; } } } } }
class GFG { public static boolean isPrime ( char c ) { return ( c == '2' || c == '3' || c == '5' || c == '7' ) ; } public static void decrease ( StringBuilder s , int i ) { if ( s . charAt ( i ) <= '2' ) { s . deleteCharAt ( i ) ; s . setCharAt ( i , '7' ) ; } else if ( s . charAt ( i ) == '3' ) s . setCharAt ( i , '2' ) ; else if ( s . charAt ( i ) <= '5' ) s . setCharAt ( i , '3' ) ; else if ( s . charAt ( i ) <= '7' ) s . setCharAt ( i , '5' ) ; else s . setCharAt ( i , '7' ) ; return ; } public static String primeDigits ( StringBuilder s ) { for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( ! isPrime ( s . charAt ( i ) ) ) { while ( i >= 0 && s . charAt ( i ) <= '2' ) i -- ; if ( i < 0 ) { i = 0 ; decrease ( s , i ) ; } else decrease ( s , i ) ; for ( int j = i + 1 ; j < s . length ( ) ; j ++ ) s . setCharAt ( j , '7' ) ; break ; } } return s . toString ( ) ; } public static void main ( String [ ] args ) { StringBuilder s = new StringBuilder ( "45" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "1000" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "7721" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "7221" ) ; System . out . println ( primeDigits ( s ) ) ; s = new StringBuilder ( "74545678912345689748593275897894708927680" ) ; System . out . println ( primeDigits ( s ) ) ; } }
import java . io . * ; class GFG { static int N = 1000005 ; static int primeFactors [ ] = new int [ N ] ; static void findPrimeFactors ( ) { for ( int i = 2 ; i < N ; i ++ ) if ( primeFactors [ i ] == 0 ) for ( int j = i ; j < N ; j += i ) primeFactors [ j ] = primeFactors [ j / i ] + 1 ; for ( int i = 1 ; i < N ; i ++ ) primeFactors [ i ] += primeFactors [ i - 1 ] ; } public static void main ( String [ ] args ) { findPrimeFactors ( ) ; int a = 6 , b = 3 ; System . out . println ( primeFactors [ a ] - primeFactors [ b ] ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void findNDigitNumsUtil ( int n , char out [ ] , int index , int evenSum , int oddSum ) { if ( index > n ) return ; if ( index == n ) { if ( Math . abs ( evenSum - oddSum ) == 1 ) { out [ index ] = '';  System . out . print ( out ) ; System . out . print ( " ▁ " ) ; } return ; } if ( index % 2 != 0 ) { for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum , oddSum + i ) ; } } else { for ( int i = 0 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } } static void findNDigitNums ( int n ) { char [ ] out = new char [ n + 1 ] ; int index = 0 ; int evenSum = 0 , oddSum = 0 ; for ( int i = 1 ; i <= 9 ; i ++ ) { out [ index ] = ( char ) ( i + '0' ) ; findNDigitNumsUtil ( n , out , index + 1 , evenSum + i , oddSum ) ; } } public static void main ( String [ ] args ) { int n = 3 ; findNDigitNums ( n ) ; } }
import java . util . Arrays ; import java . io . * ; class GFG { static int ksmallest ( int arr [ ] , int n , int k ) { Arrays . sort ( arr ) ; if ( k < arr [ 0 ] ) return k ; if ( k == arr [ 0 ] ) return arr [ 0 ] + 1 ; if ( k > arr [ n - 1 ] ) return k + n ; if ( arr [ 0 ] == 1 ) k -- ; else k -= ( arr [ 0 ] - 1 ) ; for ( int i = 1 ; i < n ; i ++ ) { int c = arr [ i ] - arr [ i - 1 ] - 1 ; if ( k <= c ) return arr [ i - 1 ] + k ; else k -= c ; } return arr [ n - 1 ] + k ; } public static void main ( String [ ] args ) { int k = 1 ; int arr [ ] = { 1 } ; int n = arr . length ; System . out . println ( ksmallest ( arr , n , k ) ) ; } }
import java . util . * ; class Solution { static class NodeDetails { int data ; int min , max ; } ; static boolean levelOrderIsOfBST ( int arr [ ] , int n ) { if ( n == 0 ) return true ; Queue < NodeDetails > q = new LinkedList < NodeDetails > ( ) ; int i = 0 ; NodeDetails newNode = new NodeDetails ( ) ; newNode . data = arr [ i ++ ] ; newNode . min = Integer . MIN_VALUE ; newNode . max = Integer . MAX_VALUE ; q . add ( newNode ) ; while ( i != n && q . size ( ) > 0 ) { NodeDetails temp = q . peek ( ) ; q . remove ( ) ; newNode = new NodeDetails ( ) ; if ( i < n && ( arr [ i ] < ( int ) temp . data && arr [ i ] > ( int ) temp . min ) ) { newNode . data = arr [ i ++ ] ; newNode . min = temp . min ; newNode . max = temp . data ; q . add ( newNode ) ; } newNode = new NodeDetails ( ) ; if ( i < n && ( arr [ i ] > ( int ) temp . data && arr [ i ] < ( int ) temp . max ) ) { newNode . data = arr [ i ++ ] ; newNode . min = temp . data ; newNode . max = temp . max ; q . add ( newNode ) ; } } if ( i == n ) return true ; return false ; } public static void main ( String args [ ] ) { int arr [ ] = { 7 , 4 , 12 , 3 , 6 , 8 , 1 , 5 , 10 } ; int n = arr . length ; if ( levelOrderIsOfBST ( arr , n ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
class GFG { public static void main ( String args [ ] ) { int marks [ ] = { 25 , 65 , 46 , 98 , 78 , 65 } ; int max_marks = marks . length * 100 ; int total = 0 ; char grade = ' F ' ; for ( int i = 0 ; i < marks . length ; i ++ ) { total += marks [ i ] ; } double percentage = ( ( double ) ( total ) / max_marks ) * 100 ; if ( percentage >= 90 ) { grade = ' A ' ; } else { if ( percentage >= 80 && percentage <= 89 ) { grade = ' B ' ; } else { if ( percentage >= 60 && percentage <= 79 ) { grade = ' C ' ; } else { if ( percentage >= 33 && percentage <= 59 ) { grade = ' D ' ; } else { grade = ' F ' ; } } } } System . out . println ( grade ) ; } }
import java . io . * ; class GFG { static void printPartition ( int n , int m ) { int k = n / m ; int ct = n % m ; int i ; for ( i = 1 ; i <= ct ; i ++ ) System . out . print ( k + 1 + " ▁ " ) ; for ( ; i <= m ; i ++ ) System . out . print ( k + " ▁ " ) ; } public static void main ( String [ ] args ) { int n = 5 , m = 2 ; printPartition ( n , m ) ; } }
class GFG { static int prevComplement ( int n , int b ) { int maxDigit , maxNum = 0 , digits = 0 , num = n ; while ( n != 0 ) { digits ++ ; n = n / 10 ; } maxDigit = b - 1 ; while ( ( digits -- ) > 0 ) { maxNum = maxNum * 10 + maxDigit ; } return maxNum - num ; } static int complement ( int n , int b ) { return prevComplement ( n , b ) + 1 ; } public static void main ( String args [ ] ) { System . out . println ( prevComplement ( 25 , 7 ) ) ; System . out . println ( complement ( 25 , 7 ) ) ; } }
class GFG { static int N = 1000 ; static int countPairs ( int arr [ ] , int n ) { int size = ( 2 * N ) + 1 ; int freq [ ] = new int [ size ] ; for ( int i = 0 ; i < n ; i ++ ) { int x = arr [ i ] ; freq [ x + N ] ++ ; } int ans = 0 ; for ( int i = 0 ; i < size ; i ++ ) { if ( freq [ i ] > 0 ) { ans += ( ( freq [ i ] ) * ( freq [ i ] - 1 ) ) / 2 ; for ( int j = i + 2 ; j < 2001 ; j += 2 ) { if ( freq [ j ] > 0 && ( freq [ ( i + j ) / 2 ] > 0 ) ) { ans += ( freq [ i ] * freq [ j ] ) ; } } } } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 2 , 5 , 1 , 3 , 5 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . io . * ; public class GFG { static int countToMake0lternate ( String s ) { int result = 0 ; for ( int i = 0 ; i < ( s . length ( ) - 1 ) ; i ++ ) if ( s . charAt ( i ) == s . charAt ( i + 1 ) ) result ++ ; return result ; } static public void main ( String [ ] args ) { System . out . println ( countToMake0lternate ( "000111" ) ) ; System . out . println ( countToMake0lternate ( "11111" ) ) ; System . out . println ( countToMake0lternate ( "01010101" ) ) ; } }
class GFG { static void numOfSubseq ( int arr [ ] , int n ) { int i , inc_count , dec_count ; int max [ ] = new int [ n ] ; int min [ ] = new int [ n ] ; int k1 = 0 , k2 = 0 ; if ( arr [ 0 ] < arr [ 1 ] ) min [ k1 ++ ] = 0 ; else max [ k2 ++ ] = 0 ; for ( i = 1 ; i < n - 1 ; i ++ ) { if ( arr [ i ] < arr [ i - 1 ] && arr [ i ] < arr [ i + 1 ] ) min [ k1 ++ ] = i ; if ( arr [ i ] > arr [ i - 1 ] && arr [ i ] > arr [ i + 1 ] ) max [ k2 ++ ] = i ; } if ( arr [ n - 1 ] < arr [ n - 2 ] ) min [ k1 ++ ] = n - 1 ; else max [ k2 ++ ] = n - 1 ; if ( min [ 0 ] == 0 ) { inc_count = k2 ; dec_count = k1 - 1 ; } else { inc_count = k2 - 1 ; dec_count = k1 ; } System . out . println ( " Increasing ▁ Subsequence " + " ▁ Count : ▁ " + inc_count ) ; System . out . println ( " Decreasing ▁ Subsequence " + " ▁ Count : ▁ " + dec_count ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 12 , 8 , 11 , 13 , 10 , 15 , 14 , 16 , 20 } ; int n = arr . length ; numOfSubseq ( arr , n ) ; } }
public class gfg { static int N = 10000 ; static long arr [ ] = new long [ N ] ; static void seive ( ) { for ( int i = 2 ; i * i < N ; i ++ ) { if ( arr [ i ] == 0 ) { for ( int j = 2 ; i * j < N ; j ++ ) { arr [ i * j ] += i ; } } } } static long sum ( int l , int r ) { seive ( ) ; long [ ] pref_arr = new long [ r + 1 ] ; pref_arr [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i <= r ; i ++ ) { pref_arr [ i ] = pref_arr [ i - 1 ] + arr [ i ] ; } if ( l == 1 ) return ( pref_arr [ r ] ) ; else return ( pref_arr [ r ] - pref_arr [ l - 1 ] ) ; } public static void main ( String [ ] args ) { int l = 5 , r = 10 ; System . out . println ( sum ( l , r ) ) ; } }
import java . lang . * ; class GFG { static double PI = 3.14159265 ; public static double area_cicumscribed ( double c ) { return ( c * c * ( PI / 4 ) ) ; } public static void main ( String [ ] args ) { double c = 8.0 ; System . out . println ( area_cicumscribed ( c ) ) ; } }
import java . util . * ; class GFG { static int N = 3 ; static int M = 3 ; static int majorityInMatrix ( int arr [ ] [ ] ) { HashMap < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mp . containsKey ( arr [ i ] [ j ] ) ) mp . put ( arr [ i ] [ j ] , mp . get ( arr [ i ] [ j ] ) + 1 ) ; else mp . put ( arr [ i ] [ j ] , 1 ) ; } } int countMajority = 0 ; Iterator < HashMap . Entry < Integer , Integer > > itr = mp . entrySet ( ) . iterator ( ) ; while ( itr . hasNext ( ) ) { HashMap . Entry < Integer , Integer > entry = itr . next ( ) ; if ( entry . getValue ( ) >= ( ( N * M ) / 2 ) ) { countMajority ++ ; } } return countMajority ; } public static void main ( String [ ] args ) { int mat [ ] [ ] = { { 1 , 2 , 2 } , { 1 , 3 , 2 } , { 1 , 2 , 6 } } ; System . out . println ( majorityInMatrix ( mat ) ) ; } }
class GFG { static void printSumSeries ( int N ) { float sum = 0 ; for ( int i = 1 ; i <= N ; i ++ ) { sum += 1.0 / ( 2 * i - 1 ) ; } System . out . println ( sum ) ; } public static void main ( String [ ] args ) { int N = 6 ; printSumSeries ( N ) ; } }
class GFG { static int deleteElement ( int A [ ] , int L , int R , int N ) { int i , j = 0 ; for ( i = 0 ; i < N ; i ++ ) { if ( i <= L || i >= R ) { A [ j ] = A [ i ] ; j ++ ; } } return j ; } public static void main ( String args [ ] ) { int A [ ] = new int [ ] { 5 , 8 , 11 , 15 , 26 , 14 , 19 , 17 , 10 , 14 } ; int L = 2 , R = 7 ; int n = A . length ; int res_size = deleteElement ( A , L , R , n ) ; for ( int i = 0 ; i < res_size ; i ++ ) System . out . print ( A [ i ] + " ▁ " ) ; } }
import java . util . * ; class GFG { static boolean areElementsContiguous ( int arr [ ] , int n ) { Arrays . sort ( arr ) ; for ( int i = 1 ; i < n ; i ++ ) if ( arr [ i ] - arr [ i - 1 ] > 1 ) return false ; return true ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 2 , 3 , 6 , 4 , 4 , 6 , 6 } ; int n = arr . length ; if ( areElementsContiguous ( arr , n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
class GFG { final static int maxin = 10001 ; static int divisors [ ] = new int [ maxin + 1 ] ; static void Calc_Max_Div ( int arr [ ] , int n ) { int vis [ ] = new int [ maxin + 1 ] ; for ( int i = 0 ; i < maxin + 1 ; i ++ ) vis [ i ] = 1 ; vis [ 0 ] = vis [ 1 ] = 0 ; for ( int i = 1 ; i <= maxin ; i ++ ) divisors [ i ] = i ; for ( int i = 4 ; i <= maxin ; i += 2 ) { vis [ i ] = 0 ; divisors [ i ] = i / 2 ; } for ( int i = 3 ; i <= maxin ; i += 2 ) { if ( divisors [ i ] != i ) { divisors [ i ] = i / divisors [ i ] ; } if ( vis [ i ] == 1 ) { for ( int j = i * i ; j < maxin ; j += i ) { vis [ j ] = 0 ; if ( divisors [ j ] == j ) divisors [ j ] = i ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( divisors [ arr [ i ] ] == arr [ i ] ) System . out . print ( " - 1 ▁ " ) ; else System . out . print ( divisors [ arr [ i ] ] + " ▁ " ) ; } } public static void main ( String [ ] args ) { int [ ] arr = { 5 , 6 , 7 , 8 , 9 , 10 } ; int n = arr . length ; Calc_Max_Div ( arr , n ) ; } }
class GFG { static int MAX = 100000 ; static int sequence [ ] = new int [ MAX + 1 ] ; static void vanEckSequence ( ) { for ( int i = 0 ; i < MAX ; i ++ ) { sequence [ i ] = 0 ; } for ( int i = 0 ; i < MAX ; i ++ ) { for ( int j = i - 1 ; j >= 0 ; j -- ) { if ( sequence [ j ] == sequence [ i ] ) { sequence [ i + 1 ] = i - j ; break ; } } } } static int getCount ( int n ) { int count = 1 ; int i = n - 1 ; while ( sequence [ i + 1 ] != 0 ) { count ++ ; i = i - sequence [ i + 1 ] ; } return count ; } public static void main ( String [ ] args ) { vanEckSequence ( ) ; int n = 5 ; System . out . println ( getCount ( n ) ) ; n = 11 ; System . out . println ( getCount ( n ) ) ; } }
class GFG { static int countGreater ( int arr [ ] , int n , int k ) { int l = 0 ; int r = n - 1 ; int leftGreater = n ; while ( l <= r ) { int m = l + ( r - l ) / 2 ; if ( arr [ m ] > k ) { leftGreater = m ; r = m - 1 ; } else l = m + 1 ; } return ( n - leftGreater ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 4 , 7 , 7 , 7 , 11 , 13 , 13 } ; int n = arr . length ; int k = 7 ; System . out . println ( countGreater ( arr , n , k ) ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static int counLastDigitK ( int low , int high , int k ) { int count = ( high - low ) / 10 ; if ( high % 10 >= k ) count ++ ; if ( low % 10 > k ) count -- ; return count ; } public static void main ( String argc [ ] ) { int low = 3 , high = 35 , k = 3 ; System . out . println ( counLastDigitK ( low , high , k ) ) ; } }
class GFG { static boolean squareRootExists ( int n , int p ) { n = n % p ; for ( int x = 2 ; x < p ; x ++ ) if ( ( x * x ) % p == n ) return true ; return false ; } public static void main ( String [ ] args ) { int p = 7 ; int n = 2 ; if ( squareRootExists ( n , p ) ) System . out . print ( " Yes " ) ; else System . out . print ( " No " ) ; } }
public class GFG { public static long findWays ( int f , int d , int s ) { long mem [ ] [ ] = new long [ d + 1 ] [ s + 1 ] ; mem [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= d ; i ++ ) { for ( int j = i ; j <= s ; j ++ ) { mem [ i ] [ j ] = mem [ i ] [ j - 1 ] + mem [ i - 1 ] [ j - 1 ] ; if ( j - f - 1 >= 0 ) mem [ i ] [ j ] -= mem [ i - 1 ] [ j - f - 1 ] ; } } return mem [ d ] [ s ] ; } public static void main ( String [ ] args ) { System . out . println ( findWays ( 4 , 2 , 1 ) ) ; System . out . println ( findWays ( 2 , 2 , 3 ) ) ; System . out . println ( findWays ( 6 , 3 , 8 ) ) ; System . out . println ( findWays ( 4 , 2 , 5 ) ) ; System . out . println ( findWays ( 4 , 3 , 5 ) ) ; } }
class GFG { static long nextFibonacci ( int n ) { double a = n * ( 1 + Math . sqrt ( 5 ) ) / 2.0 ; return Math . round ( a ) ; } public static void main ( String [ ] args ) { int n = 5 ; System . out . println ( nextFibonacci ( n ) ) ; } }
class GFG { static int maxLCM ( int n ) { return ( n * ( n - 1 ) ) ; } public static void main ( String [ ] args ) { int n = 3 ; System . out . println ( maxLCM ( n ) ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; for ( int i = 2 ; i < n ; i ++ ) if ( n % i == 0 ) return false ; return true ; } static void printPrime ( int n ) { for ( int i = 2 ; i <= n ; i ++ ) { if ( isPrime ( i ) ) System . out . print ( i + " ▁ " ) ; } } public static void main ( String [ ] args ) { int n = 7 ; printPrime ( n ) ; } }
import java . util . * ; class solution { static void divide ( int a , int b ) { for ( int i = 2 ; i <= Math . min ( a , b ) ; i ++ ) { while ( a % i == 0 && b % i == 0 ) { a = a / i ; b = b / i ; } } System . out . println ( " A ▁ = ▁ " + a + " , ▁ B ▁ = ▁ " + b ) ; } public static void main ( String args [ ] ) { int A = 10 , B = 15 ; divide ( A , B ) ; } }
import java . io . * ; class GFG { static void ReplaceElements ( int [ ] arr , int n ) { if ( n <= 1 ) return ; int prev = arr [ 0 ] ; arr [ 0 ] = arr [ 0 ] ^ arr [ 1 ] ; for ( int i = 1 ; i < n - 1 ; i ++ ) { int curr = arr [ i ] ; arr [ i ] = prev ^ arr [ i + 1 ] ; prev = curr ; } arr [ n - 1 ] = prev ^ arr [ n - 1 ] ; } public static void main ( String [ ] args ) { int [ ] arr = { 2 , 3 , 4 , 5 , 6 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } }
import java . util . * ; class GFG { static int countOne ( int n ) { int count = 0 ; while ( n > 0 ) { n = n & ( n - 1 ) ; count ++ ; } if ( count % 2 == 0 ) return 1 ; else return 0 ; } static int sumDigits ( int n ) { int sum = 0 ; while ( n != 0 ) { sum += n % 10 ; n /= 10 ; } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 4 , 9 , 15 } ; int n = arr . length ; int total_sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( countOne ( arr [ i ] ) == 1 ) total_sum += sumDigits ( arr [ i ] ) ; } System . out . println ( total_sum ) ; } }
class GFG { static long countPairs ( int [ ] arr , int n ) { int count_2 = 0 , count_others = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( arr [ i ] == 2 ) { count_2 ++ ; } else if ( arr [ i ] > 2 ) { count_others ++ ; } } long ans = 1L * count_2 * count_others + ( 1L * count_others * ( count_others - 1 ) ) / 2 ; return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 5 , 0 , 3 , 1 , 2 } ; int n = arr . length ; System . out . println ( countPairs ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int N = 3 ; static boolean checkCentrosymmetricted ( int n , int m [ ] [ ] ) { int mid_row ; if ( ( n & 1 ) > 0 ) mid_row = n / 2 + 1 ; else mid_row = n / 2 ; for ( int i = 0 ; i < mid_row ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( m [ i ] [ j ] != m [ n - i - 1 ] [ n - j - 1 ] ) return false ; } } return true ; } public static void main ( String [ ] args ) { int n = 3 ; int m [ ] [ ] = { { 1 , 3 , 5 } , { 6 , 8 , 6 } , { 5 , 3 , 1 } } ; if ( checkCentrosymmetricted ( n , m ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int MAX_LEN = 1005 ; static int MAX_CHAR = 26 ; static int [ ] [ ] cnt = new int [ MAX_LEN ] [ MAX_CHAR ] ; static void preProcess ( String s ) { int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) cnt [ i ] [ s . charAt ( i ) - ' a ' ] ++ ; for ( int i = 1 ; i < n ; i ++ ) { for ( int j = 0 ; j < 26 ; j ++ ) cnt [ i ] [ j ] += cnt [ i - 1 ] [ j ] ; } } static int findCharFreq ( int l , int r , char c ) { return ( cnt [ r ] [ ( c ) - 97 ] - cnt [ l ] [ ( c ) - 97 ] ) ; } public static void main ( String [ ] args ) { String s = " geeksforgeeks " ; int Q = 4 ; preProcess ( s ) ; System . out . println ( findCharFreq ( 0 , 5 , ' e ' ) ) ; System . out . println ( findCharFreq ( 2 , 6 , ' f ' ) ) ; System . out . println ( findCharFreq ( 4 , 7 , ' m ' ) ) ; System . out . println ( findCharFreq ( 0 , 12 , ' e ' ) ) ; } }
import java . util . * ; class GFG { static void minimumColors ( int N , int E , int U [ ] , int V [ ] ) { Vector < Integer > [ ] adj = new Vector [ N ] ; int [ ] count = new int [ N ] ; int [ ] colors = new int [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { adj [ i ] = new Vector < Integer > ( ) ; colors [ i ] = 1 ; } for ( int i = 0 ; i < N ; i ++ ) { adj [ V [ i ] - 1 ] . add ( U [ i ] - 1 ) ; count [ U [ i ] - 1 ] ++ ; } Queue < Integer > Q = new LinkedList < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( count [ i ] == 0 ) { Q . add ( i ) ; } } while ( ! Q . isEmpty ( ) ) { int u = Q . peek ( ) ; Q . remove ( ) ; for ( int x : adj [ u ] ) { count [ x ] -- ; if ( count [ x ] == 0 ) { Q . add ( x ) ; } if ( colors [ x ] <= colors [ u ] ) { colors [ x ] = 1 + colors [ u ] ; } } } int minColor = - 1 ; for ( int i = 0 ; i < N ; i ++ ) { minColor = Math . max ( minColor , colors [ i ] ) ; } System . out . print ( minColor + " \n " ) ; } public static void main ( String [ ] args ) { int N = 5 , E = 6 ; int U [ ] = { 1 , 2 , 3 , 1 , 2 , 3 } ; int V [ ] = { 3 , 3 , 4 , 4 , 5 , 5 } ; minimumColors ( N , E , U , V ) ; } }
import java . io . * ; import static java . lang . Math . * ; class Quadratic { void findRoots ( int a , int b , int c ) { if ( a == 0 ) { System . out . println ( " Invalid " ) ; return ; } int d = b * b - 4 * a * c ; double sqrt_val = sqrt ( abs ( d ) ) ; if ( d > 0 ) { System . out . println ( " Roots ▁ are ▁ real ▁ and ▁ different ▁ \n " ) ; System . out . println ( ( double ) ( - b + sqrt_val ) / ( 2 * a ) + " \n " + ( double ) ( - b - sqrt_val ) / ( 2 * a ) ) ; } else { System . out . println ( " Roots ▁ are ▁ complex ▁ \n " ) ; System . out . println ( - ( double ) b / ( 2 * a ) + " ▁ + ▁ i " + sqrt_val + " \n " + - ( double ) b / ( 2 * a ) + " ▁ - ▁ i " + sqrt_val ) ; } } public static void main ( String args [ ] ) { Quadratic obj = new Quadratic ( ) ; int a = 1 , b = - 7 , c = 12 ; obj . findRoots ( a , b , c ) ; } }
import java . util . * ; class GFG { static final int N = 3 ; static final int M = 3 ; static int sumOddOccurring ( int arr [ ] [ ] ) { Map < Integer , Integer > mp = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < M ; j ++ ) { if ( mp . get ( arr [ i ] [ j ] ) == null ) mp . put ( arr [ i ] [ j ] , 1 ) ; else mp . put ( arr [ i ] [ j ] , ( mp . get ( arr [ i ] [ j ] ) + 1 ) ) ; } } int sum = 0 ; Set < Map . Entry < Integer , Integer > > st = mp . entrySet ( ) ; for ( Map . Entry < Integer , Integer > me : st ) { if ( me . getValue ( ) % 2 == 0 ) { int x = me . getValue ( ) ; sum += ( me . getKey ( ) ) * ( me . getValue ( ) ) ; } } return sum ; } public static void main ( String args [ ] ) { int mat [ ] [ ] = { { 1 , 2 , 3 } , { 1 , 3 , 2 } , { 1 , 5 , 6 } } ; System . out . print ( sumOddOccurring ( mat ) ) ; } }
import java . util . * ; class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) { return false ; } if ( n <= 3 ) { return true ; } if ( n % 2 == 0 || n % 3 == 0 ) { return false ; } for ( int i = 5 ; i * i <= n ; i = i + 6 ) { if ( n % i == 0 || n % ( i + 2 ) == 0 ) { return false ; } } return true ; } static int power ( int x , int y , int p ) { int res = 1 ; x = x % p ; while ( y > 0 ) { if ( y % 2 == 1 ) { res = ( res * x ) % p ; } y = y >> 1 ; x = ( x * x ) % p ; } return res ; } static void findPrimefactors ( HashSet < Integer > s , int n ) { while ( n % 2 == 0 ) { s . add ( 2 ) ; n = n / 2 ; } for ( int i = 3 ; i <= Math . sqrt ( n ) ; i = i + 2 ) { while ( n % i == 0 ) { s . add ( i ) ; n = n / i ; } } if ( n > 2 ) { s . add ( n ) ; } } static int findPrimitive ( int n ) { HashSet < Integer > s = new HashSet < Integer > ( ) ; if ( isPrime ( n ) == false ) { return - 1 ; } int phi = n - 1 ; findPrimefactors ( s , phi ) ; for ( int r = 2 ; r <= phi ; r ++ ) { boolean flag = false ; for ( Integer a : s ) { if ( power ( r , phi / ( a ) , n ) == 1 ) { flag = true ; break ; } } if ( flag == false ) { return r ; } } return - 1 ; } public static void main ( String [ ] args ) { int n = 761 ; System . out . println ( " ▁ Smallest ▁ primitive ▁ root ▁ of ▁ " + n + " ▁ is ▁ " + findPrimitive ( n ) ) ; } }
class GFG { static final int max = 50009 ; static void find_Indices ( int arr [ ] , int n ) { int sum [ ] = new int [ max ] ; int index_1 , index_2 , index_3 , index ; int k , i ; for ( i = 1 , k = 0 ; i <= n ; i ++ ) sum [ i ] = sum [ i - 1 ] + arr [ k ++ ] ; double ans = - ( 1e15 ) ; index_1 = index_2 = index_3 = - 1 ; for ( int l = 0 ; l <= n ; l ++ ) { index = 0 ; double vmin = ( 1e15 ) ; for ( int r = l ; r <= n ; r ++ ) { if ( sum [ r ] < vmin ) { vmin = sum [ r ] ; index = r ; } if ( sum [ l ] + sum [ r ] - vmin > ans ) { ans = sum [ l ] + sum [ r ] - vmin ; index_1 = l ; index_2 = index ; index_3 = r ; } } } System . out . print ( index_1 + " ▁ " + index_2 + " ▁ " + index_3 ) ; } public static void main ( String [ ] args ) { int arr [ ] = { - 1 , 2 , 3 } ; int n = arr . length ; find_Indices ( arr , n ) ; } }
class GFG { static int countWays ( int n , int l , int r ) { int tL = l , tR = r ; int [ ] L = new int [ 3 ] ; int [ ] R = new int [ 3 ] ; L [ l % 2 ] = l ; R [ r % 2 ] = r ; l ++ ; r -- ; if ( l <= tR && r >= tL ) { L [ l % 2 ] = l ; R [ r % 2 ] = r ; } int cnt0 = 0 , cnt1 = 0 ; if ( R [ 0 ] > 0 && L [ 0 ] > 0 ) cnt0 = ( R [ 0 ] - L [ 0 ] ) / 2 + 1 ; if ( R [ 1 ] > 0 && L [ 1 ] > 0 ) cnt1 = ( R [ 1 ] - L [ 1 ] ) / 2 + 1 ; int [ ] [ ] dp = new int [ n + 1 ] [ 3 ] ; dp [ 1 ] [ 0 ] = cnt0 ; dp [ 1 ] [ 1 ] = cnt1 ; for ( int i = 2 ; i <= n ; i ++ ) { dp [ i ] [ 0 ] = ( cnt0 * dp [ i - 1 ] [ 0 ] + cnt1 * dp [ i - 1 ] [ 1 ] ) ; dp [ i ] [ 1 ] = ( cnt0 * dp [ i - 1 ] [ 1 ] + cnt1 * dp [ i - 1 ] [ 0 ] ) ; } return dp [ n ] [ 0 ] ; } public static void main ( String [ ] args ) { int n = 2 , l = 1 , r = 3 ; System . out . println ( countWays ( n , l , r ) ) ; } }
import java . math . BigInteger ; class GFG { static void printPair ( int g , int l ) { int n = g * l ; for ( int i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { int first = i ; int second = n / i ; int gcd = __gcd ( first , second ) ; if ( gcd == g && l % first == 0 && l % second == 0 ) { System . out . println ( first + " ▁ " + second ) ; return ; } } } } private static int __gcd ( int a , int b ) { BigInteger b1 = new BigInteger ( " " + a ) ; BigInteger b2 = new BigInteger ( " " + b ) ; BigInteger gcd = b1 . gcd ( b2 ) ; return gcd . intValue ( ) ; } public static void main ( String [ ] args ) { int g = 3 , l = 12 ; printPair ( g , l ) ; } }
import java . util . * ; class GFG { static int count_pairs ( String s1 [ ] , String s2 [ ] , int n1 , int n2 ) { HashMap < String , Integer > mp = new HashMap < String , Integer > ( ) ; for ( int i = 0 ; i < n1 ; i ++ ) mp . put ( s1 [ i ] , 0 ) ; for ( int i = 0 ; i < n1 ; i ++ ) mp . put ( s1 [ i ] , mp . get ( s1 [ i ] ) + 1 ) ; int cnt = 0 ; for ( int i = 0 ; i < n2 ; i ++ ) { if ( mp . get ( s2 [ i ] ) > 0 ) { cnt ++ ; mp . put ( s2 [ i ] , mp . get ( s2 [ i ] ) - 1 ) ; } } return cnt ; } public static void main ( String [ ] args ) { String s1 [ ] = { " abc " , " def " } ; String s2 [ ] = { " abc " , " abc " } ; int n1 = s1 . length ; int n2 = s2 . length ; System . out . println ( count_pairs ( s1 , s2 , n1 , n2 ) ) ; } }
class MergeArrays { void moveToEnd ( int mPlusN [ ] , int size ) { int i , j = size - 1 ; for ( i = size - 1 ; i >= 0 ; i -- ) { if ( mPlusN [ i ] != - 1 ) { mPlusN [ j ] = mPlusN [ i ] ; j -- ; } } } void merge ( int mPlusN [ ] , int N [ ] , int m , int n ) { int i = n ; int j = 0 ; int k = 0 ; while ( k < ( m + n ) ) { if ( ( i < ( m + n ) && mPlusN [ i ] <= N [ j ] ) || ( j == n ) ) { mPlusN [ k ] = mPlusN [ i ] ; k ++ ; i ++ ; } else { mPlusN [ k ] = N [ j ] ; k ++ ; j ++ ; } } } void printArray ( int arr [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( " " ) ; } public static void main ( String [ ] args ) { MergeArrays mergearray = new MergeArrays ( ) ; int mPlusN [ ] = { 2 , 8 , - 1 , - 1 , - 1 , 13 , - 1 , 15 , 20 } ; int N [ ] = { 5 , 7 , 9 , 25 } ; int n = N . length ; int m = mPlusN . length - n ; mergearray . moveToEnd ( mPlusN , m + n ) ; mergearray . merge ( mPlusN , N , m , n ) ; mergearray . printArray ( mPlusN , m + n ) ; } }
class GFG { static boolean isDivisibleby17 ( int n ) { if ( n == 0 || n == 17 ) return true ; if ( n < 17 ) return false ; return isDivisibleby17 ( ( int ) ( n >> 4 ) - ( int ) ( n & 15 ) ) ; } public static void main ( String [ ] args ) { int n = 35 ; if ( isDivisibleby17 ( n ) == true ) System . out . printf ( " % d ▁ is ▁ divisible ▁ by ▁ 17" , n ) ; else System . out . printf ( " % d ▁ is ▁ not ▁ divisible ▁ by ▁ 17" , n ) ; } }
import java . io . * ; import java . util . * ; class GFG { static int min1 = Integer . MAX_VALUE ; static int count = 0 ; public int permutation ( String str1 , int i , int n , int p ) { if ( i == n ) { int q = Integer . parseInt ( str1 ) ; if ( q - p > 0 && q < min1 ) { min1 = q ; count = 1 ; } } else { for ( int j = i ; j <= n ; j ++ ) { str1 = swap ( str1 , i , j ) ; permutation ( str1 , i + 1 , n , p ) ; str1 = swap ( str1 , i , j ) ; } } return min1 ; } public String swap ( String str , int i , int j ) { char ch [ ] = str . toCharArray ( ) ; char temp = ch [ i ] ; ch [ i ] = ch [ j ] ; ch [ j ] = temp ; return String . valueOf ( ch ) ; } public static void main ( String [ ] args ) { int A = 213 ; int B = 111 ; GFG gfg = new GFG ( ) ; String str1 = Integer . toString ( A ) ; int len = str1 . length ( ) ; int h = gfg . permutation ( str1 , 0 , len - 1 , B ) ; if ( count == 1 ) System . out . println ( h ) ; else System . out . println ( - 1 ) ; } }
import java . io . * ; class GFG { static int stepRequired ( int n ) { return Integer . bitCount ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = 94 ; System . out . println ( stepRequired ( n ) ) ; } }
import java . io . * ; class GFG { static int countMultiples ( int n ) { int res = 0 ; for ( int i = 1 ; i <= n ; i ++ ) if ( i % 3 == 0 || i % 7 == 0 ) res ++ ; return res ; } public static void main ( String [ ] args ) { System . out . print ( " Count ▁ = ▁ " ) ; System . out . println ( countMultiples ( 25 ) ) ; } }
class GFG { static final int arr [ ] = { 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 1 , 2 , 3 , 4 , 1 , 2 , 3 , 1 , 2 , 3 , 4 } ; public static int countKeyPressed ( String str , int len ) { int count = 0 ; for ( int i = 0 ; i < len ; i ++ ) count = count + arr [ str . charAt ( i ) - ' a ' ] ; return count ; } public static void main ( String [ ] args ) { String str = " abcdef " ; int len = str . length ( ) ; System . out . print ( countKeyPressed ( str , len ) ) ; } }
public class SumOfSeries { static int fact ( int n ) { if ( n == 1 ) return 1 ; return n * fact ( n - 1 ) ; } static double sum ( int x , int n ) { double total = 1.0 ; for ( int i = 1 ; i <= n ; i ++ ) { total = total + ( Math . pow ( x , i ) / fact ( i + 1 ) ) ; } return total ; } public static void main ( String [ ] args ) { int x = 5 , n = 4 ; System . out . print ( " Sum ▁ is : ▁ " + sum ( x , n ) ) ; } }
import java . util . * ; class GFG { static int longestPermutation ( int arr [ ] , int n ) { HashMap < Integer , Integer > freq = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( freq . containsKey ( arr [ i ] ) ) { freq . put ( arr [ i ] , freq . get ( arr [ i ] ) + 1 ) ; } else { freq . put ( arr [ i ] , 1 ) ; } } int len = 0 ; for ( int i = 1 ; i <= n ; i ++ ) { if ( ! freq . containsKey ( i ) ) { break ; } len ++ ; } return len ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 2 , 1 , 6 , 5 } ; int n = arr . length ; System . out . print ( longestPermutation ( arr , n ) ) ; } }
class GFG { static int __gcd ( int a , int b ) { if ( a == 0 || b == 0 ) return 0 ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int findLCM ( int arr [ ] , int n ) { int lcm = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) { lcm = ( lcm * arr [ i ] ) / __gcd ( arr [ i ] , lcm ) ; } return lcm ; } static int countNumbers ( int arr [ ] , int n , int l , int r ) { int lcm = findLCM ( arr , n ) ; int count = ( r / lcm ) - ( ( l - 1 ) / lcm ) ; return count ; } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 4 , 2 } ; int n = arr . length ; int l = 1 , r = 10 ; System . out . println ( countNumbers ( arr , n , l , r ) ) ; } }
class GFG { static int max_element ( int a [ ] , int n ) { int m = Integer . MIN_VALUE ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , a [ i ] ) ; return m ; } static void findNum ( int a [ ] , int n , int b [ ] , int m ) { int x = max_element ( a , n ) ; int y = max_element ( b , m ) ; System . out . print ( x + " ▁ " + y ) ; } public static void main ( String args [ ] ) { int a [ ] = { 3 , 2 , 2 } ; int n = a . length ; int b [ ] = { 1 , 5 , 7 , 7 , 9 } ; int m = b . length ; findNum ( a , n , b , m ) ; } }
import java . util . * ; class GFG { static void type1 ( int [ ] arr , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) arr [ i ] ++ ; } static void type2 ( int [ ] arr , int [ ] [ ] query , int start , int limit ) { for ( int i = start ; i <= limit ; i ++ ) { if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; } } public static void main ( String [ ] args ) { int n = 5 , m = 5 ; int [ ] arr = new int [ n + 1 ] ; int [ ] temp = { 1 , 1 , 2 , 1 , 4 , 5 , 2 , 1 , 2 , 2 , 1 , 3 , 2 , 3 , 4 } ; int [ ] [ ] query = new int [ 6 ] [ 4 ] ; int j = 0 ; for ( int i = 1 ; i <= m ; i ++ ) { query [ i ] [ 0 ] = temp [ j ++ ] ; query [ i ] [ 1 ] = temp [ j ++ ] ; query [ i ] [ 2 ] = temp [ j ++ ] ; } for ( int i = 1 ; i <= m ; i ++ ) if ( query [ i ] [ 0 ] == 1 ) type1 ( arr , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; else if ( query [ i ] [ 0 ] == 2 ) type2 ( arr , query , query [ i ] [ 1 ] , query [ i ] [ 2 ] ) ; for ( int i = 1 ; i <= n ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; System . out . println ( ) ; } }
import java . io . * ; class GFG { static int count ( int S [ ] , int m , int n ) { if ( n == 0 ) return 1 ; if ( n < 0 ) return 0 ; if ( m <= 0 && n >= 1 ) return 0 ; return count ( S , m - 1 , n ) + count ( S , m , n - S [ m - 1 ] ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 } ; int m = arr . length ; System . out . println ( count ( arr , m , 4 ) ) ; } }
import java . util . Vector ; class GFG { static Vector < Integer > Divisors ( int x ) { int c = 0 ; Vector < Integer > v = new Vector < Integer > ( ) ; while ( x % 2 == 0 ) { c ++ ; x /= 2 ; } v . add ( c ) ; c = 0 ; while ( x % 3 == 0 ) { c ++ ; x /= 3 ; } v . add ( c ) ; c = 0 ; while ( x % 7 == 0 ) { c ++ ; x /= 7 ; } v . add ( c ) ; v . add ( x ) ; return v ; } static int MinOperations ( int a , int b ) { Vector < Integer > va = Divisors ( a ) ; Vector < Integer > vb = Divisors ( b ) ; if ( va . get ( 3 ) != vb . get ( 3 ) ) { return - 1 ; } int minOperations = Math . abs ( va . get ( 0 ) - vb . get ( 0 ) ) + Math . abs ( va . get ( 1 ) - vb . get ( 1 ) ) + Math . abs ( va . get ( 2 ) - vb . get ( 2 ) ) ; return minOperations ; } public static void main ( String [ ] args ) { int a = 14 , b = 28 ; System . out . println ( MinOperations ( a , b ) ) ; } }
import java . util . Arrays ; import java . util . HashSet ; import java . util . Set ; public class DistinctElements { public static boolean areDistinct ( Integer arr [ ] ) { Set < Integer > s = new HashSet < Integer > ( Arrays . asList ( arr ) ) ; return ( s . size ( ) == arr . length ) ; } public static void main ( String [ ] args ) { Integer [ ] arr = { 1 , 2 , 3 , 2 } ; if ( areDistinct ( arr ) ) System . out . println ( " All ▁ Elements ▁ are ▁ Distinct " ) ; else System . out . println ( " Not ▁ all ▁ Elements ▁ are ▁ Distinct " ) ; } }
import java . util . * ; class GFG { static Vector < Integer > createSemiPrimeSieve ( int n ) { int v [ ] = new int [ n + 1 ] ; for ( int i = 1 ; i <= n ; i ++ ) { v [ i ] = i ; } int countDivision [ ] = new int [ n + 1 ] ; for ( int i = 0 ; i < n + 1 ; i ++ ) { countDivision [ i ] = 2 ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( v [ i ] == i && countDivision [ i ] == 2 ) { for ( int j = 2 * i ; j <= n ; j += i ) { if ( countDivision [ j ] > 0 ) { v [ j ] = v [ j ] / i ; countDivision [ j ] -- ; } } } } Vector < Integer > res = new Vector < > ( ) ; for ( int i = 2 ; i <= n ; i ++ ) { if ( v [ i ] == 1 && countDivision [ i ] == 0 ) { res . add ( i ) ; } } return res ; } public static void main ( String [ ] args ) { int n = 16 ; Vector < Integer > semiPrime = createSemiPrimeSieve ( n ) ; for ( int i = 0 ; i < semiPrime . size ( ) ; i ++ ) { System . out . print ( semiPrime . get ( i ) + " ▁ " ) ; } } }
class Test { static boolean findPattern ( int n ) { int prev = n % 2 ; n = n / 2 ; while ( n > 0 ) { int curr = n % 2 ; if ( curr == prev ) return false ; prev = curr ; n = n / 2 ; } return true ; } public static void main ( String args [ ] ) { int n = 10 ; System . out . println ( findPattern ( n ) ? " Yes " : " No " ) ; } }
public class GFG { static int countSubstringWithEqualEnds ( String s ) { int result = 0 ; int n = s . length ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = i ; j < n ; j ++ ) if ( s . charAt ( i ) == s . charAt ( j ) ) result ++ ; return result ; } public static void main ( String args [ ] ) { String s = " abcab " ; System . out . println ( countSubstringWithEqualEnds ( s ) ) ; } }
class GFG { public static int arraySum ( int arr [ ] , int n ) { int sum = 0 ; for ( int i = 0 ; i < n ; i ++ ) sum = sum + arr [ i ] ; return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 11 , 12 , 13 , 12 , 11 , 10 } ; int n = arr . length ; System . out . print ( arraySum ( arr , n ) ) ; } }
import java . io . * ; class GFG { static float InscribedCircleArea ( float n , float a ) { if ( a < 0 && n < 0 ) return - 1 ; float r = a / ( float ) ( 2 * Math . tan ( ( 180 / n ) * 3.14159 / 180 ) ) ; float Area = ( float ) ( 3.14 ) * ( r ) * ( r ) ; return Area ; } public static void main ( String [ ] args ) { float n = 6 ; float a = 4 ; System . out . println ( InscribedCircleArea ( n , a ) ) ; } }
import java . util . * ; class GFG { static int minChanges ( int arr [ ] , int n ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( arr [ i ] ) ) { mp . put ( arr [ i ] , mp . get ( arr [ i ] ) + 1 ) ; } else { mp . put ( arr [ i ] , 1 ) ; } } int maxElem = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { maxElem = Math . max ( maxElem , entry . getValue ( ) ) ; } return n - maxElem ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 3 , 3 , 4 } ; int n = arr . length ; System . out . println ( minChanges ( arr , n ) ) ; } }
class GFG { static int factorial ( int n ) { int fact = 1 ; for ( int i = 2 ; i <= n ; i ++ ) fact = fact * i ; return ( fact ) ; } static int result ( int n , int m ) { return ( factorial ( n ) - factorial ( n - m + 1 ) * factorial ( m ) ) ; } public static void main ( String args [ ] ) { System . out . println ( result ( 5 , 3 ) ) ; } }
class GFG { static int maxN = 31 ; static int maxW = 31 ; static int dp [ ] [ ] [ ] = new int [ maxN ] [ maxW ] [ maxW ] ; static int maxWeight ( int arr [ ] , int n , int w1_r , int w2_r , int i ) { if ( i == n ) return 0 ; if ( dp [ i ] [ w1_r ] [ w2_r ] != - 1 ) return dp [ i ] [ w1_r ] [ w2_r ] ; int fill_w1 = 0 , fill_w2 = 0 , fill_none = 0 ; if ( w1_r >= arr [ i ] ) fill_w1 = arr [ i ] + maxWeight ( arr , n , w1_r - arr [ i ] , w2_r , i + 1 ) ; if ( w2_r >= arr [ i ] ) fill_w2 = arr [ i ] + maxWeight ( arr , n , w1_r , w2_r - arr [ i ] , i + 1 ) ; fill_none = maxWeight ( arr , n , w1_r , w2_r , i + 1 ) ; dp [ i ] [ w1_r ] [ w2_r ] = Math . max ( fill_none , Math . max ( fill_w1 , fill_w2 ) ) ; return dp [ i ] [ w1_r ] [ w2_r ] ; } public static void main ( String [ ] args ) { int arr [ ] = { 8 , 2 , 3 } ; for ( int i = 0 ; i < maxN ; i ++ ) for ( int j = 0 ; j < maxW ; j ++ ) for ( int k = 0 ; k < maxW ; k ++ ) dp [ i ] [ j ] [ k ] = - 1 ; int n = arr . length ; int w1 = 10 , w2 = 3 ; System . out . println ( maxWeight ( arr , n , w1 , w2 , 0 ) ) ; } }
import java . io . * ; class Count { public static void main ( String args [ ] ) { String str = " # GeeKs01fOr @ gEEks07" ; int upper = 0 , lower = 0 , number = 0 , special = 0 ; for ( int i = 0 ; i < str . length ( ) ; i ++ ) { char ch = str . charAt ( i ) ; if ( ch >= ' A ' && ch <= ' Z ' ) upper ++ ; else if ( ch >= ' a ' && ch <= ' z ' ) lower ++ ; else if ( ch >= '0' && ch <= '9' ) number ++ ; else special ++ ; } System . out . println ( " Lower ▁ case ▁ letters ▁ : ▁ " + lower ) ; System . out . println ( " Upper ▁ case ▁ letters ▁ : ▁ " + upper ) ; System . out . println ( " Number ▁ : ▁ " + number ) ; System . out . println ( " Special ▁ characters ▁ : ▁ " + special ) ; } }
class GFG { static int val ( char c ) { if ( c >= '0' && c <= '9' ) return ( int ) c - '0' ; else return ( int ) c - ' A ' + 10 ; } static int toDeci ( String str , int base ) { int len = str . length ( ) ; int power = 1 ; int num = 0 ; int i ; for ( i = len - 1 ; i >= 0 ; i -- ) { if ( val ( str . charAt ( i ) ) >= base ) { return - 1 ; } num += val ( str . charAt ( i ) ) * power ; power = power * base ; } return num ; } static void checkCorrespond ( String [ ] str , int x ) { int counter = 0 ; int n = str . length ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 2 ; j <= 36 ; j ++ ) { if ( toDeci ( str [ i ] , j ) == x ) { counter ++ ; break ; } } } if ( counter == n ) System . out . print ( " YES " + " \n " ) ; else System . out . print ( " NO " + " \n " ) ; } public static void main ( String [ ] args ) { int x = 16 ; String [ ] str = { "10000" , "20" , "16" } ; checkCorrespond ( str , x ) ; } }
import java . util . * ; class GFG { static int count ( int x , int y ) { int ans = 0 ; Map < Integer , Integer > m = new HashMap < > ( ) ; while ( x % y != 0 ) { x = x % y ; ans ++ ; if ( m . containsKey ( x ) ) return - 1 ; m . put ( x , 1 ) ; x = x * 10 ; } return ans ; } public static void main ( String [ ] args ) { int res = count ( 1 , 2 ) ; if ( ( res == - 1 ) ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; res = count ( 5 , 3 ) ; if ( ( res == - 1 ) ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; res = count ( 3 , 5 ) ; if ( ( res == - 1 ) ) System . out . println ( " INF " ) ; else System . out . println ( res ) ; } }
import java . io . * ; class GFG { static int nextPowerOf2 ( int n ) { int p = 1 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) return n ; while ( p < n ) p <<= 1 ; return p ; } public static void main ( String args [ ] ) { int n = 5 ; System . out . println ( nextPowerOf2 ( n ) ) ; } }
import java . util . Vector ; class GFG { static long LCM ( int arr [ ] , int n ) { int max_num = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( max_num < arr [ i ] ) { max_num = arr [ i ] ; } } long res = 1 ; int x = 2 ; while ( x <= max_num ) { Vector < Integer > indexes = new Vector < > ( ) ; for ( int j = 0 ; j < n ; j ++ ) { if ( arr [ j ] % x == 0 ) { indexes . add ( indexes . size ( ) , j ) ; } } if ( indexes . size ( ) >= 2 ) { for ( int j = 0 ; j < indexes . size ( ) ; j ++ ) { arr [ indexes . get ( j ) ] = arr [ indexes . get ( j ) ] / x ; } res = res * x ; } else { x ++ ; } } for ( int i = 0 ; i < n ; i ++ ) { res = res * arr [ i ] ; } return res ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 , 5 , 10 , 20 , 35 } ; int n = arr . length ; System . out . println ( LCM ( arr , n ) ) ; } }
class GFG { static int maxConsecutiveOnes ( int x ) { int count = 0 ; while ( x != 0 ) { x = ( x & ( x << 1 ) ) ; count ++ ; } return count ; } static int maxOnes ( int arr [ ] , int n ) { int ans = 0 ; for ( int i = 0 ; i < n ; i ++ ) { int currMax = maxConsecutiveOnes ( arr [ i ] ) ; ans = Math . max ( ans , currMax ) ; } return ans ; } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 2 , 3 , 4 } ; int n = arr . length ; System . out . println ( maxOnes ( arr , n ) ) ; } }
import java . io . * ; class GFG { static int countSegments ( int a [ ] , int n , int x ) { boolean flag = false ; int count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] > x ) { flag = true ; } else { if ( flag ) count += 1 ; flag = false ; } } if ( flag ) count += 1 ; return count ; } public static void main ( String [ ] args ) { int a [ ] = { 8 , 25 , 10 , 19 , 19 , 18 , 20 , 11 , 18 } ; int n = a . length ; int x = 13 ; System . out . println ( countSegments ( a , n , x ) ) ; } }
class GFG { static void line ( double x0 , double y0 ) { double c = ( int ) ( 2 * y0 * x0 ) ; System . out . println ( y0 + " x " + " ▁ + ▁ " + x0 + " y ▁ = ▁ " + c ) ; } public static void main ( String [ ] args ) { double x0 = 4 , y0 = 3 ; line ( x0 , y0 ) ; } }
import java . util . * ; class GFG { static int minDiff ( int n , int x , int A [ ] ) { int mn = A [ 0 ] , mx = A [ 0 ] ; for ( int i = 0 ; i < n ; ++ i ) { mn = Math . min ( mn , A [ i ] ) ; mx = Math . max ( mx , A [ i ] ) ; } return Math . max ( 0 , mx - mn - 2 * x ) ; } public static void main ( String [ ] args ) { int n = 3 , x = 3 ; int A [ ] = { 1 , 3 , 6 } ; System . out . println ( minDiff ( n , x , A ) ) ; } }
public class GFG { static int fact ( int num ) { int fact = 1 ; while ( num > 1 ) { fact *= num ; num -= 1 ; } return fact ; } static int catalan ( int n ) { return fact ( 2 * n ) / ( fact ( n ) * fact ( n + 1 ) ) ; } public static void main ( String [ ] args ) { int n = 5 ; int arr [ ] = { 1 , 2 , 3 , 4 , 5 } ; int i , k ; for ( k = 0 ; k < n ; k ++ ) { int s = 0 ; for ( i = 0 ; i < n ; i ++ ) { if ( arr [ i ] < arr [ k ] ) s += 1 ; } int catalan_leftBST = catalan ( s ) ; int catalan_rightBST = catalan ( n - s - 1 ) ; int totalBST = catalan_rightBST * catalan_leftBST ; System . out . print ( totalBST + " ▁ " ) ; } } }
class GFG { static void nthPalindrome ( int n , int k ) { int temp = ( k & 1 ) != 0 ? ( k / 2 ) : ( k / 2 - 1 ) ; int palindrome = ( int ) Math . pow ( 10 , temp ) ; palindrome += n - 1 ; System . out . print ( palindrome ) ; if ( ( k & 1 ) > 0 ) palindrome /= 10 ; while ( palindrome > 0 ) { System . out . print ( palindrome % 10 ) ; palindrome /= 10 ; } System . out . println ( " " ) ; } public static void main ( String [ ] args ) { int n = 6 , k = 5 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; n = 10 ; k = 6 ; System . out . print ( n + " th ▁ palindrome ▁ of ▁ " + k + " ▁ digit ▁ = ▁ " ) ; nthPalindrome ( n , k ) ; } }
class GFG { static int sum , n ; static float getAvg ( int x ) { sum += x ; return ( ( ( float ) sum ) / ++ n ) ; } static void streamAvg ( float [ ] arr , int n ) { float avg = 0 ; for ( int i = 0 ; i < n ; i ++ ) { avg = getAvg ( ( int ) arr [ i ] ) ; System . out . println ( " Average ▁ of ▁ " + ( i + 1 ) + " ▁ numbers ▁ is ▁ " + avg ) ; } return ; } public static void main ( String [ ] args ) { float [ ] arr = new float [ ] { 10 , 20 , 30 , 40 , 50 , 60 } ; int n = arr . length ; streamAvg ( arr , n ) ; } }
class GFG { static int Permutations ( int n , int k ) { int ans = 1 ; if ( k >= 2 ) ans += ( n ) * ( n - 1 ) / 2 ; if ( k >= 3 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * 2 / 6 ; if ( k >= 4 ) ans += ( n ) * ( n - 1 ) * ( n - 2 ) * ( n - 3 ) * 9 / 24 ; return ans ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; System . out . println ( Permutations ( n , k ) ) ; } }
class GFG { static class Node { int data ; Node next ; } ; static Node push ( Node head_ref , int new_data ) { Node new_node = new Node ( ) ; new_node . data = new_data ; new_node . next = ( head_ref ) ; ( head_ref ) = new_node ; return head_ref ; } static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static Node deleteNonPrimeNodes ( Node head_ref ) { Node ptr = head_ref ; while ( ptr != null && ! isPrime ( ptr . data ) ) { Node temp = ptr ; ptr = ptr . next ; } head_ref = ptr ; if ( ptr == null ) return null ; Node curr = ptr . next ; while ( curr != null ) { if ( ! isPrime ( curr . data ) ) { ptr . next = curr . next ; curr = ptr . next ; } else { ptr = curr ; curr = curr . next ; } } return head_ref ; } static void printList ( Node head ) { while ( head != null ) { System . out . print ( head . data + " ▁ " ) ; head = head . next ; } } public static void main ( String args [ ] ) { Node head = null ; head = push ( head , 17 ) ; head = push ( head , 7 ) ; head = push ( head , 6 ) ; head = push ( head , 16 ) ; head = push ( head , 15 ) ; System . out . print ( " Original ▁ List : ▁ " ) ; printList ( head ) ; head = deleteNonPrimeNodes ( head ) ; System . out . print ( " \n Modified ▁ List : ▁ " ) ; printList ( head ) ; } }
class GFG { static String findMinLenStr ( String str , int k ) { int n = str . length ( ) ; int st = 0 ; int end = 0 ; int cnt [ ] = new int [ 26 ] ; for ( int i = 0 ; i < 26 ; i ++ ) cnt [ i ] = 0 ; int distEle = 0 ; int currlen ; int minlen = n ; int startInd = - 1 ; while ( end < n ) { cnt [ str . charAt ( end ) - ' a ' ] ++ ; if ( cnt [ str . charAt ( end ) - ' a ' ] == 1 ) distEle ++ ; if ( distEle > k ) { while ( st < end && distEle > k ) { if ( cnt [ str . charAt ( st ) - ' a ' ] == 1 ) distEle -- ; cnt [ str . charAt ( st ) - ' a ' ] -- ; st ++ ; } } if ( distEle == k ) { while ( st < end && cnt [ str . charAt ( st ) - ' a ' ] > 1 ) { cnt [ str . charAt ( st ) - ' a ' ] -- ; st ++ ; } currlen = end - st + 1 ; if ( currlen < minlen ) { minlen = currlen ; startInd = st ; } } end ++ ; } return str . substring ( startInd , startInd + minlen ) ; } public static void main ( String args [ ] ) { String str = " efecfefd " ; int k = 4 ; System . out . println ( findMinLenStr ( str , k ) ) ; } }
class GFG { static int longestSubarray ( int arr [ ] , int n ) { int i , d ; int hash [ ] [ ] = new int [ 2 ] [ 10 ] ; for ( i = 0 ; i < 2 ; i ++ ) for ( int j = 0 ; j < 10 ; j ++ ) hash [ i ] [ j ] = 0 ; int currRow ; int maxLen = 1 ; int len = 0 ; int tmp ; tmp = arr [ 0 ] ; while ( tmp > 0 ) { hash [ 0 ] [ tmp % 10 ] = 1 ; tmp /= 10 ; } currRow = 1 ; for ( i = 1 ; i < n ; i ++ ) { tmp = arr [ i ] ; for ( d = 0 ; d <= 9 ; d ++ ) hash [ currRow ] [ d ] = 0 ; while ( tmp > 0 ) { hash [ currRow ] [ tmp % 10 ] = 1 ; tmp /= 10 ; } for ( d = 0 ; d <= 9 ; d ++ ) { if ( hash [ currRow ] [ d ] != 0 && hash [ 1 - currRow ] [ d ] != 0 ) { len ++ ; break ; } } if ( d == 10 ) { len = 1 ; } maxLen = Math . max ( maxLen , len ) ; currRow = 1 - currRow ; } return maxLen ; } public static void main ( String args [ ] ) { int arr [ ] = { 11 , 22 , 33 , 44 , 54 , 56 , 63 } ; int n = arr . length ; System . out . println ( longestSubarray ( arr , n ) ) ; } }
class GFG { static int sumNatural ( int n ) { int sum = ( n * ( n + 1 ) ) / 2 ; return sum ; } static int suminRange ( int l , int r ) { return sumNatural ( r ) - sumNatural ( l - 1 ) ; } public static void main ( String [ ] args ) { int l = 2 , r = 5 ; System . out . println ( " Sum ▁ of ▁ Natural ▁ numbers ▁ from ▁ L ▁ to ▁ R ▁ is ▁ " + suminRange ( l , r ) ) ; } }
public class GFG { static int findIndex ( String str ) { int len = str . length ( ) ; int open [ ] = new int [ len + 1 ] ; int close [ ] = new int [ len + 1 ] ; int index = - 1 ; open [ 0 ] = 0 ; close [ len ] = 0 ; if ( str . charAt ( 0 ) == ' ( ' ) open [ 1 ] = 1 ; if ( str . charAt ( len - 1 ) == ' ) ' ) close [ len - 1 ] = 1 ; for ( int i = 1 ; i < len ; i ++ ) { if ( str . charAt ( i ) == ' ( ' ) open [ i + 1 ] = open [ i ] + 1 ; else open [ i + 1 ] = open [ i ] ; } for ( int i = len - 2 ; i >= 0 ; i -- ) { if ( str . charAt ( i ) == ' ) ' ) close [ i ] = close [ i + 1 ] + 1 ; else close [ i ] = close [ i + 1 ] ; } if ( open [ len ] == 0 ) return len ; if ( close [ 0 ] == 0 ) return 0 ; for ( int i = 0 ; i <= len ; i ++ ) if ( open [ i ] == close [ i ] ) index = i ; return index ; } public static void main ( String [ ] args ) { String str = " ( ( ) ) ) ( ( ) ( ) ( ) ) ) ) " ; System . out . println ( findIndex ( str ) ) ; } }
public class GFG { static int findLen ( String A , int n , int k , char ch ) { int maxlen = 1 ; int cnt = 0 ; int l = 0 , r = 0 ; while ( r < n ) { if ( A . charAt ( r ) != ch ) ++ cnt ; while ( cnt > k ) { if ( A . charAt ( l ) != ch ) -- cnt ; ++ l ; } maxlen = Math . max ( maxlen , r - l + 1 ) ; ++ r ; } return maxlen ; } static int answer ( String A , int n , int k ) { int maxlen = 1 ; for ( int i = 0 ; i < 26 ; ++ i ) { maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' A ' ) ) ) ; maxlen = Math . max ( maxlen , findLen ( A , n , k , ( char ) ( i + ' a ' ) ) ) ; } return maxlen ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; String A = " ABABA " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( A , n , k ) ) ; n = 6 ; k = 4 ; String B = " HHHHHH " ; System . out . println ( " Maximum ▁ length ▁ = ▁ " + answer ( B , n , k ) ) ; } }
class Test { static boolean isTidy ( int num ) { int prev = 10 ; while ( num != 0 ) { int rem = num % 10 ; num /= 10 ; if ( rem > prev ) return false ; prev = rem ; } return true ; } public static void main ( String [ ] args ) { int num = 1556 ; System . out . println ( isTidy ( num ) ? " Yes " : " No " ) ; } }
class GFG { static boolean isPowerOfTwo ( int n ) { return n != 0 && ( ( n & ( n - 1 ) ) == 0 ) ; } static boolean isProthNumber ( int n ) { int k = 1 ; while ( k < ( n / k ) ) { if ( n % k == 0 ) { if ( isPowerOfTwo ( n / k ) ) return true ; } k = k + 2 ; } return false ; } public static void main ( String [ ] args ) { int n = 25 ; if ( isProthNumber ( n - 1 ) ) System . out . println ( " YES " ) ; else System . out . println ( " NO " ) ; } }
import java . util . * ; import static java . lang . Math . pow ; class Triangle { public static double numberOfTriangles ( int n ) { double ans = 2 * ( pow ( 3 , n ) ) - 1 ; return ans ; } public static void main ( String [ ] args ) { int n = 2 ; System . out . println ( numberOfTriangles ( n ) ) ; } }
import java . io . * ; class GFG { static int maximumNumberDistinctPrimeRange ( int m , int n ) { long factorCount [ ] = new long [ n + 1 ] ; boolean prime [ ] = new boolean [ n + 1 ] ; for ( int i = 0 ; i <= n ; i ++ ) { factorCount [ i ] = 0 ; prime [ i ] = true ; } for ( int i = 2 ; i <= n ; i ++ ) { if ( prime [ i ] == true ) { factorCount [ i ] = 1 ; for ( int j = i * 2 ; j <= n ; j += i ) { factorCount [ j ] ++ ; prime [ j ] = false ; } } } int max = ( int ) factorCount [ m ] ; int num = m ; for ( int i = m ; i <= n ; i ++ ) { if ( factorCount [ i ] > max ) { max = ( int ) factorCount [ i ] ; num = i ; } } return num ; } public static void main ( String [ ] args ) { int m = 4 , n = 6 ; System . out . println ( maximumNumberDistinctPrimeRange ( m , n ) ) ; } }
import java . io . * ; class GFG { static int findEvenPair ( int A [ ] , int N ) { int count = 0 ; for ( int i = 0 ; i < N ; i ++ ) { if ( A [ i ] % 2 != 0 ) count ++ ; } int totalPairs = ( N * ( N - 1 ) / 2 ) ; int oddEvenPairs = count * ( N - count ) ; return totalPairs - oddEvenPairs ; } public static void main ( String [ ] args ) { int a [ ] = { 5 , 4 , 7 , 2 , 1 } ; int n = a . length ; System . out . println ( findEvenPair ( a , n ) ) ; } }
import java . io . * ; import java . util . * ; import java . lang . * ; class GFG { static String wordReverse ( String str ) { int i = str . length ( ) - 1 ; int start , end = i + 1 ; String result = " " ; while ( i >= 0 ) { if ( str . charAt ( i ) == ' ▁ ' ) { start = i + 1 ; while ( start != end ) result += str . charAt ( start ++ ) ; result += ' ▁ ' ; end = i ; } i -- ; } start = 0 ; while ( start != end ) result += str . charAt ( start ++ ) ; return result ; } public static void main ( String [ ] args ) { String str = " I ▁ AM ▁ A ▁ GEEK " ; System . out . print ( wordReverse ( str ) ) ; } }
import java . io . * ; public class GFG { static boolean validate ( long n ) { for ( int i = 0 ; i < 10 ; i ++ ) { long temp = n ; int count = 0 ; while ( temp > 0 ) { if ( temp % 10 == i ) count ++ ; if ( count > i ) return false ; temp /= 10 ; } } return true ; } static public void main ( String [ ] args ) { long n = 1552793 ; if ( validate ( n ) ) System . out . println ( " True " ) ; else System . out . println ( " False " ) ; } }
public class GFG { static void towerOfHanoi ( int n , char from_rod , char to_rod , char aux_rod1 , char aux_rod2 ) { if ( n == 0 ) return ; if ( n == 1 ) { System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; return ; } towerOfHanoi ( n - 2 , from_rod , aux_rod1 , aux_rod2 , to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + aux_rod2 ) ; System . out . println ( " Move ▁ disk ▁ " + n + " ▁ from ▁ rod ▁ " + from_rod + " ▁ to ▁ rod ▁ " + to_rod ) ; System . out . println ( " Move ▁ disk ▁ " + ( n - 1 ) + " ▁ from ▁ rod ▁ " + aux_rod2 + " ▁ to ▁ rod ▁ " + to_rod ) ; towerOfHanoi ( n - 2 , aux_rod1 , to_rod , from_rod , aux_rod2 ) ; } public static void main ( String args [ ] ) { int n = 4 ; towerOfHanoi ( n , ' A ' , ' D ' , ' B ' , ' C ' ) ; } }
import java . util . HashMap ; class MajorityElement { private static void findMajority ( int [ ] arr ) { HashMap < Integer , Integer > map = new HashMap < Integer , Integer > ( ) ; for ( int i = 0 ; i < arr . length ; i ++ ) { if ( map . containsKey ( arr [ i ] ) ) { int count = map . get ( arr [ i ] ) + 1 ; if ( count > arr . length / 2 ) { System . out . println ( " Majority ▁ found ▁ : - ▁ " + arr [ i ] ) ; return ; } else map . put ( arr [ i ] , count ) ; } else map . put ( arr [ i ] , 1 ) ; } System . out . println ( " ▁ No ▁ Majority ▁ element " ) ; } public static void main ( String [ ] args ) { int a [ ] = new int [ ] { 2 , 2 , 2 , 2 , 5 , 5 , 2 , 3 , 3 } ; findMajority ( a ) ; } }
import java . io . * ; class GFG { static int MAX_K = 15 ; static int fac [ ] = new int [ MAX_K ] ; static void factorial ( int k ) { fac [ 0 ] = 1 ; for ( int i = 1 ; i <= k + 1 ; i ++ ) { fac [ i ] = ( i * fac [ i - 1 ] ) ; } } static int bin ( int a , int b ) { int ans = ( ( fac [ a ] ) / ( fac [ a - b ] * fac [ b ] ) ) ; return ans ; } static int sumofn ( int n , int k ) { int p = 0 ; int num1 , temp ; int arr [ ] = new int [ 1000 ] ; for ( int j = 1 ; j <= k ; j ++ ) { if ( j == 1 ) { num1 = ( n * ( n + 1 ) ) / 2 ; arr [ p ++ ] = num1 ; temp = num1 ; } else { temp = ( ( int ) Math . pow ( n + 1 , j + 1 ) - 1 - n ) ; for ( int s = 1 ; s < j ; s ++ ) { temp = temp - ( arr [ j - s - 1 ] * bin ( j + 1 , s + 1 ) ) ; } temp = temp / ( j + 1 ) ; arr [ p ++ ] = temp ; } } temp = arr [ p - 1 ] ; return temp ; } public static void main ( String [ ] args ) { int n = 5 , k = 2 ; factorial ( k ) ; System . out . println ( sumofn ( n , k ) ) ; } }
import java . util . * ; class solution { static int countPattern ( int n , String pat ) { int pattern_int = 0 ; int power_two = 1 ; int all_ones = 0 ; for ( int i = pat . length ( ) - 1 ; i >= 0 ; i -- ) { int current_bit = pat . charAt ( i ) - '0' ; pattern_int += ( power_two * current_bit ) ; all_ones = all_ones + power_two ; power_two = power_two * 2 ; } int count = 0 ; while ( n != 0 && n >= pattern_int ) { if ( ( n & all_ones ) == pattern_int ) { count ++ ; } n = n >> 1 ; } return count ; } public static void main ( String args [ ] ) { int n = 500 ; String pat = "10" ; System . out . println ( countPattern ( n , pat ) ) ; } }
class Divisible { public static int gcd ( int a , int b ) { return b == 0 ? a : gcd ( b , a % b ) ; } static boolean isDivisible ( int x , int y ) { if ( y == 1 ) return true ; int z = gcd ( x , y ) ; if ( z == 1 ) return false ; return isDivisible ( x , y / z ) ; } public static void main ( String [ ] args ) { int x = 18 , y = 12 ; if ( isDivisible ( x , y ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . util . * ; class GFG { static int LISusingLCS ( Vector < Integer > seq ) { int n = seq . size ( ) ; int L [ ] [ ] = new int [ n + 1 ] [ n + 1 ] ; Vector < Integer > sortedseq = new Vector < Integer > ( seq ) ; Collections . sort ( sortedseq ) ; for ( int i = 0 ; i <= n ; i ++ ) { for ( int j = 0 ; j <= n ; j ++ ) { if ( i == 0 || j == 0 ) L [ i ] [ j ] = 0 ; else if ( seq . get ( i - 1 ) == sortedseq . get ( j - 1 ) ) L [ i ] [ j ] = L [ i - 1 ] [ j - 1 ] + 1 ; else L [ i ] [ j ] = Math . max ( L [ i - 1 ] [ j ] , L [ i ] [ j - 1 ] ) ; } } return L [ n ] [ n ] ; } public static void main ( String args [ ] ) { Vector < Integer > sequence = new Vector < Integer > ( ) ; sequence . add ( 12 ) ; sequence . add ( 34 ) ; sequence . add ( 1 ) ; sequence . add ( 5 ) ; sequence . add ( 40 ) ; sequence . add ( 80 ) ; System . out . println ( LISusingLCS ( sequence ) ) ; } }
import java . util . * ; class GFG { static String findSmallest ( char [ ] s ) { int len = s . length ; int [ ] loccur = new int [ 26 ] ; Arrays . fill ( loccur , - 1 ) ; for ( int i = len - 1 ; i >= 0 ; -- i ) { int chI = s [ i ] - ' a ' ; if ( loccur [ chI ] == - 1 ) { loccur [ chI ] = i ; } } char [ ] sorted_s = s ; Arrays . sort ( sorted_s ) ; for ( int i = 0 ; i < len ; ++ i ) { if ( s [ i ] != sorted_s [ i ] ) { int chI = sorted_s [ i ] - ' a ' ; int last_occ = loccur [ chI ] ; char temp = s [ last_occ ] ; s [ last_occ ] = s [ i ] ; s [ i ] = temp ; break ; } } return String . valueOf ( s ) ; } public static void main ( String [ ] args ) { String s = " geeks " ; System . out . print ( findSmallest ( s . toCharArray ( ) ) ) ; } }
class Sequences { static int getTotalNumberOfSequences ( int m , int n ) { int T [ ] [ ] = new int [ m + 1 ] [ n + 1 ] ; for ( int i = 0 ; i < m + 1 ; i ++ ) { for ( int j = 0 ; j < n + 1 ; j ++ ) { if ( i == 0 || j == 0 ) T [ i ] [ j ] = 0 ; else if ( i < j ) T [ i ] [ j ] = 0 ; else if ( j == 1 ) T [ i ] [ j ] = i ; else T [ i ] [ j ] = T [ i - 1 ] [ j ] + T [ i / 2 ] [ j - 1 ] ; } } return T [ m ] [ n ] ; } public static void main ( String [ ] args ) { int m = 10 ; int n = 4 ; System . out . println ( " Total ▁ number ▁ of ▁ possible ▁ sequences ▁ " + getTotalNumberOfSequences ( m , n ) ) ; } }
import java . util . * ; class solution { static float area ( int x1 , int y1 , int z1 , int x2 , int y2 , int z2 ) { double a = Math . pow ( ( y1 * z2 - y2 * z1 ) , 2 ) + Math . pow ( ( x1 * z2 - x2 * z1 ) , 2 ) + Math . pow ( ( x1 * y2 - x2 * y1 ) , 2 ) ; float area = ( float ) Math . sqrt ( a ) ; area = area / 2 ; return area ; } public static void main ( String arr [ ] ) { int x1 = - 2 ; int y1 = 0 ; int z1 = - 5 ; int x2 = 1 ; int y2 = - 2 ; int z2 = - 1 ; float a = area ( x1 , y1 , z1 , x2 , y2 , z2 ) ; System . out . println ( " Area = ▁ " + a ) ; } }
class GFG { static float weightedMean ( int X [ ] , int W [ ] , int n ) { int sum = 0 , numWeight = 0 ; for ( int i = 0 ; i < n ; i ++ ) { numWeight = numWeight + X [ i ] * W [ i ] ; sum = sum + W [ i ] ; } return ( float ) ( numWeight ) / sum ; } public static void main ( String args [ ] ) { int X [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int W [ ] = { 1 , 2 , 3 , 4 , 5 , 6 , 7 , 8 , 9 , 10 } ; int n = X . length ; int m = W . length ; if ( n == m ) System . out . println ( weightedMean ( X , W , n ) ) ; else System . out . println ( " - 1" ) ; } }
class GFG { static int Log2n ( int n ) { return ( n > 1 ) ? 1 + Log2n ( n / 2 ) : 0 ; } static boolean isPowerOfd ( int n , int d ) { int count = 0 ; if ( n > 0 && ( n & ( n - 1 ) ) == 0 ) { while ( n > 1 ) { n >>= 1 ; count += 1 ; } return ( count % ( Log2n ( d ) ) == 0 ) ; } return false ; } public static void main ( String [ ] args ) { int n = 64 , d = 8 ; if ( isPowerOfd ( n , d ) ) System . out . println ( n + " ▁ is ▁ a ▁ power ▁ of ▁ " + d ) ; else System . out . println ( n + " ▁ is ▁ not ▁ a ▁ power ▁ of ▁ " + d ) ; } }
import java . util . * ; class GFG { static void printRepeating ( int arr [ ] , int n ) { for ( int i = 0 ; i < n ; i ++ ) { int index = arr [ i ] % n ; arr [ index ] += n ; } for ( int i = 0 ; i < n ; i ++ ) { if ( ( arr [ i ] / n ) > 1 ) System . out . println ( i + " ▁ " ) ; } } public static void main ( String args [ ] ) { int arr [ ] = { 1 , 6 , 3 , 1 , 3 , 6 , 6 } ; int arr_size = arr . length ; System . out . println ( " The ▁ repeating ▁ elements ▁ are : ▁ " ) ; printRepeating ( arr , arr_size ) ; } }
import java . util . * ; class GFG { static void countFreq ( int [ ] a , int n ) { HashMap < Integer , Integer > hm = new HashMap < > ( ) ; for ( int i = 0 ; i < n ; i ++ ) hm . put ( a [ i ] , hm . get ( a [ i ] ) == null ? 1 : hm . get ( a [ i ] ) + 1 ) ; SortedMap < Integer , Integer > st = new TreeMap < > ( ) ; for ( HashMap . Entry < Integer , Integer > x : hm . entrySet ( ) ) { st . put ( x . getKey ( ) , x . getValue ( ) ) ; } int cumul = 0 ; for ( SortedMap . Entry < Integer , Integer > x : st . entrySet ( ) ) { cumul += x . getValue ( ) ; System . out . println ( x . getKey ( ) + " ▁ " + cumul ) ; } } public static void main ( String [ ] args ) { int [ ] a = { 1 , 3 , 2 , 4 , 2 , 1 } ; int n = a . length ; countFreq ( a , n ) ; } }
class GFG { static void checkIfPowerIsolated ( int num ) { int input = num ; int count = 0 ; int [ ] factor = new int [ num + 1 ] ; if ( num % 2 == 0 ) { while ( num % 2 == 0 ) { ++ count ; num /= 2 ; } factor [ 2 ] = count ; } for ( int i = 3 ; i * i <= num ; i += 2 ) { count = 0 ; while ( num % i == 0 ) { ++ count ; num /= i ; } if ( count > 0 ) factor [ i ] = count ; } if ( num > 1 ) factor [ num ] = 1 ; int product = 1 ; for ( int i = 0 ; i < num + 1 ; i ++ ) { if ( factor [ i ] > 0 ) product = product * factor [ i ] * i ; } if ( product == input ) System . out . print ( " Power - isolated ▁ Integer \n " ) ; else System . out . print ( " Not ▁ a ▁ Power - isolated ▁ Integer \n " ) ; } public static void main ( String [ ] args ) { checkIfPowerIsolated ( 12 ) ; checkIfPowerIsolated ( 18 ) ; checkIfPowerIsolated ( 35 ) ; } }
import java . util . * ; class GFG { static int [ ] seats = new int [ ] { 1 , 2 , 4 } ; public static int maxAmount ( int M , int N ) { PriorityQueue < Integer > q = new PriorityQueue < Integer > ( Collections . reverseOrder ( ) ) ; for ( int i = 0 ; i < M ; i ++ ) { q . add ( seats [ i ] ) ; } int ticketSold = 0 ; int ans = 0 ; while ( ticketSold < N && q . peek ( ) > 0 ) { ans = ans + q . peek ( ) ; int temp = q . peek ( ) ; q . poll ( ) ; q . add ( temp - 1 ) ; ticketSold ++ ; } return ans ; } public static void main ( String [ ] args ) { int M = seats . length ; int N = 3 ; System . out . print ( maxAmount ( M , N ) ) ; } }
import java . util . * ; class GFG { static void countPairs ( int arr [ ] , int n , int k ) { int i , j , cnt = 0 ; for ( i = 0 ; i < n - 1 ; i ++ ) { for ( j = i + 1 ; j < n ; j ++ ) { if ( ( arr [ i ] - arr [ j ] + k ) % k == 0 ) cnt += 1 ; } } System . out . print ( cnt + " \n " ) ; } public static void main ( String [ ] args ) { int arr [ ] = { 3 , 3 , 3 } ; int k = 3 ; int n = arr . length ; countPairs ( arr , n , k ) ; } }
class GFG { static boolean canFormTeam ( int n , int m ) { if ( n >= 1 && m >= 2 ) return true ; if ( m >= 1 && n >= 2 ) return true ; return false ; } static int maxTeams ( int n , int m ) { int count = 0 ; while ( canFormTeam ( n , m ) ) { if ( n > m ) { n -= 2 ; m -= 1 ; } else { m -= 2 ; n -= 1 ; } count ++ ; } return count ; } public static void main ( String args [ ] ) { int n = 4 , m = 5 ; System . out . println ( maxTeams ( n , m ) ) ; } }
class GFG { static void printUncommon ( String str1 , String str2 ) { int a1 = 0 , a2 = 0 ; for ( int i = 0 ; i < str1 . length ( ) ; i ++ ) { int ch = ( str1 . charAt ( i ) ) - ' a ' ; a1 = a1 | ( 1 << ch ) ; } for ( int i = 0 ; i < str2 . length ( ) ; i ++ ) { int ch = ( str2 . charAt ( i ) ) - ' a ' ; a2 = a2 | ( 1 << ch ) ; } int ans = a1 ^ a2 ; int i = 0 ; while ( i < 26 ) { if ( ans % 2 == 1 ) { System . out . print ( ( char ) ( ' a ' + i ) ) ; } ans = ans / 2 ; i ++ ; } } public static void main ( String [ ] args ) { String str1 = " geeksforgeeks " ; String str2 = " geeksquiz " ; printUncommon ( str1 , str2 ) ; } }
import java . util . * ; class GFG { static class Node { int data ; Node next ; Node ( int data ) { this . data = data ; this . next = null ; } } ; static class treeNode { int data ; treeNode left ; treeNode right ; treeNode ( int data ) { this . data = data ; this . left = null ; this . right = null ; } } ; static void print ( Node head ) { if ( head == null ) { return ; } Node temp = head ; while ( temp != null ) { System . out . print ( temp . data + " ▁ " ) ; temp = temp . next ; } } static Node sortedList ( Node head , treeNode root ) { if ( root == null ) { return head ; } head = sortedList ( head , root . left ) ; Node newNode = new Node ( root . data ) ; Node temp = head ; Node prev = null ; if ( temp == null ) { head = newNode ; } else { while ( temp != null ) { if ( temp . data > root . data ) { break ; } else { prev = temp ; temp = temp . next ; } } if ( temp == null ) { prev . next = newNode ; } else { if ( prev == null ) { newNode . next = temp ; head = newNode ; } else { newNode . next = temp ; prev . next = newNode ; } } } head = sortedList ( head , root . right ) ; return head ; } public static void main ( String [ ] args ) { treeNode root = new treeNode ( 10 ) ; root . left = new treeNode ( 15 ) ; root . right = new treeNode ( 2 ) ; root . left . left = new treeNode ( 1 ) ; root . left . right = new treeNode ( 5 ) ; Node head = sortedList ( null , root ) ; print ( head ) ; } }
class GFG { static String longDivision ( String number , int divisor ) { String ans = " " ; int idx = 0 ; char [ ] num = number . toCharArray ( ) ; int temp = num [ idx ] - '0' ; while ( temp < divisor ) temp = temp * 10 + ( num [ ++ idx ] - '0' ) ; idx += 1 ; while ( num . length > idx ) { ans += ( temp / divisor ) ; temp = ( temp % divisor ) * 10 + num [ idx ++ ] - '0' ; } if ( ans . length ( ) == 0 ) return "0" ; return ans ; } public static void main ( String [ ] args ) { String number = "1248163264128256512" ; int divisor = 125 ; System . out . println ( longDivision ( number , divisor ) ) ; } }
import java . util . * ; class GFG { static boolean powerOfTwo ( int n ) { return ( ( n & n - 1 ) == 0 ) ; } static boolean onlyFirstAndLastAreSet ( int n ) { if ( n == 1 ) return true ; return powerOfTwo ( n - 1 ) ; } public static void main ( String [ ] args ) { int n = Integer . parseUnsignedInt ( "9" ) ; if ( onlyFirstAndLastAreSet ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
import java . io . * ; class GFG { static int countUnmarked ( int N ) { if ( N % 2 == 0 ) return N / 2 ; else return N / 2 + 1 ; } public static void main ( String [ ] args ) { int N = 4 ; System . out . println ( " Number ▁ of ▁ unmarked ▁ " + " elements : ▁ " + countUnmarked ( N ) ) ; } }
import java . util . Arrays ; public class PrintMissing { static void printMissing ( int ar [ ] , int low , int high ) { Arrays . sort ( ar ) ; int index = ceilindex ( ar , low , 0 , ar . length - 1 ) ; int x = low ; while ( index < ar . length && x <= high ) { if ( ar [ index ] != x ) { System . out . print ( x + " ▁ " ) ; } else index ++ ; x ++ ; } while ( x <= high ) { System . out . print ( x + " ▁ " ) ; x ++ ; } } static int ceilindex ( int ar [ ] , int val , int low , int high ) { if ( val < ar [ 0 ] ) return 0 ; if ( val > ar [ ar . length - 1 ] ) return ar . length ; int mid = ( low + high ) / 2 ; if ( ar [ mid ] == val ) return mid ; if ( ar [ mid ] < val ) { if ( mid + 1 < high && ar [ mid + 1 ] >= val ) return mid + 1 ; return ceilindex ( ar , val , mid + 1 , high ) ; } else { if ( mid - 1 >= low && ar [ mid - 1 ] < val ) return mid ; return ceilindex ( ar , val , low , mid - 1 ) ; } } public static void main ( String [ ] args ) { int arr [ ] = { 1 , 3 , 5 , 4 } ; int low = 1 , high = 10 ; printMissing ( arr , low , high ) ; } }
import java . io . * ; class GFG { static int findMaxAverage ( int [ ] arr , int n , int k ) { if ( k > n ) return - 1 ; int [ ] csum = new int [ n ] ; csum [ 0 ] = arr [ 0 ] ; for ( int i = 1 ; i < n ; i ++ ) csum [ i ] = csum [ i - 1 ] + arr [ i ] ; int max_sum = csum [ k - 1 ] , max_end = k - 1 ; for ( int i = k ; i < n ; i ++ ) { int curr_sum = csum [ i ] - csum [ i - k ] ; if ( curr_sum > max_sum ) { max_sum = curr_sum ; max_end = i ; } } return max_end - k + 1 ; } static public void main ( String [ ] args ) { int [ ] arr = { 1 , 12 , - 5 , - 6 , 50 , 3 } ; int k = 4 ; int n = arr . length ; System . out . println ( " The ▁ maximum ▁ " + " average ▁ subarray ▁ of ▁ length ▁ " + k + " ▁ begins ▁ at ▁ index ▁ " + findMaxAverage ( arr , n , k ) ) ; } }
import java . util . Collections ; import java . util . Comparator ; import java . util . HashMap ; import java . util . Iterator ; import java . util . Map ; class GFG { static int findSum ( int arr [ ] , int N ) { Map < Integer , Integer > mp = new HashMap < > ( ) ; for ( int i = 0 ; i < N ; i ++ ) mp . put ( arr [ i ] , mp . get ( arr [ i ] ) == null ? 1 : mp . get ( arr [ i ] ) + 1 ) ; int minFreq = Integer . MAX_VALUE ; minFreq = Collections . min ( mp . entrySet ( ) , Comparator . comparingInt ( Map . Entry :: getKey ) ) . getValue ( ) ; int sum = 0 ; for ( Map . Entry < Integer , Integer > entry : mp . entrySet ( ) ) { if ( entry . getValue ( ) == minFreq ) { sum += entry . getKey ( ) * entry . getValue ( ) ; } } return sum ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 20 , 30 , 40 , 40 } ; int N = arr . length ; System . out . println ( findSum ( arr , N ) ) ; } }
import java . util . * ; class Eulerian { public static String fibWord ( int n ) { String Sn_1 = "0" ; String Sn = "01" ; String tmp ; for ( int i = 2 ; i <= n ; i ++ ) { tmp = Sn ; Sn += Sn_1 ; Sn_1 = tmp ; } return Sn ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . print ( fibWord ( n ) ) ; } }
class GFG { public static int gen ( int n ) { if ( n == 0 ) return 0 ; else if ( n == 1 ) return 1 ; else if ( n % 2 == 0 ) return 4 * gen ( n / 2 ) ; else if ( n % 2 == 1 ) return 4 * gen ( n / 2 ) + 1 ; return 0 ; } public static void moserDeBruijn ( int n ) { for ( int i = 0 ; i < n ; i ++ ) System . out . print ( gen ( i ) + " ▁ " ) ; System . out . println ( ) ; } public static void main ( String args [ ] ) { int n = 15 ; System . out . println ( " First ▁ " + n + " ▁ terms ▁ of ▁ " + " Moser - de ▁ Bruijn ▁ Sequence ▁ : ▁ " ) ; moserDeBruijn ( n ) ; } }
import java . io . * ; class GFG { static int __gcd ( int a , int b ) { if ( a == 0 ) return b ; if ( b == 0 ) return a ; if ( a == b ) return a ; if ( a > b ) return __gcd ( a - b , b ) ; return __gcd ( a , b - a ) ; } static int MinDeletion ( int a [ ] , int n ) { int gcd = 0 ; for ( int i = 0 ; i < n ; i ++ ) gcd = __gcd ( gcd , a [ i ] ) ; if ( gcd > 1 ) return - 1 ; else return 0 ; } public static void main ( String [ ] args ) { int a [ ] = { 3 , 6 , 12 , 81 , 9 } ; int n = a . length ; System . out . print ( MinDeletion ( a , n ) ) ; } }
class GFG { static boolean isPrime ( int n ) { if ( n <= 1 ) return false ; if ( n <= 3 ) return true ; if ( n % 2 == 0 || n % 3 == 0 ) return false ; for ( int i = 5 ; i * i <= n ; i = i + 6 ) if ( n % i == 0 || n % ( i + 2 ) == 0 ) return false ; return true ; } static int nextPrime ( int N ) { if ( N <= 1 ) return 2 ; int prime = N ; boolean found = false ; while ( ! found ) { prime ++ ; if ( isPrime ( prime ) ) found = true ; } return prime ; } public static void main ( String [ ] args ) { int N = 3 ; System . out . println ( nextPrime ( N ) ) ; } }
import java . util . * ; class GFG { static Set < Integer > st = new HashSet < Integer > ( ) ; static void generateNumbers ( int n , int num , int a , int b ) { if ( num > 0 && num < n ) st . add ( num ) ; if ( num >= n ) return ; if ( num * 10 + a > num ) generateNumbers ( n , num * 10 + a , a , b ) ; generateNumbers ( n , num * 10 + b , a , b ) ; } static void printNumbers ( int n ) { for ( int i = 0 ; i <= 9 ; i ++ ) for ( int j = i + 1 ; j <= 9 ; j ++ ) generateNumbers ( n , 0 , i , j ) ; System . out . print ( " The ▁ numbers ▁ are : ▁ " ) ; System . out . print ( st ) ; st . clear ( ) ; } public static void main ( String args [ ] ) { int n = 12 ; printNumbers ( n ) ; } }
import java . lang . Math ; import java . io . * ; class GFG { static boolean checkPerfectSquare ( double n ) { double d = Math . sqrt ( n ) ; if ( d * d == n ) return true ; return false ; } static int largestPerfectSquareNumber ( int a [ ] , double n ) { int maxi = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( checkPerfectSquare ( a [ i ] ) ) maxi = Math . max ( a [ i ] , maxi ) ; } return maxi ; } public static void main ( String [ ] args ) { int [ ] a = { 16 , 20 , 25 , 2 , 3 , 10 } ; double n = a . length ; System . out . println ( largestPerfectSquareNumber ( a , n ) ) ; } }
import java . util . * ; class GFG { static boolean isVowel ( char c ) { return ( c == ' a ' || c == ' e ' || c == ' i ' || c == ' o ' || c == ' u ' ) ; } static int countSubstringsUtil ( char [ ] s ) { int count = 0 ; Map < Character , Integer > mp = new HashMap < > ( ) ; int n = s . length ; int start = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( mp . containsKey ( s [ i ] ) ) { mp . put ( s [ i ] , mp . get ( s [ i ] ) + 1 ) ; } else { mp . put ( s [ i ] , 1 ) ; } while ( mp . containsKey ( ' a ' ) && mp . containsKey ( ' e ' ) && mp . containsKey ( ' i ' ) && mp . containsKey ( ' o ' ) && mp . containsKey ( ' u ' ) && mp . get ( ' a ' ) > 0 && mp . get ( ' e ' ) > 0 && mp . get ( ' i ' ) > 0 && mp . get ( ' o ' ) > 0 && mp . get ( ' u ' ) > 0 ) { count += n - i ; mp . put ( s [ start ] , mp . get ( s [ start ] ) - 1 ) ; start ++ ; } } return count ; } static int countSubstrings ( String s ) { int count = 0 ; String temp = " " ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) { if ( isVowel ( s . charAt ( i ) ) ) { temp += s . charAt ( i ) ; } else { if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp . toCharArray ( ) ) ; temp = " " ; } } if ( temp . length ( ) > 0 ) count += countSubstringsUtil ( temp . toCharArray ( ) ) ; return count ; } public static void main ( String [ ] args ) { String s = " aeouisddaaeeiouua " ; System . out . println ( countSubstrings ( s ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static int findMaxValue ( ) { int res = 2 ; long fact = 2 ; while ( true ) { if ( fact < 0 ) break ; res ++ ; fact = fact * res ; } return res - 1 ; } public static void main ( String [ ] args ) { System . out . println ( " Maximum ▁ value ▁ of " + " ▁ integer ▁ " + findMaxValue ( ) ) ; } }
import java . util . * ; class Solution { static final int M = 20 ; static int dp [ ] [ ] [ ] [ ] = new int [ M ] [ M ] [ 2 ] [ 2 ] ; static int d , K ; static int count ( int pos , int cnt , int tight , int nonz , Vector < Integer > num ) { if ( pos == num . size ( ) ) { if ( cnt == K ) return 1 ; return 0 ; } if ( dp [ pos ] [ cnt ] [ tight ] [ nonz ] != - 1 ) return dp [ pos ] [ cnt ] [ tight ] [ nonz ] ; int ans = 0 ; int limit = ( ( tight != 0 ) ? 9 : num . get ( pos ) ) ; for ( int dig = 0 ; dig <= limit ; dig ++ ) { int currCnt = cnt ; if ( dig == d ) { if ( d != 0 || ( d == 0 && nonz != 0 ) ) currCnt ++ ; } int currTight = tight ; if ( dig < num . get ( pos ) ) currTight = 1 ; ans += count ( pos + 1 , currCnt , currTight , ( dig != 0 ? 1 : 0 ) , num ) ; } return dp [ pos ] [ cnt ] [ tight ] [ nonz ] = ans ; } static int solve ( int x ) { Vector < Integer > num = new Vector < Integer > ( ) ; while ( x != 0 ) { num . add ( x % 10 ) ; x /= 10 ; } Collections . reverse ( num ) ; for ( int i = 0 ; i < M ; i ++ ) for ( int j = 0 ; j < M ; j ++ ) for ( int k = 0 ; k < 2 ; k ++ ) for ( int l = 0 ; l < 2 ; l ++ ) dp [ i ] [ j ] [ k ] [ l ] = - 1 ; return count ( 0 , 0 , 0 , 0 , num ) ; } public static void main ( String args [ ] ) { int L = 11 , R = 100 ; d = 2 ; K = 1 ; System . out . print ( solve ( R ) - solve ( L - 1 ) ) ; } }
class GfG { static int getMaxLength ( int arr [ ] , int n ) { int start = 0 ; int preCnt = 0 ; while ( start < n && arr [ start ] == 1 ) { preCnt ++ ; start ++ ; } int end = n - 1 ; int suffCnt = 0 ; while ( end >= 0 && arr [ end ] == 1 ) { suffCnt ++ ; end -- ; } if ( start > end ) return n ; int midCnt = 0 ; int result = 0 ; for ( int i = start ; i <= end ; i ++ ) { if ( arr [ i ] == 1 ) { midCnt ++ ; result = Math . max ( result , midCnt ) ; } else { midCnt = 0 ; } } return Math . max ( result , preCnt + suffCnt ) ; } public static void main ( String [ ] args ) { int arr [ ] = new int [ ] { 1 , 1 , 0 , 0 , 1 , 0 , 1 , 0 , 1 , 1 , 1 , 1 } ; int n = arr . length ; System . out . println ( getMaxLength ( arr , n ) ) ; } }
class GFG { static int findMin ( int arr [ ] , int n ) { int m = 0 ; for ( int i = 0 ; i < n ; i ++ ) m = Math . max ( m , arr [ i ] ) ; int cnt [ ] = new int [ m + 2 ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 1 ; j * j <= arr [ i ] ; j ++ ) { if ( arr [ i ] % j == 0 ) { if ( j * j == arr [ i ] ) cnt [ j ] ++ ; else { cnt [ j ] ++ ; cnt [ arr [ i ] / j ] ++ ; } } } } for ( int i = 1 ; i <= m + 1 ; i ++ ) if ( cnt [ i ] == 0 ) { return i ; } return - 1 ; } public static void main ( String [ ] args ) { int arr [ ] = { 2 , 12 , 6 } ; int n = arr . length ; System . out . println ( findMin ( arr , n ) ) ; } }
import java . util . * ; import java . lang . * ; class GFG { public static int minJumps ( int arr [ ] , int N ) { int MAX = 1000000 ; int [ ] fib = new int [ 30 ] ; fib [ 0 ] = 0 ; fib [ 1 ] = 1 ; for ( int i = 2 ; i < 30 ; i ++ ) fib [ i ] = fib [ i - 1 ] + fib [ i - 2 ] ; int [ ] DP = new int [ N + 2 ] ; DP [ 0 ] = 0 ; for ( int i = 1 ; i <= N + 1 ; i ++ ) DP [ i ] = MAX ; for ( int i = 1 ; i <= N + 1 ; i ++ ) { for ( int j = 1 ; j < 30 ; j ++ ) { if ( ( i == N + 1 || arr [ i - 1 ] == 1 ) && i - fib [ j ] >= 0 ) DP [ i ] = Math . min ( DP [ i ] , 1 + DP [ i - fib [ j ] ] ) ; } } if ( DP [ N + 1 ] != MAX ) return DP [ N + 1 ] ; else return - 1 ; } public static void main ( String [ ] args ) { int [ ] arr = new int [ ] { 0 , 0 , 0 , 1 , 1 , 0 , 1 , 0 , 0 , 0 , 0 } ; int n = 11 ; int ans = minJumps ( arr , n ) ; System . out . println ( ans ) ; } }
import java . util . * ; class GFG { static int getHermiteNumber ( int n ) { if ( n == 0 ) return 1 ; else if ( n == 1 ) return 1 ; else return - 2 * ( n - 1 ) * getHermiteNumber ( n - 2 ) ; } public static void main ( String [ ] args ) { int n = 6 ; System . out . println ( getHermiteNumber ( n ) ) ; } }
class GFG { static void FindPoints ( int x1 , int y1 , int x2 , int y2 , int x3 , int y3 , int x4 , int y4 ) { int x5 = Math . max ( x1 , x3 ) ; int y5 = Math . max ( y1 , y3 ) ; int x6 = Math . min ( x2 , x4 ) ; int y6 = Math . min ( y2 , y4 ) ; if ( x5 > x6 || y5 > y6 ) { System . out . println ( " No ▁ intersection " ) ; return ; } System . out . print ( " ( " + x5 + " , ▁ " + y5 + " ) ▁ " ) ; System . out . print ( " ( " + x6 + " , ▁ " + y6 + " ) ▁ " ) ; int x7 = x5 ; int y7 = y6 ; System . out . print ( " ( " + x7 + " , ▁ " + y7 + " ) ▁ " ) ; int x8 = x6 ; int y8 = y5 ; System . out . print ( " ( " + x8 + " , ▁ " + y8 + " ) ▁ " ) ; } public static void main ( String args [ ] ) { int x1 = 0 , y1 = 0 , x2 = 10 , y2 = 8 ; int x3 = 2 , y3 = 3 , x4 = 7 , y4 = 9 ; FindPoints ( x1 , y1 , x2 , y2 , x3 , y3 , x4 , y4 ) ; } }
class GFG { static int numberOfDigits ( int n ) { int cnt = 0 ; while ( n > 0 ) { cnt ++ ; n /= 10 ; } return cnt ; } static void cal ( int num ) { int digits = numberOfDigits ( num ) ; int powTen = ( int ) Math . pow ( 10 , digits - 1 ) ; for ( int i = 0 ; i < digits - 1 ; i ++ ) { int firstDigit = num / powTen ; int left = ( ( num * 10 ) + firstDigit ) - ( firstDigit * powTen * 10 ) ; System . out . print ( left + " ▁ " ) ; num = left ; } } public static void main ( String [ ] args ) { int num = 1445 ; cal ( num ) ; } }
import java . io . * ; import java . util . * ; class GFG { public static void leastPrimeFactor ( int n ) { int [ ] least_prime = new int [ n + 1 ] ; least_prime [ 1 ] = 1 ; for ( int i = 2 ; i <= n ; i ++ ) { if ( least_prime [ i ] == 0 ) { least_prime [ i ] = i ; for ( int j = 2 * i ; j <= n ; j += i ) if ( least_prime [ j ] == 0 ) least_prime [ j ] = i ; } } for ( int i = 1 ; i <= n ; i ++ ) System . out . println ( " Least ▁ Prime ▁ factor ▁ of ▁ " + + i + " : ▁ " + least_prime [ i ] ) ; } public static void main ( String [ ] args ) { int n = 10 ; leastPrimeFactor ( n ) ; } }
public class Test { public static void main ( String [ ] args ) { System . out . println ( isPower ( 10 , 1 ) ? 1 : 0 ) ; System . out . println ( isPower ( 1 , 20 ) ? 1 : 0 ) ; System . out . println ( isPower ( 2 , 128 ) ? 1 : 0 ) ; System . out . println ( isPower ( 2 , 30 ) ? 1 : 0 ) ; } public static boolean isPower ( int x , int y ) { if ( x == 1 ) return ( y == 1 ) ; int pow = 1 ; while ( pow < y ) pow = pow * x ; return ( pow == y ) ; } }
import java . io . * ; class GFG { static void pattern ( int rows_no ) { int i , j , k ; for ( i = 1 ; i <= rows_no ; i ++ ) { for ( k = 1 ; k < i ; k ++ ) System . out . print ( " ▁ " ) ; for ( j = i ; j <= rows_no ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } for ( i = rows_no - 1 ; i >= 1 ; i -- ) { for ( k = 1 ; k < i ; k ++ ) System . out . print ( " ▁ " ) ; for ( j = i ; j <= rows_no ; j ++ ) System . out . print ( j + " ▁ " ) ; System . out . println ( ) ; } } public static void main ( String [ ] args ) { int rows_no = 7 ; pattern ( rows_no ) ; } }
import java . util . * ; import java . lang . * ; public class GfG { public static void printSmall ( int arr [ ] , int n , int k ) { for ( int i = k ; i < n ; ++ i ) { int max_var = arr [ k - 1 ] ; int pos = k - 1 ; for ( int j = k - 2 ; j >= 0 ; j -- ) { if ( arr [ j ] > max_var ) { max_var = arr [ j ] ; pos = j ; } } if ( max_var > arr [ i ] ) { int j = pos ; while ( j < k - 1 ) { arr [ j ] = arr [ j + 1 ] ; j ++ ; } arr [ k - 1 ] = arr [ i ] ; } } for ( int i = 0 ; i < k ; i ++ ) System . out . print ( arr [ i ] + " ▁ " ) ; } public static void main ( String argc [ ] ) { int [ ] arr = { 1 , 5 , 8 , 9 , 6 , 7 , 3 , 4 , 2 , 0 } ; int n = 10 ; int k = 5 ; printSmall ( arr , n , k ) ; } }
class GFG { static String smallest ( String s ) { int l = s . length ( ) ; String ans = " " ; for ( int i = 0 ; i < l - 1 ; i ++ ) { if ( s . charAt ( i ) > s . charAt ( i + 1 ) ) { for ( int j = 0 ; j < l ; j ++ ) { if ( i != j ) { ans += s . charAt ( j ) ; } } return ans ; } } ans = s . substring ( 0 , l - 1 ) ; return ans ; } public static void main ( String [ ] args ) { String s = " abcda " ; System . out . println ( smallest ( s ) ) ; } }
import java . util . * ; class GFG { static int countBits ( int n ) { int count = 0 ; while ( n > 0 ) { count ++ ; n >>= 1 ; } return count ; } static int findNearestNumber ( int n ) { int cnt = countBits ( n ) ; cnt -= 1 ; if ( cnt % 2 == 1 ) { return 1 << ( cnt + 1 ) ; } else { int tempnum = 0 ; for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum += 1 << i ; } if ( tempnum < n ) { return ( 1 << ( cnt + 2 ) ) ; } else if ( tempnum == n ) { return n ; } for ( int i = 0 ; i <= cnt ; i += 2 ) { tempnum -= ( 1 << i ) ; if ( tempnum < n ) { return tempnum += ( 1 << i ) ; } } } return Integer . MIN_VALUE ; } public static void main ( String [ ] args ) { int n = 19 ; System . out . println ( findNearestNumber ( n ) ) ; } }
import java . util . * ; class GFG { static int run_tasks ( Queue < Integer > A , Queue < Integer > B ) { int total_time = 0 ; while ( ! A . isEmpty ( ) ) { int x = A . peek ( ) ; int y = B . peek ( ) ; if ( x == y ) { A . remove ( ) ; B . remove ( ) ; total_time ++ ; } else { A . remove ( ) ; A . add ( x ) ; total_time += 2 ; } } return total_time ; } public static void main ( String [ ] args ) { Queue < Integer > A = new LinkedList < Integer > ( ) ; A . add ( 3 ) ; A . add ( 2 ) ; A . add ( 1 ) ; A . add ( 4 ) ; Queue < Integer > B = new LinkedList < Integer > ( ) ; B . add ( 4 ) ; B . add ( 1 ) ; B . add ( 3 ) ; B . add ( 2 ) ; System . out . print ( run_tasks ( A , B ) ) ; } }
import java . io . * ; import java . util . * ; class GFG { static void findAllSequences ( int diff , char out [ ] , int start , int end ) { if ( Math . abs ( diff ) > ( end - start + 1 ) / 2 ) return ; if ( start > end ) { if ( diff == 0 ) { System . out . print ( out ) ; System . out . print ( " ▁ " ) ; } return ; } out [ start ] = '0' ; out [ end ] = '1' ; findAllSequences ( diff + 1 , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '1' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = out [ end ] = '0' ; findAllSequences ( diff , out , start + 1 , end - 1 ) ; out [ start ] = '1' ; out [ end ] = '0' ; findAllSequences ( diff - 1 , out , start + 1 , end - 1 ) ; } public static void main ( String [ ] args ) { int n = 2 ; char [ ] out = new char [ 2 * n + 1 ] ; out [ 2 * n ] = ' \0' ; findAllSequences ( 0 , out , 0 , 2 * n - 1 ) ; } }
class GFG { static int Count_subarray ( int arr [ ] , int n ) { int total_sum = 0 , subarray_sum , remaining_sum , count = 0 ; for ( int i = 0 ; i < n ; i ++ ) { total_sum += arr [ i ] ; } for ( int i = 0 ; i < n ; i ++ ) { subarray_sum = 0 ; for ( int j = i ; j < n ; j ++ ) { subarray_sum += arr [ j ] ; remaining_sum = total_sum - subarray_sum ; if ( subarray_sum > remaining_sum ) { count += 1 ; } } } return count ; } public static void main ( String [ ] args ) { int arr [ ] = { 10 , 9 , 12 , 6 } ; int n = arr . length ; System . out . print ( Count_subarray ( arr , n ) ) ; } }
class GFG { static int count_setbits ( int N ) { int cnt = 0 ; while ( N > 0 ) { cnt += ( N & 1 ) ; N = N >> 1 ; } return cnt ; } static int countMultiples ( int n ) { int multiple [ ] = { 2 , 3 , 5 } ; int count = 0 , mask = ( int ) Math . pow ( 2 , 3 ) ; for ( int i = 1 ; i < mask ; i ++ ) { int prod = 1 ; for ( int j = 0 ; j < 3 ; j ++ ) { if ( ( i & 1 << j ) > 0 ) prod = prod * multiple [ j ] ; } if ( count_setbits ( i ) % 2 == 1 ) count = count + n / prod ; else count = count - n / prod ; } return count ; } public static void main ( String [ ] args ) { int n = 10 ; System . out . println ( countMultiples ( n ) ) ; } }
public class GFG { static int stringToInt ( String str ) { if ( str . length ( ) == 1 ) return ( str . charAt ( 0 ) - '0' ) ; double y = stringToInt ( str . substring ( 1 ) ) ; double x = str . charAt ( 0 ) - '0' ; x = x * Math . pow ( 10 , str . length ( ) - 1 ) + y ; return ( int ) ( x ) ; } public static void main ( String [ ] args ) { String str = "1235" ; System . out . print ( stringToInt ( str ) ) ; } }
class GFG { static int calcFunction ( int n , int r ) { int finalDenominator = 1 ; int mx = Math . max ( r , n - r ) ; for ( int i = mx + 1 ; i <= n ; i ++ ) { int denominator = ( int ) Math . pow ( i , i ) ; int numerator = ( int ) Math . pow ( i - mx , i - mx ) ; finalDenominator = ( finalDenominator * denominator ) / numerator ; } return finalDenominator ; } public static void main ( String [ ] args ) { int n = 6 , r = 2 ; System . out . println ( "1 / " + calcFunction ( n , r ) ) ; } }
import java . io . * ; class GFG { static int countDigits ( int n ) { double ans = 0 ; for ( int i = 1 ; i <= n ; i ++ ) ans += Math . log10 ( i ) ; ans = ans * n ; return 1 + ( int ) Math . floor ( ans ) ; } public static void main ( String [ ] args ) { int n = 4 ; System . out . println ( countDigits ( n ) + " \n " ) ; } }
import java . util . * ; class Geeks { static void ReplaceElements ( int arr [ ] , int n ) { int max_ele = arr [ 0 ] ; arr [ 0 ] = - 1 ; for ( int i = 1 ; i < n ; ++ i ) { if ( max_ele > arr [ i ] ) arr [ i ] = max_ele ; else if ( max_ele <= arr [ i ] ) { int temp = arr [ i ] ; arr [ i ] = max_ele ; max_ele = temp ; } } } public static void main ( String args [ ] ) { int arr [ ] = { 4 , 5 , 2 , 1 , 7 , 6 } ; int n = arr . length ; ReplaceElements ( arr , n ) ; for ( int i = 0 ; i < n ; ++ i ) System . out . println ( arr [ i ] ) ; } }
class GFG { static long nthTerm ( long n ) { long nth ; if ( n % 2 == 0 ) nth = 2 * ( ( n * n ) - n ) ; else nth = ( 2 * n * n ) - n ; return nth ; } public static void main ( String [ ] args ) { long n ; n = 5 ; System . out . println ( nthTerm ( n ) ) ; n = 25 ; System . out . println ( nthTerm ( n ) ) ; n = 25000000 ; System . out . println ( nthTerm ( n ) ) ; n = 250000007 ; System . out . println ( nthTerm ( n ) ) ; } }
import java . io . * ; class GFG { static void decToHexa ( int n ) { char [ ] hexaDeciNum = new char [ 100 ] ; int i = 0 ; while ( n != 0 ) { int temp = 0 ; temp = n % 16 ; if ( temp < 10 ) { hexaDeciNum [ i ] = ( char ) ( temp + 48 ) ; i ++ ; } else { hexaDeciNum [ i ] = ( char ) ( temp + 55 ) ; i ++ ; } n = n / 16 ; } for ( int j = i - 1 ; j >= 0 ; j -- ) System . out . print ( hexaDeciNum [ j ] ) ; } public static void main ( String [ ] args ) { int n = 2545 ; decToHexa ( n ) ; } }
class GFG { void fib ( int f [ ] ) { f [ 0 ] = 0 ; f [ 1 ] = 1 ; for ( int i = 2 ; i <= 59 ; i ++ ) f [ i ] = ( f [ i - 1 ] + f [ i - 2 ] ) % 10 ; } int findLastDigit ( long n ) { int f [ ] = new int [ 60 ] ; fib ( f ) ; int index = ( int ) ( n % 60L ) ; return f [ index ] ; } public static void main ( String [ ] args ) { long n ; GFG ob = new GFG ( ) ; n = 1 ; System . out . println ( ob . findLastDigit ( n ) ) ; n = 61 ; System . out . println ( ob . findLastDigit ( n ) ) ; n = 7 ; System . out . println ( ob . findLastDigit ( n ) ) ; n = 67 ; System . out . println ( ob . findLastDigit ( n ) ) ; } }
class GFG { static void arrayConstruct ( int N ) { for ( int i = 2 ; i <= N ; i = i + 2 ) System . out . print ( i + " ▁ " ) ; for ( int i = 1 ; i < N - 1 ; i = i + 2 ) System . out . print ( i + " ▁ " ) ; System . out . print ( N - 1 + ( N / 2 ) + " \n " ) ; } static void createArray ( int N ) { if ( N % 4 == 0 ) arrayConstruct ( N ) ; else System . out . print ( - 1 + " \n " ) ; } public static void main ( String [ ] args ) { int N = 8 ; createArray ( N ) ; } }
class GFG { static final int INT_BITS = 32 ; static int leftRotate ( int n , int d ) { return ( n << d ) | ( n >> ( INT_BITS - d ) ) ; } static int rightRotate ( int n , int d ) { return ( n >> d ) | ( n << ( INT_BITS - d ) ) ; } public static void main ( String arg [ ] ) { int n = 16 ; int d = 2 ; System . out . print ( " Left ▁ Rotation ▁ of ▁ " + n + " ▁ by ▁ " + d + " ▁ is ▁ " ) ; System . out . print ( leftRotate ( n , d ) ) ; System . out . print ( " \n Right ▁ Rotation ▁ of ▁ " + n + " ▁ by ▁ " + d + " ▁ is ▁ " ) ; System . out . print ( rightRotate ( n , d ) ) ; } }
import java . lang . Math ; class GFG { static float Area ( float r ) { if ( r < 0 ) return - 1 ; float x = ( 2 * r ) / ( float ) ( Math . sqrt ( 5 ) ) ; float A = 0.70477f * ( float ) ( Math . pow ( x , 2 ) ) ; return A ; } public static void main ( String [ ] args ) { float r = 5 ; System . out . println ( Area ( r ) ) ; } }
import java . io . * ; class GFG { static int maxLength ( String s , int n ) { int invalidOpenBraces = 0 ; int invalidCloseBraces = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( s . charAt ( i ) == ' ( ' ) { invalidOpenBraces ++ ; } else { if ( invalidOpenBraces == 0 ) { invalidCloseBraces ++ ; } else { invalidOpenBraces -- ; } } } return ( n - ( invalidOpenBraces + invalidCloseBraces ) ) ; } public static void main ( String [ ] args ) { String s = " ( ) ( ( ( ( ( ( ) " ; int n = s . length ( ) ; System . out . println ( maxLength ( s , n ) ) ; } }
import java . io . * ; class GFG { static int count_odd_pair ( int n , int a [ ] ) { int odd = 0 , even = 0 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] % 2 == 0 ) even ++ ; else odd ++ ; } int ans = odd * ( odd - 1 ) ; return ans ; } static int count_even_pair ( int odd_product_pairs , int n ) { int total_pairs = ( n * ( n - 1 ) ) ; int ans = total_pairs - odd_product_pairs ; return ans ; } public static void main ( String [ ] args ) { int n = 6 ; int [ ] a = { 2 , 4 , 5 , 9 , 1 , 8 } ; int odd_product_pairs = count_odd_pair ( n , a ) ; int even_product_pairs = count_even_pair ( odd_product_pairs , n ) ; System . out . println ( " Even ▁ Product ▁ Pairs ▁ = ▁ " + even_product_pairs ) ; System . out . println ( " Odd ▁ Product ▁ Pairs = ▁ " + odd_product_pairs ) ; } }
class GFG { static int isPowerOfFour ( int n ) { if ( n == 0 ) return 0 ; while ( n != 1 ) { if ( n % 4 != 0 ) return 0 ; n = n / 4 ; } return 1 ; } public static void main ( String [ ] args ) { int test_no = 64 ; if ( isPowerOfFour ( test_no ) == 1 ) System . out . println ( test_no + " ▁ is ▁ a ▁ power ▁ of ▁ 4" ) ; else System . out . println ( test_no + " is ▁ not ▁ a ▁ power ▁ of ▁ 4" ) ; } }
import java . io . * ; class GFG { static boolean isDivisible ( long n ) { while ( n / 100 > 0 ) { long d = n % 10 ; n /= 10 ; n -= d * 5 ; } return ( n % 17 == 0 ) ; } public static void main ( String [ ] args ) { long n = 19877658 ; if ( isDivisible ( n ) ) System . out . println ( " Yes " ) ; else System . out . println ( " No " ) ; } }
public final class p191 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p191 ( ) . run ( ) ) ; } private static final int NUM_DAYS = 30 ; private static final int MAX_ABSENT = 2 ; private static final int MAX_LATE = 1 ; public String run ( ) { long [ ] [ ] [ ] numPrizeStrings = new long [ NUM_DAYS + 1 ] [ MAX_ABSENT + 1 ] [ MAX_LATE + 1 ] ; numPrizeStrings [ 0 ] [ 0 ] [ 0 ] = 1 ; for ( int i = 1 ; i <= NUM_DAYS ; i ++ ) { for ( int j = 0 ; j <= MAX_ABSENT ; j ++ ) { for ( int k = 0 ; k <= MAX_LATE ; k ++ ) { long sum ; if ( j == 0 ) { sum = 0 ; for ( int l = 0 ; l <= MAX_ABSENT ; l ++ ) sum += numPrizeStrings [ i - 1 ] [ l ] [ k ] ; if ( k > 0 ) { for ( int l = 0 ; l <= MAX_ABSENT ; l ++ ) sum += numPrizeStrings [ i - 1 ] [ l ] [ k - 1 ] ; } } else sum = numPrizeStrings [ i - 1 ] [ j - 1 ] [ k ] ; numPrizeStrings [ i ] [ j ] [ k ] = sum ; } } } long sum = 0 ; for ( int j = 0 ; j <= MAX_ABSENT ; j ++ ) { for ( int k = 0 ; k <= MAX_LATE ; k ++ ) sum += numPrizeStrings [ NUM_DAYS ] [ j ] [ k ] ; } return Long . toString ( sum ) ; } }
public final class p044 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p044 ( ) . run ( ) ) ; } public String run ( ) { long minD = - 1 ; for ( int i = 2 ; ; i ++ ) { long pentI = pentagonalNumber ( i ) ; if ( minD != - 1 && pentI - pentagonalNumber ( i - 1 ) >= minD ) break ; for ( int j = i - 1 ; j >= 1 ; j -- ) { long pentJ = pentagonalNumber ( j ) ; long diff = pentI - pentJ ; if ( minD != - 1 && diff >= minD ) break ; else if ( isPentagonalNumber ( pentI + pentJ ) && isPentagonalNumber ( diff ) ) minD = diff ; } } return Long . toString ( minD ) ; } private static long pentagonalNumber ( int x ) { if ( x <= 0 ) throw new IllegalArgumentException ( ) ; return ( long ) x * ( x * 3 - 1 ) >>> 1 ; } private static boolean isPentagonalNumber ( long y ) { if ( y <= 0 ) return false ; long temp = y * 24 + 1 ; long sqrt = Library . sqrt ( temp ) ; return sqrt * sqrt == temp && sqrt % 6 == 5 ; } }
public final class p021 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p021 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i < 10000 ; i ++ ) { if ( isAmicable ( i ) ) sum += i ; } return Integer . toString ( sum ) ; } private static boolean isAmicable ( int n ) { int m = divisorSum ( n ) ; return m != n && divisorSum ( m ) == n ; } private static int divisorSum ( int n ) { int sum = 0 ; for ( int i = 1 ; i < n ; i ++ ) { if ( n % i == 0 ) sum += i ; } return sum ; } }
import java . util . Arrays ; public final class p122 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p122 ( ) . run ( ) ) ; } private static final int LIMIT = 200 ; private int [ ] minOperations ; private int numUnknown ; public String run ( ) { minOperations = new int [ LIMIT + 1 ] ; Arrays . fill ( minOperations , - 1 ) ; minOperations [ 0 ] = 0 ; minOperations [ 1 ] = 0 ; numUnknown = LIMIT - 1 ; for ( int ops = 1 ; numUnknown > 0 ; ops ++ ) { IntStack chain = new IntStack ( ops + 1 ) ; chain . push ( 1 ) ; exploreChains ( chain , ops ) ; } int sum = 0 ; for ( int x : minOperations ) sum += x ; return Integer . toString ( sum ) ; } private void exploreChains ( IntStack chain , int maxOps ) { if ( chain . size > maxOps || numUnknown == 0 ) return ; int max = chain . values [ chain . size - 1 ] ; for ( int i = chain . size - 1 ; i >= 0 ; i -- ) { for ( int j = i ; j >= 0 ; j -- ) { int x = chain . values [ i ] + chain . values [ j ] ; if ( x <= max ) break ; if ( x <= LIMIT ) { chain . push ( x ) ; if ( minOperations [ x ] == - 1 ) { minOperations [ x ] = chain . size - 1 ; numUnknown -- ; } exploreChains ( chain , maxOps ) ; chain . pop ( ) ; } } } } private static final class IntStack { public int [ ] values ; public int size ; public IntStack ( int capacity ) { values = new int [ capacity ] ; size = 0 ; } public void push ( int x ) { if ( size >= values . length ) throw new IllegalStateException ( ) ; values [ size ] = x ; size ++ ; } public int pop ( ) { if ( size <= 0 ) throw new IllegalStateException ( ) ; size -- ; return values [ size ] ; } } }
public final class p004 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p004 ( ) . run ( ) ) ; } public String run ( ) { int maxPalin = - 1 ; for ( int i = 100 ; i < 1000 ; i ++ ) { for ( int j = 100 ; j < 1000 ; j ++ ) { int prod = i * j ; if ( Library . isPalindrome ( prod ) && prod > maxPalin ) maxPalin = prod ; } } return Integer . toString ( maxPalin ) ; } }
public final class p216 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p216 ( ) . run ( ) ) ; } private static final int LIMIT = 50000000 ; public String run ( ) { long [ ] sequence = new long [ LIMIT + 1 ] ; sequence [ 0 ] = sequence [ 1 ] = - 1 ; for ( int i = 2 ; i < sequence . length ; i ++ ) sequence [ i ] = 2L * i * i - 1 ; int count = 0 ; for ( int i = 2 ; i < sequence . length ; i ++ ) { long term = sequence [ i ] ; if ( term == 2L * i * i - 1 ) count ++ ; if ( 1 < term && term <= LIMIT * 2 ) { int p = ( int ) term ; for ( int j = i + p ; j < sequence . length ; j += p ) { assert sequence [ j ] % p == 0 ; do sequence [ j ] /= p ; while ( sequence [ j ] % p == 0 ) ; } for ( int j = i + ( p - i ) * 2 % p ; j < sequence . length ; j += p ) { assert sequence [ j ] % p == 0 ; do sequence [ j ] /= p ; while ( sequence [ j ] % p == 0 ) ; } } } return Integer . toString ( count ) ; } }
public final class p009 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p009 ( ) . run ( ) ) ; } private static final int PERIMETER = 1000 ; public String run ( ) { for ( int a = 1 ; a < PERIMETER ; a ++ ) { for ( int b = a + 1 ; b < PERIMETER ; b ++ ) { int c = PERIMETER - a - b ; if ( a * a + b * b == c * c ) { return Integer . toString ( a * b * c ) ; } } } throw new AssertionError ( " Not ▁ found " ) ; } }
public final class p040 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p040 ( ) . run ( ) ) ; } public String run ( ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 1 ; i < 1000000 ; i ++ ) sb . append ( i ) ; int prod = 1 ; for ( int i = 0 ; i <= 6 ; i ++ ) prod *= sb . charAt ( Library . pow ( 10 , i ) - 1 ) - '0' ; return Integer . toString ( prod ) ; } }
import java . math . BigInteger ; public final class p014 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p014 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 6 ) ; public String run ( ) { int maxArg = - 1 ; int maxChain = 0 ; for ( int i = 1 ; i < LIMIT ; i ++ ) { int chainLen = collatzChainLength ( BigInteger . valueOf ( i ) ) ; if ( chainLen > maxChain ) { maxArg = i ; maxChain = chainLen ; } } return Integer . toString ( maxArg ) ; } private static final BigInteger CACHE_SIZE = BigInteger . valueOf ( LIMIT ) ; private int [ ] collatzChainLength = new int [ CACHE_SIZE . intValue ( ) ] ; private int collatzChainLength ( BigInteger n ) { if ( n . signum ( ) < 0 ) throw new IllegalArgumentException ( ) ; if ( n . compareTo ( CACHE_SIZE ) >= 0 ) return collatzChainLengthDirect ( n ) ; int index = n . intValue ( ) ; if ( collatzChainLength [ index ] == 0 ) collatzChainLength [ index ] = collatzChainLengthDirect ( n ) ; return collatzChainLength [ index ] ; } private int collatzChainLengthDirect ( BigInteger n ) { if ( n . equals ( BigInteger . ONE ) ) return 1 ; else if ( ! n . testBit ( 0 ) ) return collatzChainLength ( n . shiftRight ( 1 ) ) + 1 ; else return collatzChainLength ( n . multiply ( BigInteger . valueOf ( 3 ) ) . add ( BigInteger . ONE ) ) + 1 ; } }
import java . math . BigInteger ; import java . util . HashSet ; import java . util . Set ; public final class p203 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p203 ( ) . run ( ) ) ; } public String run ( ) { Set < Long > numbers = new HashSet < > ( ) ; long max = 0 ; for ( int n = 0 ; n <= 50 ; n ++ ) { for ( int k = 0 ; k <= n ; k ++ ) { BigInteger x = Library . binomial ( n , k ) ; if ( x . bitLength ( ) >= 64 ) throw new AssertionError ( " Number ▁ too ▁ large ▁ to ▁ handle " ) ; numbers . add ( x . longValue ( ) ) ; max = Math . max ( x . longValue ( ) , max ) ; } } int [ ] primes = Library . listPrimes ( ( int ) Library . sqrt ( max ) ) ; primesSquared = new long [ primes . length ] ; for ( int i = 0 ; i < primes . length ; i ++ ) primesSquared [ i ] = ( long ) primes [ i ] * primes [ i ] ; long sum = 0 ; for ( long n : numbers ) { if ( isSquarefree ( n ) ) sum += n ; } return Long . toString ( sum ) ; } private long [ ] primesSquared ; private boolean isSquarefree ( long n ) { for ( long p2 : primesSquared ) { if ( p2 > n ) break ; if ( n % p2 == 0 ) return false ; } return true ; } }
import java . math . BigInteger ; public final class p080 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p080 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; for ( int i = 1 ; i <= 100 ; i ++ ) { BigInteger x = BigInteger . valueOf ( i ) ; x = x . multiply ( BigInteger . TEN . pow ( 100 * 2 ) ) ; BigInteger y = sqrt ( x ) ; if ( ! y . multiply ( y ) . equals ( x ) ) { String s = y . toString ( ) . substring ( 0 , 100 ) ; for ( int j = 0 ; j < s . length ( ) ; j ++ ) sum += s . charAt ( j ) - '0' ; } } return Integer . toString ( sum ) ; } private static BigInteger sqrt ( BigInteger x ) { int i = 0 ; while ( BigInteger . TEN . pow ( i * 2 ) . compareTo ( x ) <= 0 ) i ++ ; BigInteger y = BigInteger . ZERO ; for ( ; i >= 0 ; i -- ) { int j ; BigInteger delta = null ; for ( j = 9 ; j >= 0 ; j -- ) { BigInteger temp = BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ; delta = y . shiftLeft ( 1 ) . add ( temp ) . multiply ( temp ) ; if ( delta . compareTo ( x ) <= 0 ) break ; } if ( j < 0 ) throw new AssertionError ( ) ; x = x . subtract ( delta ) ; y = y . add ( BigInteger . valueOf ( j ) . multiply ( BigInteger . TEN . pow ( i ) ) ) ; } return y ; } }
public final class p039 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p039 ( ) . run ( ) ) ; } public String run ( ) { int maxPerimeter = 0 ; int maxTriangles = 0 ; for ( int p = 1 ; p <= 1000 ; p ++ ) { int triangles = countSolutions ( p ) ; if ( triangles > maxTriangles ) { maxTriangles = triangles ; maxPerimeter = p ; } } return Integer . toString ( maxPerimeter ) ; } private static int countSolutions ( int p ) { int count = 0 ; for ( int a = 1 ; a <= p ; a ++ ) { for ( int b = a ; b <= p ; b ++ ) { int c = p - a - b ; if ( b <= c && a * a + b * b == c * c ) count ++ ; } } return count ; } }
public final class p549 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p549 ( ) . run ( ) ) ; } private static final int LIMIT = Library . pow ( 10 , 8 ) ; public String run ( ) { int [ ] smallestDivisibleFactorials = new int [ LIMIT + 1 ] ; for ( int i = 2 ; i < smallestDivisibleFactorials . length ; i ++ ) { if ( smallestDivisibleFactorials [ i ] == 0 ) { long power = 1 ; middle : for ( int j = i ; ; j += i ) { power *= i ; if ( power > LIMIT ) break ; for ( int inc = ( int ) power , k = inc ; k < smallestDivisibleFactorials . length ; k += inc ) smallestDivisibleFactorials [ k ] = Math . max ( j , smallestDivisibleFactorials [ k ] ) ; for ( int temp = j / i ; temp % i == 0 ; temp /= i ) { power *= i ; if ( power > LIMIT ) break middle ; } } } } long sum = 0 ; for ( int x : smallestDivisibleFactorials ) sum += x ; return Long . toString ( sum ) ; } }
public final class p132 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p132 ( ) . run ( ) ) ; } public String run ( ) { int sum = 0 ; int count = 0 ; for ( int i = 2 ; count < 40 ; i ++ ) { if ( Library . isPrime ( i ) && repunitMod ( 1000000000 , i ) == 0 ) { sum += i ; count ++ ; } } return Integer . toString ( sum ) ; } private static int repunitMod ( int k , int m ) { return ( Library . powMod ( 10 , k , m * 9 ) - 1 ) / 9 ; } }
import java . math . BigInteger ; public final class p005 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p005 ( ) . run ( ) ) ; } public String run ( ) { BigInteger allLcm = BigInteger . ONE ; for ( int i = 1 ; i <= 20 ; i ++ ) allLcm = lcm ( BigInteger . valueOf ( i ) , allLcm ) ; return allLcm . toString ( ) ; } private static BigInteger lcm ( BigInteger x , BigInteger y ) { return x . divide ( x . gcd ( y ) ) . multiply ( y ) ; } }
import java . math . BigInteger ; public final class p178 implements EulerSolution { public static void main ( String [ ] args ) { System . out . println ( new p178 ( ) . run ( ) ) ; } private static final int LIMIT = 40 ; public String run ( ) { BigInteger [ ] [ ] [ ] [ ] ways = new BigInteger [ LIMIT + 1 ] [ 10 ] [ 10 ] [ 10 ] ; BigInteger sum = BigInteger . ZERO ; for ( int digits = 0 ; digits < ways . length ; digits ++ ) { for ( int head = 0 ; head < 10 ; head ++ ) { for ( int low = 0 ; low < 10 ; low ++ ) { for ( int high = 0 ; high < 10 ; high ++ ) { BigInteger val ; if ( digits <= 1 ) val = ( low == head && head == high ) ? BigInteger . ONE : BigInteger . ZERO ; else { val = BigInteger . ZERO ; BigInteger [ ] [ ] [ ] prevWays = ways [ digits - 1 ] ; if ( head - 1 >= low ) { val = val . add ( prevWays [ head - 1 ] [ low ] [ high ] ) ; if ( head == high ) val = val . add ( prevWays [ head - 1 ] [ low ] [ high - 1 ] ) ; } if ( head + 1 <= high ) { val = val . add ( prevWays [ head + 1 ] [ low ] [ high ] ) ; if ( head == low ) val = val . add ( prevWays [ head + 1 ] [ low + 1 ] [ high ] ) ; } } ways [ digits ] [ head ] [ low ] [ high ] = val ; if ( head > 0 && low == 0 && high == 9 ) sum = sum . add ( val ) ; } } } } return sum . toString ( ) ; } }
class Solution { public boolean isToeplitzMatrix ( int [ ] [ ] matrix ) { for ( int r = 1 ; r < matrix . length ; ++ r ) for ( int c = 1 ; c < matrix [ 0 ] . length ; ++ c ) if ( matrix [ r - 1 ] [ c - 1 ] != matrix [ r ] [ c ] ) return false ; return true ; } }
class Solution { public int findKthLargest ( int [ ] nums , int k ) { shuffle ( nums ) ; k = nums . length - k ; int lo = 0 ; int hi = nums . length - 1 ; while ( lo < hi ) { final int j = partition ( nums , lo , hi ) ; if ( j < k ) { lo = j + 1 ; } else if ( j > k ) { hi = j - 1 ; } else { break ; } } return nums [ k ] ; } private int partition ( int [ ] a , int lo , int hi ) { int i = lo ; int j = hi + 1 ; while ( true ) { while ( i < hi && less ( a [ ++ i ] , a [ lo ] ) ) ; while ( j > lo && less ( a [ lo ] , a [ -- j ] ) ) ; if ( i >= j ) { break ; } exch ( a , i , j ) ; } exch ( a , lo , j ) ; return j ; } private void exch ( int [ ] a , int i , int j ) { final int tmp = a [ i ] ; a [ i ] = a [ j ] ; a [ j ] = tmp ; } private boolean less ( int v , int w ) { return v < w ; } private void shuffle ( int a [ ] ) { final Random random = new Random ( ) ; for ( int ind = 1 ; ind < a . length ; ind ++ ) { final int r = random . nextInt ( ind + 1 ) ; exch ( a , ind , r ) ; } } }
class KthLargest { final PriorityQueue < Integer > q ; final int k ; public KthLargest ( int k , int [ ] nums ) { this . k = k ; q = new PriorityQueue < > ( k ) ; for ( int val : nums ) add ( val ) ; } public int add ( int val ) { if ( q . size ( ) < k ) q . offer ( val ) ; else if ( q . peek ( ) < val ) { q . poll ( ) ; q . offer ( val ) ; } return q . peek ( ) ; } }
class Solution { public int compress ( char [ ] chars ) { int anchor = 0 , write = 0 ; for ( int read = 0 ; read < chars . length ; read ++ ) { if ( read + 1 == chars . length || chars [ read + 1 ] != chars [ read ] ) { chars [ write ++ ] = chars [ anchor ] ; if ( read > anchor ) { for ( char c : ( " " + ( read - anchor + 1 ) ) . toCharArray ( ) ) { chars [ write ++ ] = c ; } } anchor = read + 1 ; } } return write ; } }
class Solution { public int pivotIndex ( int [ ] nums ) { int totalsum = 0 , leftsum = 0 ; for ( int i = 0 ; i < nums . length ; i ++ ) totalsum += nums [ i ] ; for ( int i = 0 ; i < nums . length ; i ++ ) { if ( leftsum == totalsum - leftsum - nums [ i ] ) return i ; leftsum += nums [ i ] ; } return - 1 ; } }
class Solution { public int longestPalindrome ( String s ) { int [ ] count = new int [ 128 ] ; for ( char c : s . toCharArray ( ) ) count [ c ] ++ ; int ans = 0 ; for ( int v : count ) { ans += v / 2 * 2 ; if ( ans % 2 == 0 && v % 2 == 1 ) ans ++ ; } return ans ; } }
class Solution { public int missingNumber ( int [ ] nums ) { int res = nums . length ; for ( int i = 0 ; i < nums . length ; i ++ ) { res ^= i ; res ^= nums [ i ] ; } return res ; } }
class Solution { public List < String > subdomainVisits ( String [ ] cpdomains ) { Map < String , Integer > map = new HashMap ( ) ; for ( String cpdomain : cpdomains ) { int i = cpdomain . indexOf ( ' ▁ ' ) ; int n = Integer . valueOf ( cpdomain . substring ( 0 , i ) ) ; String domain = cpdomain . substring ( i + 1 ) ; for ( i = 0 ; i < domain . length ( ) ; ++ i ) { if ( domain . charAt ( i ) == ' . ' ) { String d = domain . substring ( i + 1 ) ; map . put ( d , map . getOrDefault ( d , 0 ) + n ) ; } } map . put ( domain , map . getOrDefault ( domain , 0 ) + n ) ; } List < String > res = new ArrayList ( ) ; for ( String domain : map . keySet ( ) ) res . add ( map . get ( domain ) + " ▁ " + domain ) ; return res ; } }
class Solution { public int [ ] plusOne ( int [ ] digits ) { return addToDigit ( digits , digits . length - 1 ) ; } private int [ ] addToDigit ( int [ ] digits , int index ) { if ( index == - 1 ) { int [ ] newDigits = new int [ digits . length + 1 ] ; newDigits [ 0 ] = 1 ; for ( int i = 0 ; i < digits . length ; i ++ ) { newDigits [ i + 1 ] = digits [ i ] ; } return newDigits ; } if ( digits [ index ] == 9 ) { digits [ index ] = 0 ; return addToDigit ( digits , index - 1 ) ; } else { digits [ index ] ++ ; return digits ; } } }
class Solution { public boolean isPerfectSquare ( int num ) { int low = 1 ; int high = num ; while ( low <= high ) { long mid = ( low + high ) >>> 1 ; if ( mid * mid == num ) { return true ; } else if ( mid * mid < num ) { low = ( int ) mid + 1 ; } else { high = ( int ) mid - 1 ; } } return false ; } }
class Solution { public char findTheDifference ( String s , String t ) { int total = t . charAt ( s . length ( ) ) ; for ( int i = 0 ; i < s . length ( ) ; i ++ ) total += ( t . charAt ( i ) - s . charAt ( i ) ) ; return ( char ) total ; } }
